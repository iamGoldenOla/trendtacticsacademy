{
  "course_title": "Vibe Coding: Building Real Software with AI",
  "module_title": "Module 5: Real-World Workflows",
  "lesson_number": 9,
  "lesson_title": "Building Complete Projects: Combining Vibe Coding Tools",
  "introduction": "You have now learned about Full-Stack Builders, AI-First IDEs, and Agentic Tools individually. In real projects, the most effective approach is often combining multiple tools strategically - using each for what it does best.\n\nThis lesson teaches you how professional Vibe Coders think about tool selection and combination. We will walk through complete project workflows from idea to deployment, showing when to switch tools and why. This synthesis of everything you have learned prepares you for real-world development.\n\nThe key insight is that there is no single 'best' tool - only the best tool for each phase of a project. Learning to flow between tools based on your current needs is what separates hobbyists from professionals.",
  "big_idea": "Effective Vibe Coding combines multiple tools strategically: Full-Stack Builders for rapid prototyping, AI-First IDEs for refinement and custom logic, and Agentic Tools for well-specified automation. Knowing when to use each tool and how to transition between them creates a workflow that is faster and produces better results than using any single tool exclusively.",
  "why_it_matters": "Real projects have phases: exploration, prototyping, building, refining, and maintaining. Each phase has different requirements. Using a Full-Stack Builder for everything leaves you stuck when you need customization. Using an AI-First IDE for everything wastes time on things generators do instantly. Understanding workflow optimization makes you dramatically more effective than developers who use one tool for everything.",
  "project_phases_and_tools": {
    "title": "Matching Tools to Project Phases",
    "phases": [
      {
        "phase": "Exploration",
        "goal": "Understand what is possible, validate ideas quickly",
        "recommended_tools": ["Bolt.new", "Lovable", "AI Chat (Claude/ChatGPT)"],
        "approach": "Generate quick prototypes to test ideas. Do not invest in code quality yet. Focus on learning what works.",
        "example": "Want to build a fitness tracker? Try 3 different versions in Bolt to see which approach feels right."
      },
      {
        "phase": "Prototyping",
        "goal": "Create a working version good enough for feedback",
        "recommended_tools": ["Lovable", "Bolt.new", "Replit"],
        "approach": "Build a complete prototype with core features. Quality matters more than exploration phase. Test with real users.",
        "example": "Take the best exploration prototype and refine it in Lovable until it is usable for beta testing."
      },
      {
        "phase": "Building",
        "goal": "Create production-quality code with proper architecture",
        "recommended_tools": ["Cursor", "Windsurf", "Replit"],
        "approach": "Either export from prototype and refine in AI-First IDE, or rebuild with better architecture using AI assistance.",
        "example": "Export Lovable project to GitHub, open in Cursor, refactor authentication for production security."
      },
      {
        "phase": "Refining",
        "goal": "Optimize performance, fix edge cases, polish UX",
        "recommended_tools": ["Cursor", "Windsurf"],
        "approach": "Deep work with AI assistance. Debug, optimize, and handle edge cases with full codebase understanding.",
        "example": "Use Cursor to optimize database queries, add error handling, implement caching."
      },
      {
        "phase": "Maintaining",
        "goal": "Fix bugs, add features, keep system healthy",
        "recommended_tools": ["Cursor", "Agentic Tools for specific tasks"],
        "approach": "AI-First IDE for ongoing work. Delegate well-specified tasks to agents when appropriate.",
        "example": "Use Cursor for quick bug fixes. Delegate 'migrate all API calls to new SDK version' to Devin."
      }
    ]
  },
  "workflow_case_studies": [
    {
      "project": "SaaS Dashboard Application",
      "description": "A subscription management dashboard for small businesses",
      "workflow": [
        {
          "step": 1,
          "tool": "Bolt.new",
          "action": "Generate initial dashboard concept with user management, subscription display, and basic charts",
          "time": "30 minutes",
          "outcome": "Working prototype to show stakeholders and validate concept"
        },
        {
          "step": 2,
          "tool": "Lovable",
          "action": "Rebuild with better design - proper component architecture, consistent styling, responsive layout",
          "time": "2 hours",
          "outcome": "Beautiful prototype ready for user testing"
        },
        {
          "step": 3,
          "tool": "Cursor",
          "action": "Export to local project. Add real authentication with Supabase. Implement Stripe subscription logic.",
          "time": "4 hours",
          "outcome": "Production-ready authentication and payment system"
        },
        {
          "step": 4,
          "tool": "Cursor",
          "action": "Optimize database queries, add caching, implement proper error handling, write tests",
          "time": "3 hours",
          "outcome": "Production-quality application ready for deployment"
        }
      ],
      "total_time": "Under 10 hours",
      "traditional_time": "40-60 hours"
    },
    {
      "project": "E-commerce Store",
      "description": "A simple online store with product catalog and checkout",
      "workflow": [
        {
          "step": 1,
          "tool": "Lovable",
          "action": "Generate beautiful storefront with product grid, cart, and checkout flow",
          "time": "1 hour",
          "outcome": "Visually complete prototype with mock data"
        },
        {
          "step": 2,
          "tool": "Replit",
          "action": "Add backend: product database, inventory management, order processing",
          "time": "3 hours",
          "outcome": "Full-stack application with real data persistence"
        },
        {
          "step": 3,
          "tool": "Cursor",
          "action": "Integrate Stripe payments, add email notifications, implement order tracking",
          "time": "4 hours",
          "outcome": "Complete e-commerce functionality"
        },
        {
          "step": 4,
          "tool": "Agentic (if available)",
          "action": "Delegate: Generate product import script from CSV, create admin dashboard for inventory",
          "time": "1 hour supervision",
          "outcome": "Admin tools for ongoing operations"
        }
      ],
      "total_time": "Under 10 hours",
      "traditional_time": "50-80 hours"
    }
  ],
  "tool_transition_strategies": [
    {
      "transition": "Full-Stack Builder to AI-First IDE",
      "when": "Prototype is validated and you need production-quality code",
      "how": [
        "Export or download the generated code",
        "Open in Cursor or your preferred IDE",
        "Use Chat to understand the generated architecture",
        "Identify areas needing refactoring (usually auth, data, security)",
        "Incrementally improve while maintaining functionality"
      ]
    },
    {
      "transition": "AI-First IDE to Agentic Tool",
      "when": "You have a well-specified, bounded task within a larger project",
      "how": [
        "Identify a task with clear requirements and measurable completion",
        "Write detailed specification with constraints",
        "Delegate to agent",
        "Review output in your IDE",
        "Integrate approved changes"
      ]
    }
  ],
  "decision_framework": {
    "title": "Quick Tool Selection Guide",
    "questions": [
      {
        "question": "Do I need a working prototype in under 2 hours?",
        "if_yes": "Use Bolt.new or Lovable",
        "if_no": "Continue to next question"
      },
      {
        "question": "Is design quality critical for this phase?",
        "if_yes": "Use Lovable",
        "if_no": "Use Bolt.new for speed"
      },
      {
        "question": "Do I need custom backend logic or integrations?",
        "if_yes": "Use Replit or export to Cursor",
        "if_no": "Full-Stack Builders may be sufficient"
      },
      {
        "question": "Am I working with an existing codebase?",
        "if_yes": "Use Cursor or Windsurf",
        "if_no": "Consider starting with generators"
      },
      {
        "question": "Is this task well-specified and can be delegated entirely?",
        "if_yes": "Consider agentic tools",
        "if_no": "Stay with AI-First IDE for guided development"
      }
    ]
  },
  "steps": [
    "Step 1: Identify which project phase you are in",
    "Step 2: Choose the tool best suited for that phase",
    "Step 3: Set clear goals for what you want to achieve before transitioning",
    "Step 4: When goals are met, export/transition to the next tool",
    "Step 5: Use the decision framework when uncertain"
  ],
  "playground_activity": "Plan a complete project workflow: You want to build a personal finance tracker that categorizes expenses, shows spending trends, and sends weekly summary emails. Write out: 1) Which tool for initial exploration 2) Which tool for prototype 3) Which tool for production build 4) What features need AI-First IDE work 5) What tasks could be delegated to agents",
  "reflection_question": "Think about a project you built (or wanted to build) in the past. How would you approach it differently now using this multi-tool workflow? What phases would you handle differently?",
  "quiz": {
    "questions": [
      "What is the main advantage of combining multiple Vibe Coding tools?",
      "Which project phase is best suited for Full-Stack Builders like Bolt?",
      "When should you transition from a Full-Stack Builder to an AI-First IDE?",
      "What type of work is best delegated to Agentic tools?",
      "Why is it faster to prototype in generators then refine in IDEs versus building everything in an IDE?"
    ],
    "answers": [
      "Each tool excels at different phases - combining them uses each for what it does best, creating faster and better results",
      "Exploration and prototyping phases - when you need working software quickly to validate ideas",
      "When the prototype is validated and you need production-quality code with proper security, architecture, and performance",
      "Well-specified, bounded tasks with clear requirements and measurable completion criteria",
      "Generators produce working software instantly for structure/design; IDEs are better for precision work but slower for initial creation"
    ],
    "options": [
      [
        "Using one tool is simpler and more efficient",
        "Each tool excels at different phases - combining them uses each for what it does best, creating faster and better results",
        "Combining tools creates more complexity and confusion",
        "All tools have the same capabilities"
      ],
      [
        "Building and refining phases",
        "Exploration and prototyping phases - when you need working software quickly to validate ideas",
        "Maintaining phase",
        "Only for security-critical work"
      ],
      [
        "When you want to start a new project",
        "When the prototype is validated and you need production-quality code with proper security, architecture, and performance",
        "When you need to explore ideas",
        "When you only need a simple prototype"
      ],
      [
        "Ambiguous tasks with unclear requirements",
        "Well-specified, bounded tasks with clear requirements and measurable completion criteria",
        "Creative and exploratory tasks",
        "Tasks that require human judgment"
      ],
      [
        "IDEs are faster than generators",
        "Generators produce working software instantly for structure/design; IDEs are better for precision work but slower for initial creation",
        "There is no difference in speed between generators and IDEs",
        "Generators are always slower than IDEs"
      ]
    ]
  },
  "key_takeaways": [
    "Different tools excel at different project phases",
    "Exploration/prototyping: Full-Stack Builders",
    "Building/refining: AI-First IDEs",
    "Well-specified automation: Agentic Tools",
    "Smooth transitions between tools multiply your effectiveness"
  ],
  "resources": {
    "video": {
      "title": "Complete Project Workflow: Idea to Deployment",
      "url": "https://www.youtube.com/watch?v=example",
      "embed": true,
      "reason": "Watch a real project built using multiple Vibe Coding tools"
    },
    "extra_reading": [
      "https://trendtacticsdigital.com/blog/vibe-workflow - Our multi-tool workflow guide",
      "https://trendtacticsdigital.com/blog/tool-comparison - Detailed tool comparison matrix"
    ]
  },
  "summary": "In this lesson, you learned to combine Vibe Coding tools strategically for complete project workflows. You now understand which tools suit which project phases and how to transition between them smoothly. The key insight is that mastering the multi-tool workflow is what separates professional Vibe Coders from hobbyists. In the next lesson, we will focus on prompt engineering specifically for code generation."
}
