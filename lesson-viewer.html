<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.youtube.com https://youtube.com https://s.ytimg.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: blob: https: http:; frame-src 'self' https://www.youtube.com https://youtube.com https://*.youtube.com; child-src 'self' https://www.youtube.com https://youtube.com; connect-src 'self' https: wss:; media-src 'self' https: blob:;">
    <title>Course Viewer - Trendtactics Academy</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“–</text></svg>" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00D9FF;
            --primary-dark: #00B8D9;
            --secondary: #7C3AED;
            --bg-dark: #0B1437;
            --bg-darker: #060D24;
            --bg-card: rgba(15, 25, 55, 0.95);
            --text-primary: #FFFFFF;
            --text-secondary: #94A3B8;
            --text-muted: #64748B;
            --success: #10B981;
            --error: #EF4444;
            --border: rgba(0, 217, 255, 0.2);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: var(--bg-darker); min-height: 100vh; color: var(--text-primary); display: flex; flex-direction: column; }
        
        /* Header */
        .header { background: var(--bg-dark); border-bottom: 1px solid var(--border); padding: 0.6rem 1rem; }
        .header-content { max-width: 1600px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; gap: 1rem; flex-wrap: wrap; }
        .logo { font-size: 1rem; font-weight: 700; background: linear-gradient(135deg, var(--primary), var(--secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .nav { display: flex; gap: 0.4rem; flex-wrap: wrap; }
        .nav a { color: var(--text-secondary); text-decoration: none; padding: 0.4rem 0.6rem; border-radius: 6px; font-size: 0.8rem; transition: all 0.2s; }
        .nav a:hover { color: var(--primary); background: rgba(0, 217, 255, 0.1); }

        /* Main Layout */
        .main-layout { flex: 1; display: flex; overflow: hidden; }

        /* Sidebar - Lesson List */
        .sidebar { width: 280px; background: var(--bg-dark); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }
        .sidebar-header { padding: 1rem; border-bottom: 1px solid var(--border); }
        .sidebar-header h2 { font-size: 0.9rem; color: var(--text-primary); margin-bottom: 0.25rem; }
        .sidebar-header p { font-size: 0.75rem; color: var(--text-muted); }
        .lesson-list { flex: 1; overflow-y: auto; padding: 0.5rem; }
        .module-group { margin-bottom: 1rem; }
        .module-title { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; padding: 0.5rem; margin-bottom: 0.25rem; }
        .lesson-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; border-radius: 8px; cursor: pointer; transition: all 0.2s; margin-bottom: 0.25rem; }
        .lesson-item:hover { background: rgba(0, 217, 255, 0.1); }
        .lesson-item.active { background: rgba(0, 217, 255, 0.15); border-left: 3px solid var(--primary); }
        .lesson-item.completed { opacity: 0.7; }
        .lesson-num { width: 24px; height: 24px; background: var(--bg-darker); border: 1px solid var(--border); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: 600; flex-shrink: 0; }
        .lesson-item.active .lesson-num { background: var(--primary); color: var(--bg-darker); border-color: var(--primary); }
        .lesson-item.completed .lesson-num { background: var(--success); color: white; border-color: var(--success); }
        .lesson-info { flex: 1; min-width: 0; }
        .lesson-name { font-size: 0.8rem; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .lesson-duration { font-size: 0.7rem; color: var(--text-muted); }

        /* Main Content Area */
        .content-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

        /* Tabs */
        .content-tabs { display: flex; background: var(--bg-dark); border-bottom: 1px solid var(--border); padding: 0 1rem; }
        .content-tab { padding: 0.875rem 1.25rem; background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 0.85rem; font-weight: 500; border-bottom: 2px solid transparent; margin-bottom: -1px; transition: all 0.2s; font-family: inherit; }
        .content-tab:hover { color: var(--primary); }
        .content-tab.active { color: var(--primary); border-bottom-color: var(--primary); }

        /* Tab Panels */
        .tab-panel { flex: 1; overflow: hidden; display: none; }
        .tab-panel.active { display: flex; flex-direction: column; }

        /* Learning Board */
        .learning-board { flex: 1; overflow-y: auto; padding: 1.5rem; }
        .board-content { max-width: 800px; margin: 0 auto; }
        .lesson-header { margin-bottom: 1.5rem; }
        .lesson-header h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        .lesson-meta { display: flex; gap: 1rem; color: var(--text-muted); font-size: 0.8rem; }
        .content-section { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 1.25rem; margin-bottom: 1rem; }
        .section-title { font-size: 1rem; font-weight: 600; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem; }
        .section-text { color: var(--text-secondary); line-height: 1.7; font-size: 0.9rem; }
        .big-idea-box { background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(124, 58, 237, 0.1)); border-left: 4px solid var(--primary); padding: 1rem 1.25rem; border-radius: 0 10px 10px 0; margin: 1rem 0; }
        .big-idea-box p { color: var(--text-primary); font-size: 0.95rem; line-height: 1.6; }
        .steps-list { list-style: none; margin-top: 0.5rem; }
        .steps-list li { display: flex; align-items: flex-start; gap: 0.75rem; padding: 0.6rem; background: var(--bg-darker); border-radius: 8px; margin-bottom: 0.4rem; font-size: 0.85rem; color: var(--text-secondary); }
        .step-badge { background: linear-gradient(135deg, var(--primary), var(--secondary)); color: var(--bg-darker); min-width: 22px; height: 22px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.7rem; flex-shrink: 0; }

        /* Video Section */
        .video-container { background: #000; border-radius: 10px; overflow: hidden; margin: 1rem 0; aspect-ratio: 16/9; display: flex; align-items: center; justify-content: center; }
        .video-container iframe { width: 100%; height: 100%; border: none; }
        .video-placeholder { text-align: center; color: var(--text-muted); }
        .video-placeholder .icon { font-size: 3rem; margin-bottom: 0.5rem; }

        /* Quiz Section */
        .quiz-item { background: var(--bg-darker); border-radius: 10px; padding: 1rem; margin-bottom: 0.75rem; }
        .quiz-item p { color: var(--text-primary); font-weight: 500; margin-bottom: 0.75rem; font-size: 0.9rem; }
        .quiz-options { display: flex; flex-direction: column; gap: 0.4rem; }
        .quiz-opt { background: var(--bg-card); border: 1px solid var(--border); padding: 0.65rem; border-radius: 6px; cursor: pointer; transition: all 0.2s; color: var(--text-secondary); font-size: 0.85rem; }
        .quiz-opt:hover { border-color: var(--primary); color: var(--primary); }
        .quiz-opt.correct { background: rgba(16, 185, 129, 0.2); border-color: var(--success); color: var(--success); }
        .quiz-opt.wrong { background: rgba(239, 68, 68, 0.2); border-color: var(--error); color: var(--error); }

        /* Navigation Buttons */
        .lesson-nav { display: flex; justify-content: space-between; gap: 1rem; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border); }
        .nav-btn { background: var(--bg-card); border: 1px solid var(--border); color: var(--text-secondary); padding: 0.75rem 1.25rem; border-radius: 8px; cursor: pointer; font-size: 0.85rem; transition: all 0.2s; font-family: inherit; }
        .nav-btn:hover:not(:disabled) { border-color: var(--primary); color: var(--primary); }
        .nav-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .nav-btn.primary { background: linear-gradient(135deg, var(--primary), var(--primary-dark)); color: var(--bg-darker); border: none; font-weight: 600; }
        .nav-btn.primary:hover:not(:disabled) { box-shadow: 0 6px 15px rgba(0, 217, 255, 0.3); }

        /* Playground Panel */
        .playground-frame { flex: 1; border: none; }

        /* Mobile Responsive */
        @media (max-width: 900px) {
            .main-layout { flex-direction: column; }
            .sidebar { width: 100%; max-height: 200px; border-right: none; border-bottom: 1px solid var(--border); }
            .lesson-list { display: flex; gap: 0.5rem; flex-wrap: nowrap; overflow-x: auto; padding: 0.5rem; }
            .module-group { display: contents; }
            .module-title { display: none; }
            .lesson-item { flex-shrink: 0; padding: 0.5rem 0.75rem; }
            .lesson-info { display: none; }
        }
        @media (max-width: 600px) {
            .header-content { flex-direction: column; }
            .nav { justify-content: center; }
            .learning-board { padding: 1rem; }
            .lesson-header h1 { font-size: 1.25rem; }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo" id="courseLogo">ðŸ“– Course Viewer</div>
            <nav class="nav">
                <a href="/">Home</a>
                <a href="/about">About</a>
                <a href="/services">Services</a>
                <a href="/courses">Courses</a>
                <a href="/blog">Blog</a>
                <a href="/cross-platform-integration">Digital Services</a>
                <a href="/contact">Contact</a>
            </nav>
        </div>
    </header>

    <div class="main-layout">
        <!-- Sidebar with Lesson List -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <h2>Course Lessons</h2>
                <p id="progressText">0/15 completed</p>
            </div>
            <div style="padding: 0.5rem 1rem; border-bottom: 1px solid var(--border);">
                <select id="courseSelect" onchange="switchCourse(this.value)" style="width: 100%; padding: 0.5rem; background: var(--bg-darker); border: 1px solid var(--border); color: var(--text-primary); border-radius: 6px; font-size: 0.8rem; cursor: pointer;">
                    <option value="vibe-coding">Vibe Coding</option>
                    <option value="prompt-engineering">Prompt Engineering</option>
                </select>
            </div>
            <div class="lesson-list" id="lessonList"></div>
        </aside>

        <!-- Main Content -->
        <main class="content-area">
            <div class="content-tabs">
                <button class="content-tab active" onclick="switchTab('board')">ðŸ“‹ Learning Board</button>
                <button class="content-tab" onclick="switchTab('playground')">ðŸ’» AI Playground</button>
            </div>

            <!-- Learning Board Tab -->
            <div class="tab-panel active" id="board-panel">
                <div class="learning-board" id="learningBoard"></div>
            </div>

            <!-- Playground Tab -->
            <div class="tab-panel" id="playground-panel">
                <iframe class="playground-frame" src="/playground"></iframe>
            </div>
        </main>
    </div>

    <script>
        const COURSES={
  "vibe-coding": {
    "title": "Vibe Coding: Building Real Software with AI",
    "lessons": [
      {
        "id": 1,
        "module": "Module 1: Vibe Coding Foundations",
        "title": "What Is Vibe Coding?",
        "duration": "10-15 min",
        "intro": "Welcome to the future of software development. In this foundational lesson, you will discover a paradigm shift that is transforming how software gets built in 2024 and beyond. Vibe Coding is not just another programming methodology - it represents a fundamental change in the relationship between humans and computers when creating software.\n\nTraditionally, building software required years of study: learning syntax, memorizing functions, understanding complex architectures, and debugging cryptic error messages. This barrier kept millions of creative, intelligent people from bringing their ideas to life. Vibe Coding removes this barrier entirely.\n\nThe term 'Vibe Coding' was coined by AI researcher Andrej Karpathy to describe a new way of building software where humans focus on intent, direction, and outcomes while AI handles the technical execution. Instead of writing every line of code yourself, you describe what you want, guide the AI, and iterate on the results. This is not about replacing programming knowledge - it's about making software creation accessible to everyone while amplifying the capabilities of experienced developers.",
        "bigIdea": "Vibe Coding is the practice of building real software by focusing on intent, systems thinking, and outcomes while AI handles the code execution. You become the architect and director; AI becomes your skilled builder. This approach democratizes software creation, allowing anyone with clear ideas to build functional applications, websites, and digital products without memorizing syntax or spending years learning traditional programming.",
        "steps": [
          "Step 1: Understand that Vibe Coding is about directing AI with clear intent, not writing code manually",
          "Step 2: Recognize that your value comes from knowing what to build, not how to type it",
          "Step 3: Accept that iteration is normal - expect to refine and adjust multiple times",
          "Step 4: Commit to always testing and validating what AI produces",
          "Step 5: Embrace systems thinking - understand how pieces connect even if you don't write them"
        ],
        "example": "Consider Sarah, a small business owner who needed a customer booking system. Traditional approach: hire a developer for $5,000-15,000 or spend 6+ months learning to code. Vibe Coding approach: Sarah described her booking requirements to an AI coding assistant, iterated on the design, and had a working system in two weeks. She didn't write a single line of code manually, but she directed every decision about features, user experience, and business logic. The result was a professional application that perfectly matched her needs.\n\nAnother example: Marcus, a marketing professional, needed to analyze thousands of customer reviews to find patterns. Instead of exporting data to Excel and spending weeks on manual analysis, he used Vibe Coding to create a Python script that categorized reviews by sentiment and topic. Total time: 3 hours. He couldn't explain every line of code, but he understood what the script did and verified its accuracy.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Think about a digital tool or app you wish existed for your work or personal life. How would you describe it to someone who could build it? What features would be essential? What should it look like? This is the kind of thinking that makes Vibe Coding powerful.",
        "quiz": [
          {
            "q": "What is the primary focus of a Vibe Coder when building software?",
            "a": "Intent, direction, and outcomes - focusing on what to build rather than how to write code",
            "opts": [
              "Intent, direction, and outcomes - focusing on what to build rather than how to write code",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Who coined the term 'Vibe Coding' and what was their role?",
            "a": "Andrej Karpathy, an AI researcher",
            "opts": [
              "Andrej Karpathy, an AI researcher",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why is testing and validation crucial in Vibe Coding?",
            "a": "Because AI can produce code with bugs or that doesn't match your intent, requiring human verification",
            "opts": [
              "Because AI can produce code with bugs or that doesn't match your intent, requiring human verification",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What replaces the need to memorize programming syntax in Vibe Coding?",
            "a": "The ability to clearly articulate what you want in natural language",
            "opts": [
              "The ability to clearly articulate what you want in natural language",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What type of thinking becomes more important than syntax knowledge in Vibe Coding?",
            "a": "Systems thinking - understanding how components connect and affect each other",
            "opts": [
              "Systems thinking - understanding how components connect and affect each other",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you learned that Vibe Coding is a paradigm shift in software development where humans focus on intent, systems, and outcomes while AI handles code execution. You discovered that this approach democratizes software creation without eliminating the need for validation and testing. The key insight is that your value as a Vibe Coder comes from clear thinking and direction, not syntax memorization. You are now ready to explore the tools and ecosystem that make Vibe Coding possible."
      },
      {
        "id": 2,
        "module": "Module 1: Vibe Coding Foundations",
        "title": "The Vibe Coding Ecosystem: Tools That Power Modern Development",
        "duration": "10-15 min",
        "intro": "Now that you understand what Vibe Coding is, it is time to explore the tools that make it possible. The Vibe Coding ecosystem has exploded in 2024, with dozens of powerful AI-powered tools designed for different use cases. Understanding this landscape is essential before you start building.\n\nThis lesson will give you a clear map of the major categories of tools, what each does best, and how to choose the right tool for your projects. By the end, you will have a mental framework for navigating this rapidly evolving space and making informed decisions about which tools to learn and use.\n\nThe tools we cover here are not theoretical - these are production-grade platforms used by startups, enterprises, and individual creators to build real software every day. Some of these tools did not exist 18 months ago, yet they are already transforming how software gets built.",
        "bigIdea": "The Vibe Coding ecosystem consists of three main categories: Full-Stack AI Builders (like Bolt, Lovable, and Replit) that generate complete applications from descriptions, AI-First IDEs (like Cursor, Windsurf, and Qoder) that enhance coding with AI assistance, and Agentic Tools (like Devin and OpenHands) that can autonomously complete complex development tasks. Each category serves different needs, and skilled Vibe Coders know when to use each.",
        "steps": [
          "Step 1: Identify your goal - prototype, production code, or learning",
          "Step 2: Assess your technical comfort level - no code, some code, or professional",
          "Step 3: Match your goal and comfort level to a tool category",
          "Step 4: Within that category, choose based on your specific needs",
          "Step 5: Start with one tool, master it, then expand your toolkit"
        ],
        "example": "Let us follow two different projects to see tool selection in action.\n\nProject A: Maria wants to build a portfolio website to showcase her photography. She has no coding experience and needs it done this weekend. Best choice: Bolt.new. She can describe her vision, iterate on the design, and have a deployed website in a few hours.\n\nProject B: James is a developer with a complex e-commerce codebase. He needs to refactor the payment processing module and add new features. Best choice: Cursor. The AI can understand his existing code, suggest improvements, and help implement changes while he maintains full control.\n\nProject C: A startup needs to integrate their app with five different APIs and set up a data pipeline. They have clear specifications but limited engineering bandwidth. Best choice: Devin. They can delegate the entire integration task and review the results.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Based on your current goals and technical comfort level, which tool category seems most appropriate for your first Vibe Coding projects? What specific project would you want to build with it?",
        "quiz": [
          {
            "q": "What are the three main categories of tools in the Vibe Coding ecosystem?",
            "a": "Full-Stack AI Builders, AI-First IDEs, and Agentic Coding Tools",
            "opts": [
              "Full-Stack AI Builders, AI-First IDEs, and Agentic Coding Tools",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Which category is best for generating complete applications from descriptions without touching code?",
            "a": "Full-Stack AI Builders (like Bolt, Lovable, and Replit)",
            "opts": [
              "Full-Stack AI Builders (like Bolt, Lovable, and Replit)",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is the primary advantage of AI-First IDEs over Full-Stack Builders?",
            "a": "More control over code structure and the ability to work with existing codebases",
            "opts": [
              "More control over code structure and the ability to work with existing codebases",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Which tool would you recommend for someone who wants a prototype in under an hour with no coding experience?",
            "a": "Bolt.new or Lovable - Full-Stack AI Builders designed for speed and simplicity",
            "opts": [
              "Bolt.new or Lovable - Full-Stack AI Builders designed for speed and simplicity",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What characterizes Agentic Coding Tools compared to other categories?",
            "a": "They can autonomously complete complex development tasks with minimal guidance",
            "opts": [
              "They can autonomously complete complex development tasks with minimal guidance",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you mapped the Vibe Coding ecosystem and learned to categorize tools into Full-Stack AI Builders, AI-First IDEs, and Agentic Coding Tools. You now have a decision framework for choosing the right tool based on your goals and technical comfort. The key insight is that different tools serve different purposes - there is no single 'best' tool, only the best tool for your specific situation. In the next lesson, we will dive deep into Full-Stack AI Builders and learn to use them effectively."
      },
      {
        "id": 3,
        "module": "Module 2: Full-Stack AI Builders",
        "title": "Mastering Bolt.new: From Idea to Deployed App",
        "duration": "10-15 min",
        "intro": "Bolt.new has emerged as one of the most powerful Full-Stack AI Builders available today. In this hands-on lesson, you will learn to use Bolt effectively - from crafting your first prompt to deploying a working application. This is where theory becomes practice.\n\nWhat makes Bolt special is its speed and simplicity. You can go from a blank page to a deployed web application in under 30 minutes, often faster. But speed without quality produces disposable prototypes. This lesson teaches you to use Bolt strategically - knowing when to use it, how to prompt it effectively, and how to iterate towards production-quality results.\n\nBy the end of this lesson, you will have built and deployed your first real application using Bolt. You will understand the prompting patterns that produce the best results, and you will know the limitations that help you decide when Bolt is the right tool versus when you need something more powerful.",
        "bigIdea": "Bolt.new transforms natural language descriptions into complete, deployed web applications. Your effectiveness depends on prompt quality - specific, structured prompts with clear requirements produce dramatically better results than vague descriptions. The key is learning to think like a product manager: defining what users need, how they will interact with it, and what success looks like.",
        "steps": [
          "Step 1: Go to bolt.new and create an account (free tier available)",
          "Step 2: Craft your initial prompt using the structure above",
          "Step 3: Review the generated application thoroughly",
          "Step 4: Iterate with specific refinement requests",
          "Step 5: Test all features across devices",
          "Step 6: Deploy when satisfied"
        ],
        "example": "Let us build a practical application step-by-step.\n\nProject: Personal Task Tracker\n\nStep 1 - Initial Prompt: 'Build a personal task tracker. Features: add tasks with title and due date, mark tasks complete, filter by status (all, active, completed), delete tasks. Clean, minimal design with a blue accent color. Store tasks in local storage.'\n\nStep 2 - Review and Iterate: The first version appears. The design is good but tasks need priority levels. Refinement: 'Add a priority field to tasks (low, medium, high). Show priority with colored badges. Sort tasks by priority by default.'\n\nStep 3 - Polish: 'Make the add-task form slide down when clicking the Add button. Add a subtle animation when tasks are marked complete. Show a friendly empty state when no tasks exist.'\n\nStep 4 - Deploy: Click deploy, get a live URL, share with others.\n\nTotal time: 15-25 minutes. Result: A fully functional, well-designed task tracker that works on any device.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "What simple tool or application would make your daily life easier? How would you describe it to Bolt using the prompting patterns from this lesson?",
        "quiz": [
          {
            "q": "What are the five key sections of an effective Bolt prompt?",
            "a": "Purpose Statement, Core Features, User Experience Details, Design Direction, and Technical Requirements",
            "opts": [
              "Purpose Statement, Core Features, User Experience Details, Design Direction, and Technical Requirements",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why should you start with simple features before adding complexity?",
            "a": "Complex prompts produce confused, buggy results - incremental building allows for cleaner iteration",
            "opts": [
              "Complex prompts produce confused, buggy results - incremental building allows for cleaner iteration",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What should you do immediately when you encounter an error in Bolt?",
            "a": "Fix errors immediately before moving on to prevent compounding problems",
            "opts": [
              "Fix errors immediately before moving on to prevent compounding problems",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What types of projects is Bolt NOT well-suited for?",
            "a": "Complex backend logic, custom API integrations, large-scale enterprise applications, and performance-critical systems",
            "opts": [
              "Complex backend logic, custom API integrations, large-scale enterprise applications, and performance-critical systems",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is the main difference between a vague prompt and an effective prompt in Bolt?",
            "a": "Effective prompts are specific about features, design, and user experience; vague prompts force Bolt to guess, often incorrectly",
            "opts": [
              "Effective prompts are specific about features, design, and user experience; vague prompts force Bolt to guess, often incorrectly",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you learned to use Bolt.new effectively - from crafting structured prompts to deploying working applications. You now understand the 5-part prompt structure, common mistakes to avoid, and Bolt's limitations. The key insight is that your prompting skill directly determines the quality of output. In the next lesson, we will explore Lovable, another Full-Stack Builder with different strengths."
      },
      {
        "id": 4,
        "module": "Module 2: Full-Stack AI Builders",
        "title": "Lovable: Building Beautiful, Production-Ready Applications",
        "duration": "10-15 min",
        "intro": "While Bolt excels at speed, Lovable excels at quality. Lovable.dev is a Full-Stack AI Builder designed specifically for creating beautiful, well-architected applications that feel production-ready from the start. In this lesson, you will learn what makes Lovable different and when to choose it over other tools.\n\nLovable approaches AI-generated applications differently. Instead of optimizing purely for speed, it focuses on thoughtful component architecture, professional UI design, and code structure that developers would actually want to maintain. This makes it ideal for projects that need to look polished and potentially scale beyond the initial prototype.\n\nBy the end of this lesson, you will understand Lovable's unique strengths, know how to prompt it effectively, and have a clear framework for deciding between Lovable, Bolt, and other Full-Stack Builders based on your project needs.",
        "bigIdea": "Lovable generates applications with a focus on design quality and code architecture. It produces React components with proper structure, implements design systems consistently, and creates applications that look and feel professional. The tradeoff is that it may be slower than Bolt and has a steeper learning curve, but the output is often more suitable for production use.",
        "steps": [
          "Step 1: Go to lovable.dev and create an account",
          "Step 2: Start with a design-focused prompt emphasizing the experience",
          "Step 3: Reference specific design styles (minimal SaaS, editorial, etc.)",
          "Step 4: Iterate on design details before adding features",
          "Step 5: Polish micro-interactions and transitions",
          "Step 6: Test responsiveness across device sizes"
        ],
        "example": "Let us build a professional application with Lovable.\n\nProject: Freelancer Client Portal\n\nStep 1 - Initial Prompt: 'Build a client portal for freelancers that feels professional and builds trust. For solo designers/developers who need to share work with clients. Modern, minimal design with a neutral color palette and blue accents. Features: project dashboard showing active projects, file upload with preview, comment system for feedback, simple status updates. Clean typography, generous spacing, subtle shadows.'\n\nStep 2 - Review: The initial output shows a polished dashboard. The design is cohesive and professional. But we need better navigation. Refinement: 'Add a sidebar navigation with icons for Dashboard, Projects, Files, and Settings. Make the current page indicator subtle but clear.'\n\nStep 3 - Enhance: 'Add a notification bell in the header that shows when clients leave new comments. Include a quick-action button for uploading files that's always accessible.'\n\nStep 4 - Final Polish: 'Add skeleton loading states for the project cards. Implement a dark mode toggle in settings.'\n\nResult: A portfolio-worthy client portal that looks like a real SaaS product. Total time: 30-45 minutes.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Think about a project you want to build that needs to impress users or clients. How would you describe the feeling and experience you want to create, beyond just the features?",
        "quiz": [
          {
            "q": "What is Lovable's primary advantage over Bolt?",
            "a": "Higher design quality and better code architecture for production-ready applications",
            "opts": [
              "Higher design quality and better code architecture for production-ready applications",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What type of language should you use in Lovable prompts?",
            "a": "Design-focused language that emphasizes experience, feeling, and design style rather than just features",
            "opts": [
              "Design-focused language that emphasizes experience, feeling, and design style rather than just features",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "When should you choose Bolt instead of Lovable?",
            "a": "When speed matters more than polish, for quick experiments, personal tools, or simple utilities",
            "opts": [
              "When speed matters more than polish, for quick experiments, personal tools, or simple utilities",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What does 'component architecture' mean in the context of Lovable's output?",
            "a": "Properly structured React components with good separation, props handling, and maintainable code patterns",
            "opts": [
              "Properly structured React components with good separation, props handling, and maintainable code patterns",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why is design quality particularly important for certain types of projects?",
            "a": "First impressions affect user trust - professional design builds credibility for client work, SaaS products, and portfolio pieces",
            "opts": [
              "First impressions affect user trust - professional design builds credibility for client work, SaaS products, and portfolio pieces",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you learned that Lovable excels at creating beautiful, production-ready applications with professional design and maintainable code architecture. You now understand how to write design-focused prompts and have a clear framework for choosing between Lovable and Bolt. The key insight is that different projects have different needs - knowing when to prioritize polish over speed is a valuable skill. In the next lesson, we will explore Replit, which offers a unique blend of learning, collaboration, and deployment capabilities."
      },
      {
        "id": 5,
        "module": "Module 2: Full-Stack AI Builders",
        "title": "Replit: Learning, Building, and Deploying in One Platform",
        "duration": "10-15 min",
        "intro": "Replit stands apart from other Full-Stack Builders because it is not just a generation tool - it is a complete development environment. While Bolt and Lovable focus on outputting finished applications, Replit gives you a workspace where you can learn, experiment, collaborate, and deploy all in one place. This makes it uniquely valuable for learners and teams.\n\nIn this lesson, you will understand what makes Replit different, when it is the best choice, and how to leverage its unique features. You will also learn about Replit's AI assistant (Ghostwriter) and how it integrates with the broader development experience.\n\nReplit's power comes from its flexibility. You can start with AI-generated code, then learn by modifying it. You can collaborate in real-time with others. You can deploy instantly without configuring servers. This combination makes it an excellent bridge between pure no-code tools and professional development environments.",
        "bigIdea": "Replit is a browser-based development environment with integrated AI assistance, real-time collaboration, and instant deployment. Unlike pure generation tools, Replit lets you see, understand, and modify the code - making it ideal for learning, team projects, and applications that need backend logic. Its AI assistant (Ghostwriter) provides contextual coding help while you maintain full control.",
        "steps": [
          "Step 1: Create a Replit account at replit.com",
          "Step 2: Create a new Repl, choosing an appropriate template",
          "Step 3: Use Ghostwriter to generate initial code",
          "Step 4: Read through the generated code to understand it",
          "Step 5: Iterate with specific prompts for additional features",
          "Step 6: Test thoroughly using the live preview",
          "Step 7: Deploy and optionally enable Always On for backend projects"
        ],
        "example": "Let us build a practical backend application with Replit.\n\nProject: Discord Bot for Community Management\n\nThis project requires backend logic - it needs to run continuously, respond to events, and interact with external APIs. Bolt and Lovable cannot do this. Replit excels here.\n\nStep 1 - Create New Repl: Choose Python template (or Node.js). Name it 'community-bot'.\n\nStep 2 - Use Ghostwriter: 'Create a Discord bot that welcomes new members, tracks message count, and responds to !stats command showing top contributors.'\n\nStep 3 - Review Generated Code: Ghostwriter creates the bot structure. Read through it to understand how Discord.py works.\n\nStep 4 - Iterate: 'Add a moderation feature: when users type banned words, auto-delete the message and warn them.'\n\nStep 5 - Add Database: 'Store user warning counts in Replit's database. After 3 warnings, notify moderators.'\n\nStep 6 - Deploy: Click Run and enable Always On. Your bot runs 24/7.\n\nStep 7 - Invite Collaborators: Share the Repl with team members who can see your code and contribute.\n\nResult: A fully functional Discord bot running continuously, with real-time collaboration capability.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Consider a project idea that needs more than just a frontend - maybe a bot, an API, or a data processing tool. How would you approach building it with Replit? What questions would you ask Ghostwriter?",
        "quiz": [
          {
            "q": "What makes Replit different from pure AI code generators like Bolt?",
            "a": "Replit is a full development environment where you can see, modify, and learn from code, not just consume generated output",
            "opts": [
              "Replit is a full development environment where you can see, modify, and learn from code, not just consume generated output",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is Ghostwriter and what can it do?",
            "a": "Replit's AI assistant that provides contextual code completion, explanations, generation, and debugging within your project",
            "opts": [
              "Replit's AI assistant that provides contextual code completion, explanations, generation, and debugging within your project",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "When should you choose Replit over Bolt or Lovable?",
            "a": "When you need backend logic, want to learn by modifying code, need team collaboration, or require custom functionality",
            "opts": [
              "When you need backend logic, want to learn by modifying code, need team collaboration, or require custom functionality",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is 'Multiplayer Coding' in Replit?",
            "a": "Real-time collaborative editing where multiple users can code together simultaneously, like Google Docs for code",
            "opts": [
              "Real-time collaborative editing where multiple users can code together simultaneously, like Google Docs for code",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What types of projects benefit most from Replit's backend capabilities?",
            "a": "Bots, APIs, data processing, scheduled jobs, and any application requiring server-side logic running continuously",
            "opts": [
              "Bots, APIs, data processing, scheduled jobs, and any application requiring server-side logic running continuously",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you learned that Replit offers a unique combination of AI assistance, full development environment, real-time collaboration, and instant deployment. Unlike pure generators, Replit lets you see and modify code - making it ideal for learning and complex projects. You now understand when to choose Replit over Bolt or Lovable, and how to leverage Ghostwriter for AI-assisted development. In the next module, we will explore AI-First IDEs that offer even more control and power for those ready to dive deeper into code."
      },
      {
        "id": 6,
        "module": "Module 3: AI-First IDEs",
        "title": "Introduction to AI-First IDEs: Cursor, Windsurf, and Qoder",
        "duration": "10-15 min",
        "intro": "Having explored Full-Stack Builders that generate complete applications, we now move to a more powerful category of tools: AI-First IDEs. These are professional development environments enhanced with AI capabilities that give you full control while dramatically accelerating your workflow.\n\nAI-First IDEs represent the sweet spot for many developers and ambitious Vibe Coders. They offer the power to build complex, production-grade applications while AI assists with the tedious parts - writing boilerplate, suggesting implementations, explaining unfamiliar code, and debugging issues. Unlike Full-Stack Builders, you work directly with code, but AI makes that work significantly more productive.\n\nThis lesson introduces the three leading AI-First IDEs: Cursor, Windsurf, and Qoder. By the end, you will understand their distinct approaches to AI-assisted development and know which might be best for your needs.",
        "bigIdea": "AI-First IDEs are code editors built from the ground up with AI integration. They understand your entire codebase, can make multi-file changes, explain complex code, and assist with debugging. Unlike traditional IDEs with AI plugins, these tools treat AI as a core feature, not an afterthought. The result is a fundamentally different coding experience where AI is always available and deeply integrated.",
        "steps": [
          "Step 1: Download one AI-First IDE to start (Cursor is recommended for most people)",
          "Step 2: Open an existing project or clone a starter template",
          "Step 3: Explore the AI chat feature - ask questions about the code",
          "Step 4: Try inline generation - start typing and see AI suggestions",
          "Step 5: Make a multi-file change using AI assistance",
          "Step 6: Use AI to debug something that is not working"
        ],
        "example": "Consider a real scenario: You are building a SaaS application and need to implement Stripe payment integration.\n\nWith a Full-Stack Builder: You describe 'add Stripe payments' and get generated code. If it does not work or needs customization, you are stuck without understanding why.\n\nWith an AI-First IDE (Cursor): You open your existing project. You ask Cursor: 'How should I structure Stripe integration in this codebase?' It analyzes your project and suggests an approach. You then say: 'Create the payment processing module with subscription management.' Cursor generates code that fits your existing patterns. When Stripe's webhook does not work, you ask: 'Why is this webhook failing?' and Cursor helps you debug by analyzing the code and error logs.\n\nThe difference: You maintain understanding and control while AI accelerates every step.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Think about a coding task that has frustrated you in the past - maybe debugging, understanding unfamiliar code, or implementing a complex feature. How might an AI-First IDE have changed that experience?",
        "quiz": [
          {
            "q": "What distinguishes AI-First IDEs from traditional IDEs with AI plugins?",
            "a": "AI is a core feature built into the foundation, not an add-on - the entire experience is designed around AI assistance",
            "opts": [
              "AI is a core feature built into the foundation, not an add-on - the entire experience is designed around AI assistance",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Which AI-First IDE is best known for deep codebase understanding and multi-file edits?",
            "a": "Cursor - it can read entire projects, understand relationships between files, and make coordinated changes",
            "opts": [
              "Cursor - it can read entire projects, understand relationships between files, and make coordinated changes",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is Windsurf's primary design focus?",
            "a": "Flow state coding - minimal interruption with predictive suggestions that feel like an extension of your thoughts",
            "opts": [
              "Flow state coding - minimal interruption with predictive suggestions that feel like an extension of your thoughts",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What makes Qoder unique among AI-First IDEs?",
            "a": "Agentic development - it can autonomously plan and execute multi-step tasks with minimal guidance",
            "opts": [
              "Agentic development - it can autonomously plan and execute multi-step tasks with minimal guidance",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "When should you choose an AI-First IDE over a Full-Stack Builder?",
            "a": "When you need control, must work with existing code, require debugging/optimization, or are building production applications",
            "opts": [
              "When you need control, must work with existing code, require debugging/optimization, or are building production applications",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you learned about AI-First IDEs - professional development environments with AI deeply integrated into every workflow. You explored Cursor, Windsurf, and Qoder, understanding their distinct approaches and strengths. The key insight is that AI-First IDEs give you control and understanding while keeping AI's productivity benefits. In the next lesson, we will dive deep into Cursor and learn to use it effectively for real projects."
      },
      {
        "id": 7,
        "module": "Module 3: AI-First IDEs",
        "title": "Mastering Cursor: Your AI Pair Programmer",
        "duration": "10-15 min",
        "intro": "Cursor has rapidly become the most popular AI-First IDE among professional developers. In this hands-on lesson, you will learn to use Cursor effectively - from basic chat interactions to advanced multi-file editing and the powerful Composer mode.\n\nWhat makes Cursor special is its deep understanding of your codebase. Unlike general-purpose AI assistants, Cursor reads and indexes your entire project. When you ask a question or request a change, it understands the context: your file structure, your coding patterns, the relationships between modules, and even your configuration files. This context-awareness produces dramatically better results than generic AI assistance.\n\nBy the end of this lesson, you will be comfortable using Cursor's key features: Chat, Edit, and Composer. You will know the prompting strategies that produce the best results, and you will understand how to iterate effectively when AI output needs refinement.",
        "bigIdea": "Cursor is an AI pair programmer that understands your entire codebase. Its power comes from three core features: Chat for conversations about your code, Edit for inline changes, and Composer for complex multi-file modifications. Mastering these features transforms your development workflow, making you significantly more productive while maintaining full understanding and control.",
        "steps": [
          "Step 1: Download and install Cursor from cursor.com",
          "Step 2: Open an existing project (or clone a starter template)",
          "Step 3: Practice Chat (Cmd+L): Ask questions about the codebase",
          "Step 4: Practice Edit (Cmd+K): Select code and request modifications",
          "Step 5: Practice Composer (Cmd+I): Make a multi-file change",
          "Step 6: Use the Reference and Context strategies in your prompts"
        ],
        "example": "Let us walk through a real development session with Cursor.\n\nTask: Add a 'Forgot Password' feature to an existing application.\n\nStep 1 - Understand Current Auth: Open Chat, ask: 'How does authentication currently work in this project? Where are the auth-related files?'\nCursor explains the auth flow and lists relevant files.\n\nStep 2 - Plan the Feature: Ask: 'What would I need to add for forgot password functionality? List the files and changes needed.'\nCursor outlines: email template, reset token generation, API endpoint, password reset page, email sending service.\n\nStep 3 - Generate Email Template: Open Composer: 'Create an email template for password reset following the style of existing email templates in /templates.'\nCursor creates the template file.\n\nStep 4 - Create API Endpoint: 'Add POST /api/auth/forgot-password endpoint that generates a reset token, stores it with expiration, and sends the email.'\nCursor creates the endpoint with proper error handling.\n\nStep 5 - Add Reset Page: 'Create a password reset page at /reset-password that accepts the token, validates it, and allows setting a new password.'\nCursor creates the frontend component and connects it to the API.\n\nStep 6 - Test and Refine: You test the feature. Token expiration is not working. Ask: 'The reset token is not expiring after the timeout. Can you check the token validation logic?'\nCursor identifies and fixes the issue.\n\nTotal time: 30-45 minutes for a feature that might take 4+ hours without AI assistance.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Consider a recent coding task that took you several hours. How could you have broken it down into Cursor Chat, Edit, and Composer interactions? What would your prompts have been?",
        "quiz": [
          {
            "q": "What are Cursor's three core interaction modes?",
            "a": "Chat (Cmd+L) for conversations, Edit (Cmd+K) for inline changes, and Composer (Cmd+I) for multi-file modifications",
            "opts": [
              "Chat (Cmd+L) for conversations, Edit (Cmd+K) for inline changes, and Composer (Cmd+I) for multi-file modifications",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "When should you use Composer instead of Edit mode?",
            "a": "When changes span multiple files or require creating new files - Edit is for single-file inline changes",
            "opts": [
              "When changes span multiple files or require creating new files - Edit is for single-file inline changes",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is the Reference Strategy in Cursor prompting?",
            "a": "Pointing to existing code as a model for what you want - helps AI match your project's patterns and style",
            "opts": [
              "Pointing to existing code as a model for what you want - helps AI match your project's patterns and style",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why is it important to review changes before accepting them?",
            "a": "AI can introduce bugs, break existing functionality, or misunderstand requirements - review catches these issues",
            "opts": [
              "AI can introduce bugs, break existing functionality, or misunderstand requirements - review catches these issues",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "How does providing context improve Cursor's output?",
            "a": "Context helps AI understand not just what to do but why, leading to solutions that fit the real requirements",
            "opts": [
              "Context helps AI understand not just what to do but why, leading to solutions that fit the real requirements",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you mastered Cursor's three core features: Chat for conversations and understanding, Edit for inline modifications, and Composer for multi-file changes. You learned prompting strategies that produce better results and common mistakes to avoid. The key insight is that effective Cursor use requires clear, contextual prompts and always reviewing AI output. In the next lesson, we will explore Agentic Coding Tools that take AI assistance even further."
      },
      {
        "id": 8,
        "module": "Module 4: Agentic Coding Tools",
        "title": "Understanding Agentic AI: Devin, OpenHands, and Autonomous Development",
        "duration": "10-15 min",
        "intro": "We have now reached the cutting edge of Vibe Coding: Agentic AI tools. These are not assistants that wait for your instructions - they are autonomous agents that can plan, execute, and iterate on development tasks with minimal human guidance.\n\nAgentic coding represents a fundamental shift in how software gets built. Instead of prompting for each step, you describe an outcome and the agent figures out how to achieve it. It can browse documentation, write code, run tests, debug errors, and refine its approach - all autonomously. This is the future that many predicted but few expected to arrive so quickly.\n\nIn this lesson, you will understand what agentic AI is, explore the leading tools (Devin and OpenHands), and learn when autonomous development is appropriate versus when human guidance is essential.",
        "bigIdea": "Agentic AI tools are autonomous software development agents that can independently plan, execute, and iterate on complex tasks. Unlike assistants that respond to prompts, agents take high-level goals and work towards them independently, asking for human input only when truly necessary. This represents the highest level of AI delegation in Vibe Coding, requiring clear specifications but offering transformative productivity gains.",
        "steps": [
          "Step 1: Evaluate whether your task is well-suited for agentic development",
          "Step 2: Write a detailed specification with clear requirements and constraints",
          "Step 3: Review the agent's plan before execution when possible",
          "Step 4: Monitor progress and provide guidance when agent requests it",
          "Step 5: Thoroughly review and test the output",
          "Step 6: Iterate with specific feedback if adjustments are needed"
        ],
        "example": "An example of this concept in action.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Think about tasks in your work or projects that are well-defined but time-consuming. Which would be good candidates for agentic development? What would you need to specify clearly?",
        "quiz": [
          {
            "q": "What is the key difference between AI assistants and AI agents?",
            "a": "Agents work autonomously towards high-level goals; assistants respond to individual prompts requiring continuous guidance",
            "opts": [
              "Agents work autonomously towards high-level goals; assistants respond to individual prompts requiring continuous guidance",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why is specification quality so important for agentic development?",
            "a": "Vague specifications lead to wrong results - agents interpret and execute what you specify, so clarity is essential",
            "opts": [
              "Vague specifications lead to wrong results - agents interpret and execute what you specify, so clarity is essential",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What type of task is ideal for agentic tools?",
            "a": "Well-specified, bounded tasks with clear objectives and measurable completion criteria",
            "opts": [
              "Well-specified, bounded tasks with clear objectives and measurable completion criteria",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "When should you NOT use agentic development?",
            "a": "Ambiguous requirements, creative/novel solutions, security-critical code, or early exploration phases",
            "opts": [
              "Ambiguous requirements, creative/novel solutions, security-critical code, or early exploration phases",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is the human's role in the agentic development workflow?",
            "a": "Provide clear specifications, review plans, monitor progress, test outputs, and provide feedback for refinement",
            "opts": [
              "Provide clear specifications, review plans, monitor progress, test outputs, and provide feedback for refinement",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you explored agentic AI - autonomous agents that can plan and execute complex development tasks independently. You learned the difference between assistants and agents, explored Devin and OpenHands, and understood when agentic development is appropriate. The key insight is that effective delegation requires clear specifications and human oversight remains essential. In the next lesson, we will focus on real-world workflows that combine different Vibe Coding tools for maximum effectiveness."
      },
      {
        "id": 9,
        "module": "Module 5: Real-World Workflows",
        "title": "Building Complete Projects: Combining Vibe Coding Tools",
        "duration": "10-15 min",
        "intro": "You have now learned about Full-Stack Builders, AI-First IDEs, and Agentic Tools individually. In real projects, the most effective approach is often combining multiple tools strategically - using each for what it does best.\n\nThis lesson teaches you how professional Vibe Coders think about tool selection and combination. We will walk through complete project workflows from idea to deployment, showing when to switch tools and why. This synthesis of everything you have learned prepares you for real-world development.\n\nThe key insight is that there is no single 'best' tool - only the best tool for each phase of a project. Learning to flow between tools based on your current needs is what separates hobbyists from professionals.",
        "bigIdea": "Effective Vibe Coding combines multiple tools strategically: Full-Stack Builders for rapid prototyping, AI-First IDEs for refinement and custom logic, and Agentic Tools for well-specified automation. Knowing when to use each tool and how to transition between them creates a workflow that is faster and produces better results than using any single tool exclusively.",
        "steps": [
          "Step 1: Identify which project phase you are in",
          "Step 2: Choose the tool best suited for that phase",
          "Step 3: Set clear goals for what you want to achieve before transitioning",
          "Step 4: When goals are met, export/transition to the next tool",
          "Step 5: Use the decision framework when uncertain"
        ],
        "example": "An example of this concept in action.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Think about a project you built (or wanted to build) in the past. How would you approach it differently now using this multi-tool workflow? What phases would you handle differently?",
        "quiz": [
          {
            "q": "What is the main advantage of combining multiple Vibe Coding tools?",
            "a": "Each tool excels at different phases - combining them uses each for what it does best, creating faster and better results",
            "opts": [
              "Each tool excels at different phases - combining them uses each for what it does best, creating faster and better results",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Which project phase is best suited for Full-Stack Builders like Bolt?",
            "a": "Exploration and prototyping phases - when you need working software quickly to validate ideas",
            "opts": [
              "Exploration and prototyping phases - when you need working software quickly to validate ideas",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "When should you transition from a Full-Stack Builder to an AI-First IDE?",
            "a": "When the prototype is validated and you need production-quality code with proper security, architecture, and performance",
            "opts": [
              "When the prototype is validated and you need production-quality code with proper security, architecture, and performance",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What type of work is best delegated to Agentic tools?",
            "a": "Well-specified, bounded tasks with clear requirements and measurable completion criteria",
            "opts": [
              "Well-specified, bounded tasks with clear requirements and measurable completion criteria",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why is it faster to prototype in generators then refine in IDEs versus building everything in an IDE?",
            "a": "Generators produce working software instantly for structure/design; IDEs are better for precision work but slower for initial creation",
            "opts": [
              "Generators produce working software instantly for structure/design; IDEs are better for precision work but slower for initial creation",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you learned to combine Vibe Coding tools strategically for complete project workflows. You now understand which tools suit which project phases and how to transition between them smoothly. The key insight is that mastering the multi-tool workflow is what separates professional Vibe Coders from hobbyists. In the next lesson, we will focus on prompt engineering specifically for code generation."
      },
      {
        "id": 10,
        "module": "Module 6: Prompting for Software",
        "title": "Prompt Engineering for Code: Writing Instructions That Work",
        "duration": "10-15 min",
        "intro": "Everything in Vibe Coding depends on your ability to communicate effectively with AI. This skill - prompt engineering for code - is what separates those who struggle with AI tools from those who use them masterfully.\n\nPrompt engineering is not about tricks or magic phrases. It is a systematic approach to writing instructions that AI interprets correctly. In this lesson, you will learn the principles, patterns, and practices that produce reliable, high-quality code from AI systems.\n\nThe concepts here apply across all Vibe Coding tools: Full-Stack Builders, AI-First IDEs, and Agentic Tools. While each tool has nuances, the core principles of effective prompting are universal.",
        "bigIdea": "Effective code prompts have three elements: clear intent (what you want), sufficient context (what the AI needs to know), and explicit constraints (what you do not want). Mastering this formula transforms AI from unpredictable into reliable. The more precisely you can express your requirements, the better your results will be.",
        "steps": [
          "Step 1: Before prompting, clarify Intent, Context, and Constraints in your mind",
          "Step 2: Write the prompt using one or more proven patterns",
          "Step 3: Review AI output - does it match your intent?",
          "Step 4: If not, identify what was misunderstood and refine",
          "Step 5: Use iteration to add features or fix issues incrementally"
        ],
        "example": "An example of this concept in action.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Think about a time when AI gave you completely wrong code. Looking back, what was missing from your prompt? How would you write it differently now?",
        "quiz": [
          {
            "q": "What are the three elements of the effective code prompt formula?",
            "a": "Intent (what you want), Context (what AI needs to know), and Constraints (what to avoid)",
            "opts": [
              "Intent (what you want), Context (what AI needs to know), and Constraints (what to avoid)",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is the Example Pattern and when should you use it?",
            "a": "Showing input/output examples to clarify expected behavior - use when the function's behavior is complex or nuanced",
            "opts": [
              "Showing input/output examples to clarify expected behavior - use when the function's behavior is complex or nuanced",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why is combining too many requests in one prompt problematic?",
            "a": "Large requests produce lower-quality results because AI struggles to maintain focus across many requirements",
            "opts": [
              "Large requests produce lower-quality results because AI struggles to maintain focus across many requirements",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What should you do when AI repeatedly misunderstands your request?",
            "a": "Rephrase completely rather than adding more to a confusing prompt - start fresh with clearer language",
            "opts": [
              "Rephrase completely rather than adding more to a confusing prompt - start fresh with clearer language",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "How does the Reference Pattern improve code generation quality?",
            "a": "By pointing to existing code as a model, AI matches your project's patterns, style, and architecture",
            "opts": [
              "By pointing to existing code as a model, AI matches your project's patterns, style, and architecture",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you learned the formula for effective code prompts: Intent + Context + Constraints. You explored proven patterns (Example, Reference, Step-by-Step, Persona, Negative) and common mistakes to avoid. The key insight is that prompt quality directly determines output quality - investing in better prompts pays off exponentially. In the next module, we will look at the future of Vibe Coding and how to stay ahead of this rapidly evolving field."
      },
      {
        "id": 11,
        "module": "Module 6: Prompting for Software",
        "title": "Debugging and Refactoring with AI Assistance",
        "duration": "10-15 min",
        "intro": "Writing code is only half the battle. Real-world software development involves extensive debugging and refactoring - finding and fixing bugs, improving code quality, and adapting code as requirements change. AI assistance transforms these traditionally tedious tasks.\n\nThis lesson teaches you how to leverage AI for debugging and refactoring effectively. You will learn prompting techniques that help AI diagnose issues, systematic approaches to AI-assisted debugging, and how to use AI for safe, incremental refactoring without breaking existing functionality.\n\nThese skills are particularly valuable because debugging and refactoring are where many developers spend most of their time. Improving your effectiveness here creates outsized productivity gains.",
        "bigIdea": "AI excels at debugging when given the right information: error messages, relevant code, expected vs actual behavior, and what you have already tried. For refactoring, AI provides a safety net - you can confidently restructure code because AI helps you maintain functionality while changing structure. The key is learning to provide AI with the context it needs to help effectively.",
        "steps": [
          "Step 1: For debugging - gather all relevant information before engaging AI",
          "Step 2: Present problems with full context: error, code, expected vs actual",
          "Step 3: Ask for diagnosis before fixes",
          "Step 4: For refactoring - understand current behavior first",
          "Step 5: Have tests before refactoring",
          "Step 6: Make incremental changes, testing after each"
        ],
        "example": "Scenario: You have a 200-line function that handles user registration. It is hard to maintain and has bugs.\n\nStep 1: Ask AI to explain the function's complete behavior, documenting all cases.\n\nStep 2: Ask AI to generate comprehensive tests covering all cases.\n\nStep 3: Run tests to verify they pass with current code.\n\nStep 4: Ask AI: 'Refactor this registration function by extracting these concerns into separate functions: validation, duplicate checking, password hashing, email sending. The tests should still pass.'\n\nStep 5: Review the refactored code. Run tests. All pass.\n\nStep 6: Commit with confidence.\n\nResult: The 200-line function becomes 5 smaller, focused functions that are easier to understand, test, and maintain individually.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Think about a bug you spent hours debugging in the past. How would you present that bug to AI using the structured approach from this lesson? What information would you include?",
        "quiz": [
          {
            "q": "What five pieces of information should you gather before asking AI to debug?",
            "a": "Exact error message, relevant code, expected behavior, actual behavior, and what you've already tried",
            "opts": [
              "Exact error message, relevant code, expected behavior, actual behavior, and what you've already tried",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why should you apply AI-suggested fixes one at a time?",
            "a": "So you know which fix worked - multiple fixes at once obscure which change solved the problem",
            "opts": [
              "So you know which fix worked - multiple fixes at once obscure which change solved the problem",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is the most important principle of refactoring?",
            "a": "Preserve behavior - refactoring changes structure but not what the code does",
            "opts": [
              "Preserve behavior - refactoring changes structure but not what the code does",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why should you have tests before refactoring?",
            "a": "Tests catch any accidental behavioral changes introduced during refactoring",
            "opts": [
              "Tests catch any accidental behavioral changes introduced during refactoring",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What should you ask AI to do before requesting a refactoring?",
            "a": "Explain the current behavior - ensures you and AI understand what must be preserved",
            "opts": [
              "Explain the current behavior - ensures you and AI understand what must be preserved",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you learned systematic approaches to AI-assisted debugging and refactoring. For debugging, you now know how to gather context and present problems effectively. For refactoring, you understand the importance of tests, incremental changes, and behavior preservation. These skills apply across all Vibe Coding tools and represent some of the highest-value applications of AI assistance in development."
      },
      {
        "id": 12,
        "module": "Module 7: Building for Production",
        "title": "From Prototype to Production: Security, Performance, and Best Practices",
        "duration": "10-15 min",
        "intro": "Building a working prototype is exciting, but shipping it to real users requires more. Production software must be secure against attacks, performant under load, and reliable in ways prototypes do not need to be. This lesson bridges that gap.\n\nMany Vibe Coders build impressive prototypes but struggle with production readiness. AI-generated code often prioritizes functionality over security, performance over scalability, and working code over maintainable code. Knowing how to identify and address these gaps is essential for building software that can actually be deployed.\n\nBy the end of this lesson, you will have a checklist for production readiness and know how to use AI assistance to harden your applications for real-world use.",
        "bigIdea": "Production-ready software differs from prototypes in three key areas: security (protecting against attacks and data breaches), performance (handling real-world load efficiently), and reliability (working correctly even when things go wrong). AI-generated code often needs hardening in all three areas. Knowing what to check and how to fix it is the difference between a demo and a product.",
        "steps": [
          "Step 1: Run security audit prompt on your codebase",
          "Step 2: Fix all identified security issues",
          "Step 3: Run performance review prompt",
          "Step 4: Implement performance optimizations",
          "Step 5: Add reliability patterns (error handling, validation, health checks)",
          "Step 6: Complete production readiness checklist"
        ],
        "example": "Scenario: You built a task management app with Bolt and need to make it production-ready.\n\nStep 1 - Security Audit: 'Review this application for security vulnerabilities, focusing on authentication, authorization, and input handling.'\nAI identifies: hardcoded JWT secret, missing auth on API routes, no input validation.\n\nStep 2 - Fix Security Issues: 'Move JWT secret to environment variable. Add authentication middleware to /api routes. Add input validation for task creation.'\n\nStep 3 - Performance Review: 'Identify performance issues, especially around database queries.'\nAI identifies: N+1 query loading user's tasks with assigned members.\n\nStep 4 - Fix Performance: 'Refactor getTasksWithMembers to use a single query with JOIN instead of multiple queries.'\n\nStep 5 - Add Reliability: 'Add error handling, input validation, and a health check endpoint.'\n\nStep 6 - Final Review: Run through checklist, deploy with confidence.\n\nResult: A production-ready application that is secure, fast, and reliable.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Think about a website or application you use daily. What would happen if it had a security breach? What about if it went offline? This is why production readiness matters.",
        "quiz": [
          {
            "q": "What are the three key areas that distinguish production software from prototypes?",
            "a": "Security (protecting against attacks), Performance (handling load efficiently), and Reliability (working correctly when things go wrong)",
            "opts": [
              "Security (protecting against attacks), Performance (handling load efficiently), and Reliability (working correctly when things go wrong)",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why does AI-generated code often have security vulnerabilities?",
            "a": "AI optimizes for functionality and working code, not security - it takes the most direct path without considering attack vectors",
            "opts": [
              "AI optimizes for functionality and working code, not security - it takes the most direct path without considering attack vectors",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is an N+1 query problem and how do you fix it?",
            "a": "Loading related data with one query per item instead of bulk - fix with eager loading or batch queries",
            "opts": [
              "Loading related data with one query per item instead of bulk - fix with eager loading or batch queries",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What should a health check endpoint verify?",
            "a": "Database connectivity, cache availability, and key external dependencies - anything the app needs to function",
            "opts": [
              "Database connectivity, cache availability, and key external dependencies - anything the app needs to function",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why is input validation important for both security and reliability?",
            "a": "For security it prevents injection attacks and malicious input; for reliability it prevents crashes from unexpected data formats",
            "opts": [
              "For security it prevents injection attacks and malicious input; for reliability it prevents crashes from unexpected data formats",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you learned to bridge the gap between prototypes and production software. You now understand security vulnerabilities common in AI-generated code, performance optimizations needed for real users, and reliability patterns that keep your software running. Use the production readiness checklist before every deployment. This knowledge separates demo builders from product shippers."
      },
      {
        "id": 13,
        "module": "Module 8: The Future of Vibe Coding",
        "title": "The Evolving AI Landscape: Staying Current in a Rapidly Changing Field",
        "duration": "10-15 min",
        "intro": "The Vibe Coding landscape changes faster than any technology field in history. Tools that were cutting-edge six months ago may be obsolete today. New capabilities emerge weekly. This presents both opportunity and challenge.\n\nThis lesson prepares you for continuous learning in this rapidly evolving space. You will develop strategies for staying current, frameworks for evaluating new tools, and principles that remain constant even as specific tools change.\n\nThe goal is not to know every tool - that is impossible. The goal is to build learning habits and evaluation skills that let you quickly adopt valuable new capabilities while avoiding distraction from shiny objects that do not deliver real value.",
        "bigIdea": "While specific Vibe Coding tools change rapidly, the underlying principles remain stable: clear intent, systematic testing, iterative refinement, and human oversight. Building strong foundations in principles means you can quickly adapt to any new tool. Developing learning habits and evaluation frameworks matters more than mastering any single tool.",
        "steps": [
          "Step 1: Curate your information diet - select 3-5 high-quality sources",
          "Step 2: Schedule regular learning time (weekly scan, monthly deep-dive)",
          "Step 3: When new tools emerge, apply the evaluation framework before investing time",
          "Step 4: Try promising tools on real projects, not just tutorials",
          "Step 5: Invest in foundational skills that remain valuable as tools change"
        ],
        "example": "An example of this concept in action.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Think about a technology you learned 5 years ago. How much of that specific knowledge is still useful? What general skills from that learning remain valuable? This illustrates the difference between tool-specific and principle-based learning.",
        "quiz": [
          {
            "q": "What underlying principles of Vibe Coding remain stable even as tools change?",
            "a": "Clear communication, testing/validation, human judgment for decisions, security considerations, and problem decomposition",
            "opts": [
              "Clear communication, testing/validation, human judgment for decisions, security considerations, and problem decomposition",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is a sustainable approach to staying current with AI tools?",
            "a": "Curated information diet, scheduled learning time, hands-on evaluation, and community engagement",
            "opts": [
              "Curated information diet, scheduled learning time, hands-on evaluation, and community engagement",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is the first question to ask when evaluating a new AI tool?",
            "a": "Does it solve a real problem that I actually have?",
            "opts": [
              "Does it solve a real problem that I actually have?",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why will specification and requirements skills become more valuable?",
            "a": "As AI becomes more autonomous, defining what to build becomes more valuable than knowing how to build it",
            "opts": [
              "As AI becomes more autonomous, defining what to build becomes more valuable than knowing how to build it",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is the danger of chasing every new AI tool?",
            "a": "Exhaustion and distraction - you never develop depth in any tool while constantly switching",
            "opts": [
              "Exhaustion and distraction - you never develop depth in any tool while constantly switching",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson, you learned strategies for staying current in the rapidly evolving Vibe Coding landscape without burning out. You now have an evaluation framework for new tools and understand which skills remain valuable regardless of which specific tools dominate. The key insight is that principles endure while tools change - invest accordingly. In the final lesson, we will discuss building your career as a Vibe Coder."
      },
      {
        "id": 14,
        "module": "Module 8: The Future of Vibe Coding",
        "title": "Building Your Career as a Vibe Coder: Opportunities and Paths Forward",
        "duration": "10-15 min",
        "intro": "Congratulations on reaching the final lesson of this course. You have learned to use Full-Stack Builders, AI-First IDEs, and Agentic Tools. You understand prompting, debugging, production readiness, and staying current. Now it is time to turn these skills into real-world impact.\n\nThis lesson focuses on the career opportunities that Vibe Coding opens up. Whether you want to build your own products, freelance for clients, contribute to a team, or start a company, these skills create new paths that did not exist even two years ago.\n\nThe key insight is that Vibe Coding skills are not just about coding faster - they enable entirely new approaches to building products, serving clients, and creating value. Understanding these opportunities helps you make strategic choices about where to invest your energy next.",
        "bigIdea": "Vibe Coding creates three distinct opportunity paths: building products (creating your own applications and businesses), providing services (helping others build with AI), and contributing to teams (being the AI-powered developer that organizations need). Each path has different requirements and rewards. Understanding all three helps you choose the path that matches your goals.",
        "steps": [
          "Step 1: Complete your first full project this week",
          "Step 2: Deploy it and gather feedback from real users",
          "Step 3: Choose which opportunity path fits your goals",
          "Step 4: Build your portfolio with 3-5 deployed projects",
          "Step 5: Establish ongoing learning habits",
          "Step 6: Take the first step on your chosen path"
        ],
        "example": "An example of this concept in action.",
        "video": "https://www.youtube.com/watch?v=example",
        "reflection": "Where do you want to be in one year? How do your Vibe Coding skills help you get there? What is the first step you will take after completing this course?",
        "quiz": [
          {
            "q": "What are the three opportunity paths enabled by Vibe Coding skills?",
            "a": "Building products (your own applications), providing services (helping others build), and contributing to teams (being an AI-powered team member)",
            "opts": [
              "Building products (your own applications), providing services (helping others build), and contributing to teams (being an AI-powered team member)",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why does Vibe Coding particularly benefit solo entrepreneurs?",
            "a": "One person can now build what previously required a team, with faster validation and lower risk",
            "opts": [
              "One person can now build what previously required a team, with faster validation and lower risk",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What should a strong Vibe Coding portfolio include?",
            "a": "3-5 deployed applications with live links, diversity of complexity, documentation of process, and metrics where possible",
            "opts": [
              "3-5 deployed applications with live links, diversity of complexity, documentation of process, and metrics where possible",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Why is documenting development speed important for your portfolio?",
            "a": "The ability to build quickly is a key differentiator that sets Vibe Coders apart from traditional developers",
            "opts": [
              "The ability to build quickly is a key differentiator that sets Vibe Coders apart from traditional developers",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is the recommended first action after completing this course?",
            "a": "Build your first complete project this week, applying everything learned in the course",
            "opts": [
              "Build your first complete project this week, applying everything learned in the course",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this final lesson, you explored the career opportunities that Vibe Coding enables: building your own products, providing services to others, and contributing to teams as an AI-powered developer. You have a framework for building a compelling portfolio and a clear action plan for what to do next. The most important thing now is to take action - build something this week, deploy it, and start your journey. Thank you for completing this course. The future of software development is in your hands."
      },
      {
        "id": 15,
        "module": "Exploring and Building with Confidence",
        "title": "Your First Complete Vibe-Coded Project",
        "duration": "10-15 min",
        "intro": "Welcome to \"Your First Complete Vibe-Coded Project\" in the Vibe Coding course! In this lesson, we'll explore this important concept in a beginner-friendly way. Remember, there's no need to feel anxious - we'll take this step by step with plenty of guidance and support.",
        "bigIdea": "Your first complete project brings together all the Vibe Coding principles you've learned. It demonstrates how to create a functional digital product while maintaining focus on ideas and creativity.",
        "steps": [
          "Step 1: Understand the main concept of this lesson",
          "Step 2: Learn how this concept applies to Vibe Coding",
          "Step 3: See practical examples of this concept in action",
          "Step 4: Practice applying this concept in the playground",
          "Step 5: Reflect on how this fits into your learning journey"
        ],
        "example": "An example of this concept in action.",
        "video": "",
        "reflection": "How does the concept of \"Your First Complete Vibe-Coded Project\" change the way you think about creating digital products? Can you think of an example from your own experience where this approach might have been helpful?",
        "quiz": [
          {
            "q": "What is the main focus of Your First Complete Vibe-Coded Project?",
            "a": "The specific concept covered in this lesson",
            "opts": [
              "The specific concept covered in this lesson",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "How does this concept benefit beginners?",
            "a": "It reduces anxiety and makes learning accessible",
            "opts": [
              "It reduces anxiety and makes learning accessible",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "Is this concept part of Vibe Coding's core principles?",
            "a": "Yes, it's a core principle of Vibe Coding",
            "opts": [
              "Yes, it's a core principle of Vibe Coding",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "What is one practical application of this concept?",
            "a": "Applying this concept in digital creation projects",
            "opts": [
              "Applying this concept in digital creation projects",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          },
          {
            "q": "How does this concept build confidence in learners?",
            "a": "By focusing on ideas and providing guidance rather than complexity",
            "opts": [
              "By focusing on ideas and providing guidance rather than complexity",
              "Option 2",
              "Option 3",
              "Option 4"
            ]
          }
        ],
        "summary": "In this lesson on \"Your First Complete Vibe-Coded Project\", you've learned an important concept in Vibe Coding. You now understand how this fits into the bigger picture of creating digital products with confidence. You're building a strong foundation for your journey in Vibe Coding."
      }
    ]
  },
  "prompt-engineering": {
    "title": "Prompt Engineering Mastery",
    "lessons": [
      {
        "id": 1,
        "module": "Module 1: Prompt Engineering Foundations",
        "title": "What Prompt Engineering Really Is",
        "duration": "10-15 min",
        "intro": "Prompt engineering is the systematic practice of designing and refining instructions that guide AI systems to produce specific, desired outputs. In this foundational lesson, we'll explore what prompt engineering truly means in 2025, why it matters more than ever, and how it differs from casual AI interaction. This skill has evolved from simple 'prompt tricks' to a systematic discipline used by AI builders, product teams, automation engineers, marketers, educators, and founders to create reliable, scalable AI interactions.\n\nUnlike traditional programming where you write code to achieve results, prompt engineering involves crafting precise language instructions that an AI model interprets to generate outputs. This requires understanding how AI models process information, what makes instructions clear and actionable, and how to structure prompts for consistent results.\n\nThe importance of prompt engineering has exploded as organizations move from experimental AI usage to production-level AI systems. Companies now hire dedicated prompt engineers, and teams deploying AI across multiple tools need systematic approaches that go beyond trial-and-error prompting. This lesson establishes the foundation for building those systematic skills.",
        "bigIdea": "Prompt engineering is the systematic discipline of designing precise instructions that guide AI behavior, moving from trial-and-error to reliable, reusable AI systems. It's not about tricks or shortcutsâ€”it's about understanding how to communicate with AI systems in ways that produce consistent, predictable results at scale.",
        "steps": [
          "Step 1: Define the specific role or persona for the AI to assume (e.g., 'You are an expert financial analyst')",
          "Step 2: Clearly specify the task with all necessary context and requirements",
          "Step 3: Set explicit constraints and boundaries (what to avoid, formatting requirements, etc.)",
          "Step 4: Define the exact output format needed for integration with other systems",
          "Step 5: Test the prompt with different inputs to ensure consistency and refine as needed"
        ],
        "example": "Consider a marketing team that needs AI to generate social media content. Their initial approach was casual: 'Write a Facebook post about our new product.' This produced inconsistent results with varying tone, length, and quality.\n\nUsing prompt engineering principles, they created a systematic approach: 'You are an expert social media manager for a B2B SaaS company. Write a 150-word Facebook post in a professional but approachable tone. Target audience: marketing professionals aged 28-40. Include one customer testimonial, one benefit-focused bullet point, and a clear call-to-action. Avoid buzzwords like 'revolutionary' and 'game-changing.' Format as: Hook sentence, value proposition, testimonial, benefits, CTA.'\n\nThis systematic prompt produced consistent, on-brand content that met their requirements every time, saving hours of manual editing and revision.",
        "video": "https://www.youtube.com/watch?v=example1",
        "reflection": "Think about a task where you've used AI but got inconsistent or unsatisfactory results. How might you restructure your request using the systematic approach to prompt engineering rather than treating it as a casual conversation?",
        "quiz": [
          {
            "q": "What is the primary difference between casual AI use and professional prompt engineering?",
            "a": "Professional prompt engineering uses systematic, structured approaches with defined components while casual use relies on natural language requests hoping for good results",
            "opts": [
              "Professional prompt engineering costs more to implement",
              "Professional prompt engineering uses systematic, structured approaches with defined components while casual use relies on natural language requests hoping for good results",
              "Casual AI use is more creative than professional prompt engineering",
              "There is no real difference between the two approaches"
            ]
          },
          {
            "q": "Why do most AI failures actually stem from instruction problems rather than AI limitations?",
            "a": "Most AI failures occur because prompts are vague, lack context, have unclear expectations, or contain contradictory requirements",
            "opts": [
              "AI models are inherently unreliable and buggy",
              "Most AI failures occur because prompts are vague, lack context, have unclear expectations, or contain contradictory requirements",
              "AI models are designed to fail to encourage human oversight",
              "Companies deliberately limit AI capabilities to sell more services"
            ]
          },
          {
            "q": "Which of the following is NOT a core component of systematic prompt engineering?",
            "a": "Relying on the AI's creativity to fill in missing details",
            "opts": [
              "Defining the role or persona for the AI",
              "Specifying the task with context and requirements",
              "Relying on the AI's creativity to fill in missing details",
              "Setting explicit constraints and boundaries"
            ]
          },
          {
            "q": "How does treating AI interaction as 'giving instructions' rather than 'having a conversation' improve results?",
            "a": "It eliminates ambiguity by being explicit about requirements, providing clear examples, specifying constraints, and defining success criteria",
            "opts": [
              "It makes AI responses more creative and unpredictable",
              "It eliminates ambiguity by being explicit about requirements, providing clear examples, specifying constraints, and defining success criteria",
              "It allows AI to better understand human emotions and context",
              "It reduces the computational resources needed by the AI"
            ]
          },
          {
            "q": "What is the main benefit of using systematic prompt engineering in professional settings?",
            "a": "It ensures consistent, high-quality results that can be relied upon in production environments and scaled across teams",
            "opts": [
              "It allows for more casual, creative interactions with AI",
              "It ensures consistent, high-quality results that can be relied upon in production environments and scaled across teams",
              "It makes AI responses faster and more efficient",
              "It reduces the cost of using AI systems"
            ]
          }
        ],
        "summary": "In this lesson, we've established that prompt engineering is a systematic discipline focused on designing precise instructions that guide AI behavior reliably. We've explored the difference between casual AI use and professional prompt engineering, understood why most AI failures are actually instruction failures, and learned the core concepts that differentiate systematic approaches from trial-and-error methods. This foundation prepares you to build reliable, scalable AI interactions that can be used professionally and integrated into production systems."
      },
      {
        "id": 2,
        "module": "Module 1: Prompt Engineering Foundations",
        "title": "How AI Interprets Instructions",
        "duration": "10-15 min",
        "intro": "Understanding how AI systems interpret instructions is fundamental to effective prompt engineering. In this lesson, we'll explore the mechanics of how AI models process prompts, what happens when you submit a request, and why understanding these processes helps you craft more effective instructions. This knowledge enables you to design prompts that align with how AI systems actually work, rather than how we might intuitively expect them to work.\n\nUnlike human communication, where we use context, tone, and shared understanding to interpret meaning, AI models process text as sequences of tokens and use statistical patterns to generate responses. This mechanical process follows predictable patterns that, when understood, allow you to craft instructions that produce more reliable and accurate outputs.\n\nWe'll examine the technical aspects of AI processing in simple terms, explore how context affects interpretation, and understand why certain prompt structures work better than others. This foundational knowledge will inform all your future prompt engineering efforts.",
        "bigIdea": "AI models process prompts as sequences of tokens using statistical patterns, not as human-like understanding. Effective prompt engineering aligns your instructions with how AI systems actually process information, leading to more predictable and reliable outputs. Understanding these mechanics allows you to design prompts that work with the AI's processing methods rather than against them.",
        "steps": [
          "Step 1: Understand the tokenization process of your target AI model",
          "Step 2: Structure your prompt with important information at the beginning and end",
          "Step 3: Provide clear role definitions and explicit instructions",
          "Step 4: Include relevant examples that demonstrate the desired output pattern",
          "Step 5: Test your prompt with different orderings to optimize for the specific AI model"
        ],
        "example": "Consider an AI tasked with generating technical documentation. A prompt that simply says 'Write good documentation' produces inconsistent results because the AI doesn't know what 'good documentation' means in your specific context.\n\nA better approach uses understanding of AI mechanics: 'You are an experienced technical writer. Documentation format: [Title, Overview, Prerequisites, Step-by-step instructions, Example code, Troubleshooting]. Tone: Clear, concise, beginner-friendly. Here's an example of good documentation: [detailed example]. Now document the user authentication API endpoint.'\n\nThis prompt works better because it provides explicit structure (the format), clear constraints (the tone), and a specific example to follow. The AI processes these components as patterns to replicate, producing consistent, well-structured documentation.",
        "video": "https://www.youtube.com/watch?v=example2",
        "reflection": "Think about a time when an AI response surprised you or didn't match your expectations. How might understanding the AI's pattern-based processing have helped you structure your request differently?",
        "quiz": [
          {
            "q": "How do AI models primarily process text instructions?",
            "a": "AI models process text as sequences of tokens using statistical patterns to predict the next most likely tokens",
            "opts": [
              "AI models process text the same way humans do, with context and understanding",
              "AI models process text as sequences of tokens using statistical patterns to predict the next most likely tokens",
              "AI models use a complex algorithm that mimics human thought processes",
              "AI models analyze text based on semantic meaning and emotional context"
            ]
          },
          {
            "q": "Why is understanding context windows important in prompt engineering?",
            "a": "Context windows determine how much information the AI can process, and information at the beginning and end may be weighted differently",
            "opts": [
              "Context windows determine how much information the AI can process, and information at the beginning and end may be weighted differently",
              "Context windows only affect the speed of AI processing",
              "Context windows are marketing terms with no practical impact",
              "Context windows only matter for very long documents"
            ]
          },
          {
            "q": "What is the main difference between how humans and AI models interpret instructions?",
            "a": "Humans use context, tone, and shared understanding, while AI models recognize patterns and respond to explicit instructions",
            "opts": [
              "Humans use context, tone, and shared understanding, while AI models recognize patterns and respond to explicit instructions",
              "Humans are more creative than AI models when interpreting instructions",
              "AI models are better at understanding complex instructions than humans",
              "There is no significant difference in how humans and AI interpret instructions"
            ]
          },
          {
            "q": "Why are examples particularly effective in prompts?",
            "a": "Examples show the AI exactly what pattern to follow, which is often more effective than abstract instructions",
            "opts": [
              "Examples show the AI exactly what pattern to follow, which is often more effective than abstract instructions",
              "Examples make prompts longer and more impressive to human readers",
              "Examples are only useful for creative tasks, not technical ones",
              "Examples are required by AI model licensing agreements"
            ]
          },
          {
            "q": "How does the ordering of information in a prompt affect AI interpretation?",
            "a": "Information at the beginning and end of prompts often gets more weight in the AI's processing",
            "opts": [
              "Information at the beginning and end of prompts often gets more weight in the AI's processing",
              "Ordering only matters for creative writing, not technical tasks",
              "AI models process all information in a prompt equally regardless of order",
              "Ordering affects only the speed of AI response, not the content"
            ]
          }
        ],
        "summary": "In this lesson, we've explored how AI systems actually process instructions, understanding that they operate as sophisticated pattern recognition systems rather than systems with human-like understanding. We've examined the importance of tokens and context windows, learned why explicit instructions work better than implicit assumptions, and discovered how examples effectively shape AI output. This foundational knowledge will help you craft prompts that work with AI's actual processing methods rather than against them, leading to more reliable and predictable results in all your future prompt engineering efforts."
      },
      {
        "id": 3,
        "module": "Module 1: Prompt Engineering Foundations",
        "title": "Prompt Engineering vs Traditional Instructions",
        "duration": "10-15 min",
        "intro": "Understanding the differences between prompt engineering and traditional instruction methods is crucial for mastering this discipline. While traditional instruction methods assume human understanding, context awareness, and common sense, prompt engineering must account for how AI systems process information through pattern recognition and statistical modeling. This lesson explores the fundamental distinctions that shape how you should approach crafting instructions for AI systems.\n\nTraditional human instructions rely on shared context, implicit understanding, and the ability to ask clarifying questions. AI systems, however, process prompts as sequences of tokens and respond based on learned patterns without the ability to seek clarification or fill in gaps with common sense. This fundamental difference requires a completely different approach to instruction design.\n\nWe'll examine how to adapt traditional instruction principles for AI systems, identify common pitfalls when applying human instruction techniques to AI, and develop strategies for creating instructions that work effectively with AI's processing methods. This understanding forms the foundation for all advanced prompt engineering techniques.",
        "bigIdea": "Prompt engineering requires explicit, structured instructions that account for AI's pattern-based processing, unlike traditional human instructions that rely on shared context and common sense. Effective prompt engineering eliminates ambiguity, provides clear examples, and specifies constraints explicitly because AI systems process instructions differently than humans. Understanding these differences is essential for creating reliable, predictable AI interactions.",
        "steps": [
          "Step 1: Identify what context a human would assume but an AI cannot",
          "Step 2: Explicitly state all constraints, boundaries, and requirements",
          "Step 3: Provide clear examples of desired output patterns",
          "Step 4: Specify the target audience and their characteristics",
          "Step 5: Test and refine to ensure the AI has sufficient context to produce desired results"
        ],
        "example": "Consider the difference between asking a human graphic designer versus an AI to create a logo. For a human, you might say: 'Create a modern logo for a tech startup that works in fintech.' The human designer would apply their knowledge of design principles, current trends, and fintech industry characteristics.\n\nFor an AI, effective prompt engineering requires explicit instructions: 'Create a logo for FintechFlow, a financial technology startup. Style: Modern, minimalist, professional. Colors: Blue and white, conveying trust and innovation. Elements: Abstract representation of flow or connection. Avoid: Charts, coins, traditional banking symbols. Format: SVG with hex codes. Target audience: Financial professionals aged 28-45.'\n\nThe AI prompt is much more explicit because it provides all the context and constraints that a human would infer from common sense and experience.",
        "video": "https://www.youtube.com/watch?v=example3",
        "reflection": "Think about a time when an AI response was different from what you expected. How might the differences have stemmed from the AI lacking common sense or context that a human would have assumed?",
        "quiz": [
          {
            "q": "What is the main difference between delegating to humans versus AI systems?",
            "a": "Humans can rely on shared context and common sense while AI needs explicit instructions with no gaps in logic or missing context",
            "opts": [
              "There is no significant difference between delegating to humans versus AI",
              "Humans can rely on shared context and common sense while AI needs explicit instructions with no gaps in logic or missing context",
              "AI systems are more creative and flexible than humans",
              "Humans require more detailed instructions than AI systems"
            ]
          },
          {
            "q": "Why do AI systems need explicit boundaries in prompts?",
            "a": "AI systems respond to patterns and may extrapolate beyond intended boundaries without explicit constraints",
            "opts": [
              "AI systems respond to patterns and may extrapolate beyond intended boundaries without explicit constraints",
              "Explicit boundaries make the prompt longer and more impressive",
              "AI systems only follow boundaries when they are explicitly told to",
              "Explicit boundaries are required by AI model licensing agreements"
            ]
          },
          {
            "q": "What does it mean that AI lacks 'common sense'?",
            "a": "AI systems process text based on learned patterns without the ability to fill in gaps with general world knowledge or apply practical judgment",
            "opts": [
              "AI systems process text based on learned patterns without the ability to fill in gaps with general world knowledge or apply practical judgment",
              "AI systems are intentionally designed to ignore common sense",
              "AI systems have better common sense than humans",
              "Common sense is not relevant for AI systems"
            ]
          },
          {
            "q": "How does AI creativity differ from human creativity?",
            "a": "AI excels at following patterns with specific parameters while humans can think outside the box in novel ways",
            "opts": [
              "AI excels at following patterns with specific parameters while humans can think outside the box in novel ways",
              "AI creativity is superior to human creativity in all contexts",
              "Human creativity is just pattern matching like AI",
              "AI and human creativity work exactly the same way"
            ]
          },
          {
            "q": "Why is it important to provide explicit examples in AI prompts?",
            "a": "AI systems need examples to understand the exact patterns they should follow, as they cannot infer patterns from abstract descriptions alone",
            "opts": [
              "AI systems need examples to understand the exact patterns they should follow, as they cannot infer patterns from abstract descriptions alone",
              "Examples make prompts look more professional to human reviewers",
              "AI systems are required by design to follow examples exactly",
              "Examples are only useful for creative tasks, not technical ones"
            ]
          }
        ],
        "summary": "In this lesson, we've explored the fundamental differences between prompt engineering and traditional human instruction methods. We've learned that AI systems require explicit instructions without gaps in logic, as they lack common sense and the ability to infer missing context. We've examined how to set clear boundaries, provide sufficient examples, and adapt traditional instruction techniques for AI's pattern-based processing. This understanding forms the foundation for creating reliable, predictable AI interactions that can scale across professional settings."
      },
      {
        "id": 4,
        "module": "Module 2: Prompt Structure & Control",
        "title": "Core Prompt Components",
        "duration": "10-15 min",
        "intro": "Every effective prompt follows a structured approach with specific components that guide AI behavior. In this lesson, we'll examine the essential elements that make prompts reliable and effective. Understanding these components allows you to systematically build prompts that produce consistent, high-quality results across different AI models and use cases.\n\nA well-structured prompt is like a well-designed form with clear sections that guide the AI through the task systematically. Each component serves a specific purpose and contributes to the overall effectiveness of the instruction. The order and clarity of these components significantly impact the quality of the output.\n\nWe'll explore each component in detail, understand how they interact, and learn to apply them systematically to create prompts that work reliably in professional settings. This foundation will support all your future prompt engineering efforts.",
        "bigIdea": "Effective prompts follow a structured approach with specific components: Role definition, Task definition, Constraints, Output format, Tone & style, and Scope limits. Each component serves a specific function in guiding AI behavior, and systematic use of these components creates reliable, predictable results. Understanding how to combine these elements allows you to build prompts that work consistently across different scenarios.",
        "steps": [
          "Step 1: Define the specific role or persona for the AI to assume",
          "Step 2: Clearly specify the exact task with all requirements",
          "Step 3: Set explicit constraints and boundaries for the output",
          "Step 4: Define the precise output format needed",
          "Step 5: Specify tone, style, and other relevant parameters",
          "Step 6: Test the prompt to ensure all components work together effectively"
        ],
        "example": "Consider a company that needs to generate product descriptions. A poorly structured prompt might be: 'Write a product description.' This produces inconsistent results with varying length, tone, and format.\n\nA well-structured prompt using core components: 'You are an experienced e-commerce copywriter with expertise in consumer electronics (Role). Write a product description for our new wireless headphones (Task). Include key features, target audience, and benefits. Keep it under 200 words. Use a professional but approachable tone. Avoid technical jargon that non-technical customers won't understand (Constraints). Format as: Product name, Key features list, Target audience, Benefits, Call to action (Output Format).'\n\nThis structured approach produces consistent, on-brand product descriptions that meet all requirements every time.",
        "video": "https://www.youtube.com/watch?v=example4",
        "reflection": "Think about a time when an AI response didn't meet your expectations. How might including all core prompt components have improved the result?",
        "quiz": [
          {
            "q": "What is the primary purpose of the role definition component in a prompt?",
            "a": "To establish who the AI should act as when completing the task, providing expertise and perspective",
            "opts": [
              "To make the prompt longer and more impressive",
              "To establish who the AI should act as when completing the task, providing expertise and perspective",
              "To show off your knowledge of AI systems",
              "To slow down the AI's processing time"
            ]
          },
          {
            "q": "Which component of a structured prompt specifies what the AI should NOT do?",
            "a": "Constraints and Boundaries component",
            "opts": [
              "Task Definition component",
              "Constraints and Boundaries component",
              "Role Definition component",
              "Output Format component"
            ]
          },
          {
            "q": "Why are output format specifications important in professional settings?",
            "a": "They ensure consistency and make outputs suitable for integration with other systems",
            "opts": [
              "They make the prompt look more professional",
              "They ensure consistency and make outputs suitable for integration with other systems",
              "They slow down the AI's response time",
              "They are required by AI model licensing agreements"
            ]
          },
          {
            "q": "How does a well-defined task definition improve prompt effectiveness?",
            "a": "It clearly specifies what the AI should do with specific requirements and expectations",
            "opts": [
              "It clearly specifies what the AI should do with specific requirements and expectations",
              "It makes the prompt more creative and interesting",
              "It reduces the computational resources needed",
              "It forces the AI to respond in a specific language"
            ]
          },
          {
            "q": "What happens when you rely on the AI to infer missing prompt components?",
            "a": "The results become inconsistent and unpredictable because AI cannot fill in missing context like humans",
            "opts": [
              "The AI automatically fills in missing context like a human would",
              "The results become inconsistent and unpredictable because AI cannot fill in missing context like humans",
              "The AI produces better results because it has more freedom",
              "Nothing happens; AI doesn't need complete prompts"
            ]
          }
        ],
        "summary": "In this lesson, we've explored the core components that make prompts effective: Role definition, Task definition, Constraints, and Output format. We've learned how each component serves a specific function in guiding AI behavior and how they work together to create reliable, predictable results. This systematic approach transforms prompt engineering from trial-and-error to a structured discipline that produces consistent results across different scenarios and AI models. Understanding these fundamentals provides the foundation for all advanced prompt engineering techniques."
      },
      {
        "id": 5,
        "module": "Module 2: Prompt Structure & Control",
        "title": "Context Layering",
        "duration": "10-15 min",
        "intro": "Context layering is the strategic placement and organization of information within a prompt to maximize its effectiveness. In this lesson, we'll explore how to structure context at different levels to guide AI behavior without overwhelming the system with unnecessary information. Effective context layering creates prompts that are both comprehensive and efficient.\n\nAI models have limited context windows, so how you layer and prioritize information significantly impacts the results. The most important information should be placed where the AI is most likely to attend to it, while supporting context should be organized to enhance rather than dilute the core instructions.\n\nWe'll examine different types of context, understand how to layer them effectively, and learn to balance comprehensive instructions with processing limitations. This skill is essential for creating prompts that work reliably in complex, real-world scenarios.",
        "bigIdea": "Context layering involves strategically organizing information within prompts at different levels: global context (broad instructions), local context (task-specific details), and persistent vs temporary instructions. The placement of information affects how AI processes and prioritizes it. Effective context layering ensures critical instructions receive attention while supporting information enhances rather than dilutes the core message.",
        "steps": [
          "Step 1: Identify global context that applies broadly across tasks",
          "Step 2: Determine local context specific to the current task",
          "Step 3: Separate persistent instructions from temporary requirements",
          "Step 4: Organize information with critical instructions at high-attention positions",
          "Step 5: Test the prompt to ensure context layering supports rather than hinders the task",
          "Step 6: Optimize the balance between comprehensive context and processing efficiency"
        ],
        "example": "Consider a content creation system for a company with specific brand guidelines. A poorly structured approach might dump all brand guidelines at the beginning: 'Our company values, brand voice, target audience, competitor analysis, market position, customer demographics, product details, tone requirements, style guide, and formatting rules,' followed by 'Now write a blog post about X.'\n\nA better approach uses context layering: 'You are an experienced content marketer for [Company]. Follow our brand voice: professional but approachable, customer-focused, value-driven (Global Context). Write a 800-word blog post about [Topic] for marketing professionals aged 28-45 (Local Context). Include 3 key takeaways and a call-to-action. Avoid technical jargon (Persistent Instructions). Address the specific challenges of [specific topic details] (Temporary Instructions).'\n\nThis layered approach ensures critical brand guidelines are established while specific task details remain clear and actionable.",
        "video": "https://www.youtube.com/watch?v=example5",
        "reflection": "Think about a time when an AI response seemed to ignore important instructions. How might poor context layering have contributed to this outcome?",
        "quiz": [
          {
            "q": "What is the difference between global and local context in prompt engineering?",
            "a": "Global context includes broad, general instructions; local context includes task-specific details",
            "opts": [
              "There is no difference between global and local context",
              "Global context includes broad, general instructions; local context includes task-specific details",
              "Global context is more important than local context",
              "Local context is used only for creative tasks"
            ]
          },
          {
            "q": "Why does context dumping reduce prompt effectiveness?",
            "a": "It overwhelms the AI's processing capacity and dilutes important instructions with excessive information",
            "opts": [
              "It makes the prompt look more professional",
              "It overwhelms the AI's processing capacity and dilutes important instructions with excessive information",
              "AI models prefer longer prompts with more context",
              "Context dumping is required for complex tasks"
            ]
          },
          {
            "q": "How does the position of information in a prompt affect AI processing?",
            "a": "Information at the beginning and end often receives more attention than information in the middle",
            "opts": [
              "Position has no impact on AI processing",
              "Information at the beginning and end often receives more attention than information in the middle",
              "Middle information is always processed most carefully",
              "AI processes all information in a prompt equally regardless of position"
            ]
          },
          {
            "q": "What are persistent instructions in the context of prompt engineering?",
            "a": "Instructions that should apply across multiple interactions or remain in effect for extended periods",
            "opts": [
              "Instructions that apply only to a single interaction",
              "Instructions that should apply across multiple interactions or remain in effect for extended periods",
              "Instructions that are only used for creative tasks",
              "Instructions that are temporary and change frequently"
            ]
          },
          {
            "q": "What happens when you don't properly layer context in a prompt?",
            "a": "Critical instructions may be ignored or diluted, leading to inconsistent or irrelevant results",
            "opts": [
              "The AI processes all information more carefully",
              "Critical instructions may be ignored or diluted, leading to inconsistent or irrelevant results",
              "The results become more creative and innovative",
              "Nothing negative happens; AI handles context automatically"
            ]
          }
        ],
        "summary": "In this lesson, we've explored context layering - the strategic organization of information within prompts to maximize effectiveness. We've learned to distinguish between global and local context, understand the difference between persistent and temporary instructions, and recognize how information position affects AI processing. We've also examined why context dumping reduces quality and how to balance comprehensive instructions with processing limitations. This understanding enables you to create prompts that work reliably within AI processing constraints while providing sufficient context for high-quality results."
      },
      {
        "id": 6,
        "module": "Module 2: Prompt Structure & Control",
        "title": "Constraints & Guardrails",
        "duration": "10-15 min",
        "intro": "Constraints and guardrails are essential elements that define boundaries and prevent unwanted behaviors in AI outputs. In this lesson, we'll explore how to implement effective constraints that guide AI behavior without stifling its capabilities. Well-designed constraints ensure outputs meet specific requirements while maintaining the AI's ability to generate creative and useful responses.\n\nUnlike human communication where we assume shared understanding of boundaries and social norms, AI systems need explicit constraints to prevent them from generating inappropriate, inaccurate, or off-topic content. These constraints act as guardrails that keep the AI within acceptable parameters while allowing it to operate effectively within those boundaries.\n\nWe'll examine different types of constraints, learn how to implement them effectively, and understand how to balance restrictive requirements with creative freedom. This knowledge is crucial for creating prompts that produce reliable results in professional and public contexts.",
        "bigIdea": "Effective constraints and guardrails explicitly define boundaries for AI behavior, preventing hallucinations, enforcing formats, specifying what NOT to do, and ensuring outputs meet specific requirements. These constraints act as safety measures that guide AI behavior without eliminating its problem-solving capabilities. Well-designed constraints enhance rather than limit AI effectiveness by providing clear boundaries within which the AI can operate optimally.",
        "steps": [
          "Step 1: Identify potential problematic behaviors or outputs to prevent",
          "Step 2: Define specific format requirements for consistent outputs",
          "Step 3: Specify content boundaries and what to avoid",
          "Step 4: Set scope limits for appropriate depth and breadth",
          "Step 5: Test constraints to ensure they guide rather than overly restrict behavior",
          "Step 6: Refine constraints based on actual usage and results"
        ],
        "example": "Consider an AI system used to generate customer support responses. Without constraints, it might provide medical advice when asked about health-related products, give specific pricing information it doesn't have, or create responses that don't match the company's brand voice.\n\nWith effective constraints: 'You are a customer support specialist for TechCorp. Only provide information from our official documentation. If uncertain about technical details, direct customers to our support team. Do not provide medical advice, legal opinions, or specific pricing not in our documentation. Maintain a helpful, professional tone. Format responses as: Acknowledgment, Information, Next steps. Limit to 150 words.'\n\nThis constrained approach produces consistent, appropriate responses that protect the company while helping customers effectively.",
        "video": "https://www.youtube.com/watch?v=example6",
        "reflection": "Think about a time when an AI generated something inappropriate or off-topic. How might explicit constraints have prevented this outcome?",
        "quiz": [
          {
            "q": "What is the primary purpose of constraints in prompt engineering?",
            "a": "To define boundaries and prevent unwanted behaviors while maintaining AI effectiveness",
            "opts": [
              "To make prompts longer and more impressive",
              "To define boundaries and prevent unwanted behaviors while maintaining AI effectiveness",
              "To slow down AI processing time",
              "To show off your knowledge of AI systems"
            ]
          },
          {
            "q": "How do format constraints improve professional AI interactions?",
            "a": "They ensure outputs follow specific structures required for integration and consistency",
            "opts": [
              "They make the prompt look more professional",
              "They ensure outputs follow specific structures required for integration and consistency",
              "They force the AI to use specific words",
              "They are required by AI model licensing agreements"
            ]
          },
          {
            "q": "Why is it important to specify what NOT to do in constraints?",
            "a": "Negative constraints prevent inappropriate content and off-topic responses",
            "opts": [
              "It's not important to specify what NOT to do",
              "Negative constraints prevent inappropriate content and off-topic responses",
              "Positive constraints are always more effective than negative ones",
              "AI systems automatically know what not to do"
            ]
          },
          {
            "q": "What are AI hallucinations in the context of prompt engineering?",
            "a": "When the AI generates information that sounds plausible but is factually incorrect",
            "opts": [
              "When the AI refuses to respond to any prompts",
              "When the AI generates information that sounds plausible but is factually incorrect",
              "When the AI responds too slowly to prompts",
              "When the AI uses too many technical terms"
            ]
          },
          {
            "q": "How do scope constraints improve AI output quality?",
            "a": "They prevent responses from becoming too broad, too narrow, or off-topic",
            "opts": [
              "They make the AI respond more slowly",
              "They prevent responses from becoming too broad, too narrow, or off-topic",
              "They force the AI to use specific formatting",
              "They are only important for creative tasks"
            ]
          }
        ],
        "summary": "In this lesson, we've explored constraints and guardrails - essential elements that define boundaries for AI behavior while maintaining its effectiveness. We've learned to prevent hallucinations, enforce specific formats, specify negative constraints (what NOT to do), and maintain scope control. We've examined how well-designed constraints enhance rather than limit AI capabilities by providing clear boundaries within which the AI can operate optimally. This knowledge is crucial for creating prompts that produce reliable, appropriate results in professional contexts."
      },
      {
        "id": 7,
        "module": "Intermediate Prompt Techniques",
        "title": "Few-Shot Learning and Examples",
        "duration": "10-15 min",
        "intro": "In this lesson, we'll explore few-shot learning techniques, which involve providing examples within your prompt to guide the AI's response. Few-shot prompting is a powerful technique that allows you to demonstrate the desired format, style, or approach by showing examples directly in the prompt. This method is particularly effective for tasks that require specific formatting or complex patterns. When you provide examples, you're essentially showing the AI a template of what you want, which eliminates ambiguity and leads to much more consistent and accurate outputs. This technique is especially valuable when you need specific formatting, structured responses, or when the task involves complex patterns that are difficult to describe in abstract terms.",
        "bigIdea": "Few-shot learning is a powerful prompting technique where you provide specific examples within your prompt to guide the AI toward the desired output format, style, and approach. By showing the AI exactly what you want through concrete examples, you eliminate guesswork and significantly improve the quality and consistency of the responses. This technique works because AI models can recognize patterns in the examples you provide and apply those same patterns to your new request, resulting in outputs that closely match your expectations.",
        "steps": [
          "Identify the pattern you want the AI to learn by analyzing what specific format, style, or approach you need",
          "Create 2-5 clear, representative examples that showcase the exact output you want, ensuring they cover different variations of your task",
          "Format examples consistently using clear separators and identical structure to reinforce the pattern",
          "Clearly separate examples from the actual task with distinct labels or formatting",
          "Test and refine the examples for clarity by running the prompt and adjusting as needed"
        ],
        "example": "For creating product descriptions, you might provide: 'Example 1: Product: Wireless headphones. Description: Premium noise-canceling headphones with 30-hour battery life. Perfect for travelers and office workers. Key features: Noise cancellation, 30-hour battery, comfortable fit, Bluetooth 5.0. Target audience: Professionals and frequent travelers. Tone: Professional yet approachable. Example 2: Product: Smart water bottle. Description: Hydration tracker that reminds you to drink water and monitors your daily intake. Ideal for fitness enthusiasts. Key features: Hydration tracking, smart reminders, temperature control, BPA-free materials. Target audience: Health-conscious individuals. Tone: Health-focused and motivational. Example 3: Product: Portable phone charger. Description: Ultra-slim portable charger with 20,000mAh capacity. Perfect for travelers and heavy users. Key features: Fast charging, multiple ports, lightweight, LED indicator. Target audience: Tech-savvy travelers. Tone: Tech-focused and practical. Now write a description for: Product: Ergonomic keyboard.' This comprehensive approach gives the AI clear examples of the format, key elements to include, target audience, and tone to use. This detailed structure ensures the AI understands exactly how to format the response and what information to include.",
        "video": "",
        "reflection": "Consider how few-shot learning changes the way you approach AI tasks. How does providing examples versus describing requirements in abstract terms change the quality and predictability of the results? Reflect on which types of tasks benefit most from few-shot prompting and why this technique is so effective for complex or specific requirements.",
        "quiz": [
          {
            "q": "What is the main purpose of few-shot learning in prompts?",
            "a": "To provide examples that demonstrate the desired format or approach",
            "opts": [
              "To make the AI respond faster",
              "To provide examples that demonstrate the desired format or approach",
              "To reduce the cost of using AI",
              "To make the AI more creative"
            ]
          },
          {
            "q": "How does the quality of examples in few-shot prompting affect AI performance?",
            "a": "The quality and clarity of examples directly impact the AI's performance",
            "opts": [
              "The quality of examples has minimal impact on performance",
              "The quality and clarity of examples directly impact the AI's performance",
              "Only the quantity of examples matters, not quality",
              "AI models ignore example quality"
            ]
          },
          {
            "q": "Which of the following is NOT a key consideration for effective few-shot learning?",
            "a": "Using as many examples as possible to ensure comprehensive coverage",
            "opts": [
              "Using clear, relevant examples",
              "Maintaining consistent formatting",
              "Using as many examples as possible to ensure comprehensive coverage",
              "Providing representative examples"
            ]
          },
          {
            "q": "What is the relationship between the number of examples provided and the quality of AI responses in few-shot learning?",
            "a": "More examples generally lead to more consistent and accurate responses",
            "opts": [
              "More examples always lead to decreased performance",
              "More examples generally lead to more consistent and accurate responses",
              "The number of examples has no impact on quality",
              "Fewer examples always produce better results"
            ]
          },
          {
            "q": "How does few-shot learning differ from zero-shot learning in terms of example provision?",
            "a": "Few-shot learning provides examples in the prompt, while zero-shot learning does not provide any examples",
            "opts": [
              "Few-shot learning provides examples in the prompt, while zero-shot learning does not provide any examples",
              "Few-shot learning uses more computational resources",
              "Zero-shot learning requires examples",
              "There is no difference between the two approaches"
            ]
          }
        ],
        "summary": "In this lesson, we've explored few-shot learning, a powerful technique that uses concrete examples within prompts to guide AI behavior. This approach eliminates the guesswork from AI interactions by showing the AI exactly what you want rather than describing it in abstract terms. By providing clear, relevant examples with consistent formatting, you can significantly improve the AI's ability to produce outputs that match your specific requirements. The key to successful few-shot prompting lies in the quality and representativeness of your examples, the consistency of their formatting, and ensuring they cover the range of scenarios the AI might encounter. This technique is especially valuable for tasks requiring specific formats, structured responses, or complex patterns that are difficult to describe with words alone."
      },
      {
        "id": 8,
        "module": "Intermediate Prompt Techniques",
        "title": "Iterative Refinement and Prompt Chaining",
        "duration": "10-15 min",
        "intro": "In this lesson, we'll explore how to refine prompts through iteration and how to chain multiple prompts together for complex tasks. Iterative refinement involves testing prompts, analyzing the results, and making adjustments to improve output quality. Prompt chaining combines multiple prompts to tackle complex tasks that require multiple steps or different types of processing. These techniques are essential for professional AI use because they allow you to systematically improve your prompts and handle complex requirements that a single prompt cannot address effectively. The iterative approach helps you develop prompts that consistently produce high-quality results, while prompt chaining enables you to break down complex problems into manageable components, each addressed with specialized prompts.",
        "bigIdea": "Prompt engineering is fundamentally an iterative process that systematically improves through testing, analysis, and refinement. Professional prompt engineering is not a one-time activity but rather a continuous cycle of improvement where you test your prompts, analyze the outputs, identify areas for improvement, and refine your approach. This systematic methodology ensures that your prompts consistently produce high-quality, reliable results. Additionally, complex tasks often require chaining multiple specialized prompts together rather than relying on a single complex prompt, allowing for more precise and effective results.",
        "steps": [
          "Start with a basic prompt that addresses your core need and clearly defines the desired output",
          "Test the prompt with diverse sample inputs representing different scenarios you'll encounter",
          "Analyze the output quality, accuracy, and consistency, identifying specific issues and areas for improvement",
          "Refine the prompt based on your analysis, making targeted adjustments to address specific issues",
          "Repeat the test-refine cycle systematically until you achieve consistently high-quality results",
          "For complex tasks, identify opportunities to break them into specialized chained prompts"
        ],
        "example": "For creating a comprehensive market analysis report, you might chain multiple specialized prompts: 1) 'Analyze the provided sales data for Q3 2023 and identify key performance trends, seasonal patterns, and outlier data points' â†’ 2) 'Create an executive summary highlighting the 3 most significant findings from the analysis with specific data points' â†’ 3) 'Generate 5 strategic recommendations based on the analysis and summary, including specific implementation steps' â†’ 4) 'Format the entire report in a professional business format with clear headings, bullet points, and data visualizations mentioned.' Each prompt focuses on a specific aspect of the task with specialized requirements, leading to much higher quality results than trying to accomplish everything in a single complex prompt. This approach allows each step to be optimized for its specific function, resulting in more thorough and accurate outputs.",
        "video": "",
        "reflection": "Consider how iterative refinement and prompt chaining change your approach to solving complex problems with AI. How does this systematic approach compare to other iterative processes you've used in work or projects? Reflect on which types of tasks benefit most from iterative refinement versus prompt chaining, and think about how you can apply these methodologies to your specific use cases.",
        "quiz": [
          {
            "q": "What is the primary benefit of prompt chaining?",
            "a": "It allows complex tasks to be broken into specialized steps",
            "opts": [
              "It makes the AI respond faster",
              "It allows complex tasks to be broken into specialized steps",
              "It reduces the cost of using AI",
              "It makes the AI more creative"
            ]
          },
          {
            "q": "How does the iterative refinement process improve prompt effectiveness?",
            "a": "By testing, analyzing output, identifying issues, and adjusting prompts based on results",
            "opts": [
              "By testing, analyzing output, identifying issues, and adjusting prompts based on results",
              "By making random changes to the prompt",
              "By increasing the length of the prompt",
              "By using more complex vocabulary"
            ]
          },
          {
            "q": "Which of the following is NOT a key component of systematic prompt testing?",
            "a": "Using only one test input to validate the prompt",
            "opts": [
              "Testing prompts with different inputs",
              "Validating results across various scenarios",
              "Using only one test input to validate the prompt",
              "Identifying edge cases"
            ]
          },
          {
            "q": "What is the relationship between prompt complexity and the need for iterative refinement?",
            "a": "More complex prompts typically require more iterations to achieve desired results",
            "opts": [
              "Simple prompts always require more iterations than complex ones",
              "More complex prompts typically require more iterations to achieve desired results",
              "Complexity has no impact on the number of iterations needed",
              "Simple prompts are impossible to refine"
            ]
          },
          {
            "q": "How does prompt chaining differ from using a single complex prompt for multi-step tasks?",
            "a": "Chaining allows specialized processing at each step, often producing higher quality results",
            "opts": [
              "Chaining allows specialized processing at each step, often producing higher quality results",
              "Single prompts are always more efficient",
              "There is no practical difference between the approaches",
              "Single prompts allow for better resource management"
            ]
          }
        ],
        "summary": "In this lesson, we've explored the iterative nature of prompt engineering and the technique of chaining multiple prompts together. These approaches allow you to systematically improve prompt effectiveness and tackle complex tasks that require multiple steps. The iterative refinement process is essential for developing prompts that consistently produce high-quality, reliable results across various inputs and scenarios. Prompt chaining enables you to break down complex requirements into specialized components, each addressed with focused prompts that are optimized for their specific function. Both techniques require a systematic approach and proper testing to be effective. By mastering these methodologies, you can handle increasingly complex AI tasks with greater precision and reliability."
      },
      {
        "id": 9,
        "module": "Advanced Prompt Techniques",
        "title": "Temperature and Creativity Control",
        "duration": "10-15 min",
        "intro": "In this lesson, we'll explore how to control the creativity and randomness of AI responses through temperature settings and prompt techniques. Understanding how to adjust creativity levels is crucial for achieving the right balance between predictable, reliable outputs and innovative, creative responses. This knowledge allows you to fine-tune AI behavior for different types of tasks. The ability to control creativity is fundamental to professional AI use because different tasks have vastly different requirements. Technical documentation needs factual accuracy and consistency, while creative brainstorming requires innovative and varied outputs. Mastering creativity control ensures you get the most appropriate and effective responses for each specific use case, making your AI interactions more valuable and reliable.",
        "bigIdea": "Temperature settings and prompt techniques are powerful tools that allow you to precisely control the balance between creativity and predictability in AI responses. By understanding and applying these controls, you can ensure that the AI generates outputs that match the specific requirements of your task, whether that requires highly creative, innovative responses or factual, predictable outputs. Temperature controls the randomness and exploration in the AI's output, while prompt techniques guide the AI's approach through language and instruction. Mastering both approaches gives you comprehensive control over the AI's creative output.",
        "steps": [
          "Identify the appropriate level of creativity for your task by considering whether you need factual accuracy or innovative ideas",
          "Use temperature settings if available (0.1-0.3 for factual/technical tasks, 0.7-1.0 for creative/ideation tasks)",
          "Use appropriate language in prompts to encourage desired behavior through strategic word choices",
          "Test responses with multiple inputs to ensure they consistently match your requirements",
          "Adjust both temperature and language as needed for optimal results"
        ],
        "example": "For a technical manual requiring factual responses, you might use: 'Provide the standard, proven procedure for changing a tire, using established safety protocols and industry best practices. Include only information that is factually accurate and widely accepted by automotive professionals. Format the response in clear, numbered steps with safety warnings where appropriate.' For creative brainstorming requiring innovative responses, you might use: 'Generate 10 innovative, unconventional marketing approaches for a new eco-friendly product that will surprise customers and create buzz. Think outside the box and explore creative, unexpected strategies that have never been tried before. Consider viral marketing, interactive experiences, and unconventional partnerships. Be creative, bold, and imaginative in your suggestions.' The first prompt uses language that signals the need for factual, conservative responses with terms like 'standard,' 'proven,' 'established,' and 'best practices.' The second prompt uses language that signals the need for creative, innovative thinking with terms like 'innovative,' 'unconventional,' 'think outside the box,' and 'imaginative.' This demonstrates how language choice in prompts can control creativity levels.",
        "video": "",
        "reflection": "Consider how creativity control changes the effectiveness of your AI interactions. Think about the tasks you perform regularly and categorize them as requiring high, medium, or low creativity. Reflect on how using appropriate creativity levels could improve the quality of your AI outputs. Consider the difference between your needs for initial brainstorming versus final documentation, or between creative projects versus technical tasks. How might you adjust your approach to creativity control based on your specific use cases and requirements?",
        "quiz": [
          {
            "q": "What is the primary purpose of controlling creativity in AI responses?",
            "a": "To match the response style to the requirements of the specific task",
            "opts": [
              "To make the AI respond faster",
              "To match the response style to the requirements of the specific task",
              "To reduce the cost of using AI",
              "To make the AI more creative in all cases"
            ]
          },
          {
            "q": "How does temperature setting affect the randomness of AI responses?",
            "a": "Lower temperatures produce more predictable responses, higher temperatures produce more creative responses",
            "opts": [
              "Temperature has no effect on randomness",
              "Lower temperatures produce more predictable responses, higher temperatures produce more creative responses",
              "Higher temperatures make responses more predictable",
              "Temperature only affects response speed"
            ]
          },
          {
            "q": "Which of the following is NOT a method for controlling creativity in AI responses?",
            "a": "Changing the font size in the prompt",
            "opts": [
              "Using temperature settings",
              "Using specific language in prompts",
              "Changing the font size in the prompt",
              "Adjusting system parameters"
            ]
          },
          {
            "q": "What is the relationship between task type and appropriate creativity level?",
            "a": "Technical tasks need low creativity for accuracy, creative tasks benefit from high creativity",
            "opts": [
              "All tasks require the same level of creativity",
              "Technical tasks need low creativity for accuracy, creative tasks benefit from high creativity",
              "Creative tasks should always use low creativity",
              "Creativity level doesn't affect task outcomes"
            ]
          },
          {
            "q": "How do prompt techniques influence AI creativity compared to temperature settings?",
            "a": "Prompt techniques use language to guide behavior while temperature controls randomness",
            "opts": [
              "Prompt techniques use language to guide behavior while temperature controls randomness",
              "Prompt techniques are more effective than temperature settings",
              "Temperature settings are more effective than prompt techniques",
              "There is no difference between the two approaches"
            ]
          }
        ],
        "summary": "In this lesson, we've explored how to control creativity and randomness in AI responses through both temperature settings and strategic prompt techniques. By understanding how temperature affects the randomness of AI outputs and how language in prompts can guide creative behavior, you can fine-tune AI behavior to match the specific requirements of your tasks. The key is recognizing that different tasks require different levels of creativity - technical tasks need low creativity for accuracy and reliability, while creative tasks benefit from high creativity for innovation and originality. Mastering both temperature controls and language-based creativity techniques gives you comprehensive control over the AI's output style, allowing you to get the most appropriate and effective responses for each specific use case. This skill is fundamental to professional AI use, ensuring you consistently get outputs that match your requirements."
      },
      {
        "id": 10,
        "module": "Advanced Prompt Techniques",
        "title": "Zero-Shot and Self-Consistency Techniques",
        "duration": "10-15 min",
        "intro": "In this lesson, we'll explore zero-shot prompting and self-consistency techniques, two advanced methods that expand your prompt engineering capabilities. Zero-shot prompting involves getting AI to perform tasks without providing examples, relying solely on clear instructions, comprehensive context, and well-defined role expectations. This technique is particularly valuable when you need quick results without the time investment of creating examples. Self-consistency techniques involve generating multiple responses to the same prompt and comparing them to identify the most consistent or highest quality answer. This approach is especially useful for tasks requiring factual accuracy or when you want to increase confidence in the AI's response. These advanced techniques can significantly improve the reliability and accuracy of AI outputs, giving you more tools to handle different scenarios effectively.",
        "bigIdea": "Zero-shot prompting and self-consistency are powerful advanced techniques that significantly enhance the reliability and accuracy of AI responses. Zero-shot prompting allows you to get quality results without providing examples by relying on clear instructions and comprehensive context, making it efficient for quick tasks. Self-consistency techniques increase confidence in AI outputs by generating multiple responses and identifying the most consistent or accurate answer. These methods expand your prompt engineering toolkit and provide solutions for scenarios where traditional approaches might be less effective.",
        "steps": [
          "For zero-shot: Ensure instructions are comprehensive, detailed, and leave no room for ambiguity",
          "Provide sufficient context that covers all background information the AI needs",
          "Define the specific role or expertise level required for the task",
          "Specify the exact desired output format, structure, and requirements",
          "For self-consistency: Generate 3-5 responses to the same prompt",
          "Compare responses systematically to identify consistent elements and recurring information",
          "Select the most accurate or consistent answer based on frequency and quality"
        ],
        "example": "For zero-shot prompting in a business context: 'You are an expert financial analyst with 15 years of experience in small business lending. Analyze the implications of a 2% increase in interest rates on small business loans. Consider the impact on cash flow for businesses with different revenue levels, effects on expansion plans for growing companies, and how investment decisions might change. Include specific examples of how businesses in different sectors might be affected. Format your response as a 3-point analysis with specific, actionable recommendations for businesses to mitigate negative impacts. Use professional, authoritative language suitable for a C-suite presentation.' For self-consistency: You would run this same prompt 5 times, then compare the responses to identify which specific recommendations, examples, and impacts appear most frequently across the responses. The most commonly mentioned points are likely to be the most accurate and reliable. This approach helps ensure that your analysis is based on the AI's most confident responses rather than a single potentially flawed generation.",
        "video": "",
        "reflection": "Consider the scenarios where each technique would be most appropriate. When might zero-shot prompting be more efficient or effective than few-shot prompting? Think about situations where creating examples would be time-consuming, where the task is well-defined and clear, or where you need quick results. Conversely, when might few-shot prompting be better? Also consider when you would use self-consistency techniques and how this approach could increase your confidence in AI outputs. Think about your own use cases and how these advanced techniques could improve your results.",
        "quiz": [
          {
            "q": "What is zero-shot prompting?",
            "a": "Prompting without providing examples",
            "opts": [
              "Prompting without providing examples",
              "Prompting with many examples",
              "Prompting that makes the AI respond quickly",
              "Prompting that reduces AI creativity"
            ]
          },
          {
            "q": "How does self-consistency technique improve AI response accuracy?",
            "a": "By generating multiple responses and selecting the most consistent answer",
            "opts": [
              "By using more computational resources",
              "By generating multiple responses and selecting the most consistent answer",
              "By reducing response length",
              "By limiting the AI's vocabulary"
            ]
          },
          {
            "q": "Which of the following is NOT a requirement for effective zero-shot prompting?",
            "a": "Providing multiple examples for reference",
            "opts": [
              "Clear instructions",
              "Sufficient context",
              "Providing multiple examples for reference",
              "Well-defined output format"
            ]
          },
          {
            "q": "What is the relationship between instruction clarity and zero-shot prompting success?",
            "a": "Clear, comprehensive instructions are crucial for success",
            "opts": [
              "Clarity has no impact on success",
              "Clear, comprehensive instructions are crucial for success",
              "Complex instructions work better than clear ones",
              "Instruction clarity only matters for creative tasks"
            ]
          },
          {
            "q": "How do zero-shot and few-shot prompting differ in their approach to examples?",
            "a": "Zero-shot uses no examples while few-shot provides examples",
            "opts": [
              "Zero-shot uses no examples while few-shot provides examples",
              "Zero-shot is always more effective than few-shot",
              "There is no practical difference between the two",
              "Few-shot uses no examples while zero-shot provides examples"
            ]
          }
        ],
        "summary": "In this lesson, we've explored zero-shot prompting and self-consistency techniques, two advanced methods that significantly expand your prompt engineering capabilities. Zero-shot prompting allows you to get quality results without providing examples by relying on clear, comprehensive instructions and well-defined context. This technique is particularly valuable when you need quick results or when creating examples would be time-consuming. Self-consistency techniques increase confidence in AI outputs by generating multiple responses to the same prompt and identifying the most consistent or accurate answers. This approach is especially useful for factual tasks where accuracy is critical. Both techniques address different challenges: zero-shot for efficiency when examples aren't practical, and self-consistency for accuracy when you need to verify information. These methods enhance your ability to handle a wider range of challenges with greater confidence in the results, making them valuable additions to your prompt engineering toolkit."
      },
      {
        "id": 11,
        "module": "Specialized Applications",
        "title": "Prompt Engineering for Content Creation",
        "duration": "10-15 min",
        "intro": "In this lesson, we'll explore specialized prompt engineering techniques for content creation across various formats and platforms. Content creation is one of the most common applications of AI, and mastering prompt techniques for this domain can significantly improve the quality, relevance, and engagement of AI-generated content. Effective content creation prompts must consider multiple factors: the specific platform's requirements, the target audience's preferences and behaviors, the content format, and the desired engagement outcomes. We'll cover techniques for different content types, platforms, and audiences, helping you create prompts that generate content that not only meets technical requirements but also resonates with your intended audience and achieves your content objectives. This lesson will provide you with the tools to create highly targeted, platform-specific content that performs well across different channels and connects with your audience effectively.",
        "bigIdea": "Specialized prompt techniques for content creation can significantly improve the quality, relevance, and engagement of AI-generated content by addressing platform-specific requirements, audience preferences, and content format needs. Effective content creation prompts must consider multiple dimensions simultaneously: the unique characteristics and requirements of each platform, the specific preferences and behaviors of the target audience, and the structural requirements of different content formats. By incorporating these specialized techniques into your prompts, you can generate content that not only meets technical specifications but also resonates with your audience and achieves your content marketing objectives. This multi-dimensional approach to content creation prompts ensures that your AI-generated content performs effectively across different channels and connects meaningfully with your intended audience.",
        "steps": [
          "Identify the specific platform and understand its unique requirements, culture, and optimal content characteristics",
          "Define your target audience with specific demographic, psychographic, and behavioral details",
          "Specify the content format with structural requirements and organizational expectations",
          "Include platform-specific engagement elements like hashtags, calls-to-action, or interactive components",
          "Test your content and refine based on actual performance and engagement metrics"
        ],
        "example": "Instead of the generic 'Write a social media post,' a much more effective prompt would be: 'Write a LinkedIn post for marketing professionals with 3-7 years of experience about the importance of data-driven marketing decisions in the current economic climate. Include a compelling hook that addresses a common challenge, 2 specific, actionable insights with brief explanations, and a thought-provoking question to encourage engagement from your network. Use a professional but approachable tone that demonstrates expertise without being overly technical. Structure the post with a clear introduction, two main points with supporting details, and a conclusion that reinforces the main message. Keep the length between 150-200 words to maintain engagement. Include 2-3 relevant hashtags like #DataDrivenMarketing #MarketingStrategy #DigitalMarketing. This detailed prompt generates content that's specifically tailored to the platform's culture, the audience's experience level, and the desired format, resulting in content that's much more likely to resonate and generate meaningful engagement. The same principle applies when creating content for other platforms - each needs its own specific approach and requirements included in the prompt.",
        "video": "",
        "reflection": "Consider how platform-specific requirements affect your content creation approach. Think about the different audiences, formats, and engagement patterns on various platforms you use. How would you modify your prompts for platforms like Twitter, LinkedIn, Instagram, YouTube, or a blog? What specific elements would you include in prompts for each platform? Also consider how audience segmentation affects your prompts - how would you modify your approach for different audience segments like beginners versus experts, B2B versus B2C, or different age groups? Reflect on how content format requirements influence your prompts and how you might approach different formats like listicles, how-to guides, or storytelling.",
        "quiz": [
          {
            "q": "Why is it important to specify the target audience in content creation prompts?",
            "a": "It helps the AI create content that resonates with the intended audience",
            "opts": [
              "It makes the AI respond faster",
              "It helps the AI create content that resonates with the intended audience",
              "It reduces the cost of using AI",
              "It makes the AI more creative"
            ]
          },
          {
            "q": "How does platform-specific prompting improve content effectiveness?",
            "a": "By tailoring content to platform-specific requirements and audience expectations",
            "opts": [
              "By making the AI respond faster",
              "By tailoring content to platform-specific requirements and audience expectations",
              "By reducing the cost of content creation",
              "By making the content more creative"
            ]
          },
          {
            "q": "Which of the following is NOT a core concept in content creation prompt engineering?",
            "a": "Using generic language for all platforms",
            "opts": [
              "Platform-specific content approaches",
              "Audience segmentation techniques",
              "Using generic language for all platforms",
              "Content format specifications"
            ]
          },
          {
            "q": "What is the relationship between content format specification and output quality?",
            "a": "Specifying format requirements leads to better structured and more relevant content",
            "opts": [
              "Format specification has no impact on output quality",
              "Specifying format requirements leads to better structured and more relevant content",
              "Generic formats produce higher quality content",
              "Format requirements limit creativity"
            ]
          },
          {
            "q": "How do detailed prompts compare to generic prompts in content creation?",
            "a": "Detailed prompts produce more relevant and targeted content than generic prompts",
            "opts": [
              "Detailed prompts produce more relevant and targeted content than generic prompts",
              "Generic prompts are always more effective",
              "Detailed prompts reduce content quality",
              "There is no difference between detailed and generic prompts"
            ]
          }
        ],
        "summary": "In this lesson, we've explored specialized prompt engineering techniques for content creation that address the multi-dimensional requirements of effective content. By tailoring prompts to specific platforms, audiences, and formats, you can significantly improve the quality, relevance, and effectiveness of AI-generated content. Platform-specific prompts account for each channel's unique culture, optimal content length, and engagement patterns, ensuring your content performs well within each platform's algorithm. Detailed audience segmentation in your prompts helps create content that resonates with specific groups by addressing their unique needs, preferences, and communication styles. Format-specific requirements ensure your content has the appropriate structure and flow for different types of content. The combination of these specialized techniques in your prompts results in AI-generated content that not only meets technical specifications but also connects meaningfully with your intended audience, leading to higher engagement, better reach, and more effective content marketing outcomes. Mastering these specialized techniques allows you to scale your content creation efforts while maintaining high quality and relevance across all your channels."
      },
      {
        "id": 12,
        "module": "Specialized Applications",
        "title": "Prompt Engineering for Code Generation",
        "duration": "10-15 min",
        "intro": "In this lesson, we'll explore specialized prompt engineering techniques for code generation, an increasingly important application of AI in software development. Coding with AI assistance is revolutionizing how developers work, but effective prompts are essential to generate code that is not only functional but also efficient, maintainable, and secure. AI-assisted coding can significantly accelerate development, reduce debugging time, and help with learning new technologies, but it requires precise prompts to produce correct, efficient, and maintainable code. We'll cover techniques for different programming languages, frameworks, and development scenarios, focusing on how to craft prompts that generate code meeting professional standards. The key to successful AI-assisted coding lies in providing clear, comprehensive instructions that specify not just what the code should do, but also how it should be structured, documented, and optimized for your specific requirements.",
        "bigIdea": "Specialized prompt techniques for code generation can significantly improve the quality, correctness, efficiency, and maintainability of AI-generated code. Effective coding prompts must address multiple dimensions simultaneously: specifying the exact programming language and framework, clearly defining functionality requirements, outlining quality standards, and including considerations for security, performance, and maintainability. By incorporating these specialized techniques into your prompts, you can generate code that not only meets functional requirements but also adheres to professional development standards. This multi-dimensional approach ensures that AI-generated code integrates seamlessly into existing projects, follows best practices, and can be maintained by other developers. The precision in your prompts directly correlates to the quality of the generated code, making specialized techniques essential for professional development.",
        "steps": [
          "Specify the exact programming language, version, and relevant frameworks or libraries",
          "Define the precise functionality needed with detailed input/output specifications",
          "Include comprehensive requirements for error handling, edge cases, and constraints",
          "Specify style, quality, and performance requirements including documentation standards",
          "Test the generated code thoroughly to ensure it meets all requirements and functions correctly"
        ],
        "example": "Instead of the generic 'Write a function to sort data,' a much more effective prompt would be: 'Write a Python function named bubble_sort that takes a list of integers and returns the sorted list in ascending order. The function should handle edge cases including empty lists, single-item lists, and lists with duplicate values. Include comprehensive error handling for non-list inputs, non-integer elements, and None values. Add detailed docstrings following PEP 257 conventions, include inline comments explaining the sorting algorithm's logic, and ensure the function is efficient for small to medium datasets. Follow PEP 8 style guidelines for naming conventions and formatting. The function should not modify the original list but return a new sorted list. Include type hints for all parameters and return values.' This comprehensive prompt specifies language, functionality, error handling, documentation requirements, code quality standards, and behavioral expectations. The same principle applies to other programming tasks - the more specific and comprehensive your requirements, the better the AI-generated code will meet your professional standards.",
        "video": "",
        "reflection": "Consider how detailed requirements change the quality of AI-generated code. How do language-specific requirements affect the code's correctness and adherence to conventions? Think about how specifying error handling, edge cases, and quality standards influences the robustness of the generated code. Reflect on the importance of documentation requirements and how they affect maintainability. Consider how different types of projects might require different levels of detail in coding prompts - for example, a prototype versus production code, or a simple script versus a component in a large application. Think about how you might adapt your prompting approach based on the specific requirements of your projects and the standards of your development team.",
        "quiz": [
          {
            "q": "What is the primary benefit of specifying programming language in code generation prompts?",
            "a": "It ensures the AI generates code in the correct syntax and style",
            "opts": [
              "It makes the AI respond faster",
              "It ensures the AI generates code in the correct syntax and style",
              "It reduces the cost of using AI",
              "It makes the AI more creative"
            ]
          },
          {
            "q": "How do clear functionality requirements improve code generation quality?",
            "a": "By providing clear specifications of what the code should do, including inputs, outputs, and constraints",
            "opts": [
              "By making the AI respond faster",
              "By providing clear specifications of what the code should do, including inputs, outputs, and constraints",
              "By reducing the complexity of the code",
              "By making the code shorter"
            ]
          },
          {
            "q": "Which of the following is NOT a core concept in code generation prompt engineering?",
            "a": "Avoiding specific language requirements",
            "opts": [
              "Language-specific prompts",
              "Functionality requirements",
              "Avoiding specific language requirements",
              "Code quality considerations"
            ]
          },
          {
            "q": "What is the relationship between code quality requirements and generated code quality?",
            "a": "Specifying quality requirements helps generate code that follows best practices",
            "opts": [
              "Quality requirements have no impact on generated code",
              "Specifying quality requirements helps generate code that follows best practices",
              "Quality requirements reduce code performance",
              "Quality requirements make code less readable"
            ]
          },
          {
            "q": "How do detailed coding prompts compare to generic coding prompts?",
            "a": "Detailed prompts produce more accurate and appropriate code than generic prompts",
            "opts": [
              "Detailed prompts produce more accurate and appropriate code than generic prompts",
              "Generic prompts are always more effective",
              "Detailed prompts reduce code quality",
              "There is no difference between detailed and generic prompts"
            ]
          }
        ],
        "summary": "In this lesson, we've explored specialized prompt engineering techniques for code generation that address the multi-dimensional requirements of professional software development. By providing clear language specifications, detailed functionality requirements, and comprehensive quality expectations, you can significantly improve the quality, correctness, and maintainability of AI-generated code. Language-specific prompts ensure the code follows proper syntax, conventions, and idioms for the target programming language. Detailed functionality requirements help generate code that handles all expected use cases, including edge cases and error conditions. Quality-focused specifications ensure the code includes proper documentation, error handling, and follows best practices for maintainability and security. The combination of these specialized techniques in your prompts results in AI-generated code that not only functions correctly but also meets professional development standards, integrates well with existing systems, and can be maintained by other developers. Mastering these specialized techniques allows you to leverage AI as a powerful tool for accelerating development while maintaining high code quality and reducing time spent on routine coding tasks."
      },
      {
        "id": 13,
        "module": "Specialized Applications",
        "title": "Prompt Engineering for Data Analysis",
        "duration": "10-15 min",
        "intro": "In this lesson, we'll explore specialized prompt engineering techniques for data analysis tasks, an increasingly critical application as organizations become more data-driven in their decision-making processes. AI-powered data analysis can significantly accelerate insights, identify complex patterns that might be missed by human analysis, and perform calculations that would be time-consuming to do manually. However, effective data analysis with AI requires carefully crafted prompts that provide sufficient context, clear objectives, and specific requirements. We'll cover techniques for asking AI to interpret data, identify patterns, perform calculations, and generate actionable insights from datasets. The key to successful AI-assisted data analysis lies in providing comprehensive instructions that help the AI understand not just what to analyze, but why it's important, what specific insights you're looking for, and how you plan to use the results. This approach transforms raw data into meaningful, actionable intelligence that can drive business decisions and strategic planning.",
        "bigIdea": "Specialized prompts for data analysis can effectively guide AI systems to analyze data and generate meaningful, actionable insights by providing comprehensive context, specific analytical objectives, and clear output requirements. Effective data analysis prompts must address multiple dimensions: the nature and structure of the data being analyzed, the specific business or research context, the particular questions that need to be answered, and the format in which insights should be presented. By incorporating these specialized techniques into your prompts, you can transform raw data into meaningful intelligence that drives decision-making. This multi-dimensional approach ensures that AI-generated insights are not only statistically accurate but also relevant to your specific needs and presented in a format that's actionable for your stakeholders. The precision in your prompts directly correlates to the relevance and actionability of the generated insights, making specialized techniques essential for effective data analysis.",
        "steps": [
          "Provide comprehensive context about the dataset including field definitions, time periods, and business or research significance",
          "Define specific analysis objectives with clear business questions that need to be answered",
          "Specify the exact type of insights needed with relevance to decision-making context",
          "Request specific calculations, metrics, or statistical measures to be included",
          "Define the required output format tailored to the intended audience and use case"
        ],
        "example": "Instead of the generic 'Analyze this sales data,' a much more effective prompt would be: 'Analyze the quarterly sales data for 2023 for our e-commerce company that sells consumer electronics. The data includes customer demographics, product categories, sales volumes, and regional performance. Focus on identifying seasonal trends that could inform inventory planning for 2024, top-performing product categories and SKUs, customer segments with declining sales that require attention, and regional performance differences. Provide insights in a 5-point executive summary with specific, actionable recommendations for each point. Include percentage changes year-over-year, statistical significance indicators, and highlight any anomalies or unexpected patterns. Use business language appropriate for a leadership presentation and include confidence levels for predictions. This comprehensive prompt provides detailed context about the data source and business, specifies clear analytical objectives, and defines the exact output format needed. The same principle applies to other data analysis tasks - the more specific and comprehensive your requirements, the more actionable the AI-generated insights will be.",
        "video": "",
        "reflection": "Consider how context and specific requirements change the quality of AI-generated insights. How does providing detailed context about the data source, business relevance, and analytical objectives affect the relevance of the insights? Think about how specifying the intended use of insights influences how the AI frames its findings. Reflect on the importance of output requirements and how they affect the actionability of the results. Consider how different types of data analysis might require different levels of detail in your prompts - for example, exploratory analysis versus focused performance evaluation. Think about how you might adapt your prompting approach based on the specific requirements of your data analysis projects and the needs of your stakeholders.",
        "quiz": [
          {
            "q": "Why is it important to provide context about a dataset in analysis prompts?",
            "a": "It helps the AI understand the significance and provide relevant insights",
            "opts": [
              "It makes the AI respond faster",
              "It helps the AI understand the significance and provide relevant insights",
              "It reduces the cost of using AI",
              "It makes the AI more creative"
            ]
          },
          {
            "q": "How do clear analysis objectives improve the quality of AI-generated insights?",
            "a": "By guiding the AI to focus on the most relevant aspects of the data",
            "opts": [
              "By making the AI respond faster",
              "By guiding the AI to focus on the most relevant aspects of the data",
              "By reducing the amount of data to process",
              "By making the analysis simpler"
            ]
          },
          {
            "q": "Which of the following is NOT a core concept in data analysis prompt engineering?",
            "a": "Avoiding specific objectives",
            "opts": [
              "Data context setting",
              "Analysis objectives",
              "Avoiding specific objectives",
              "Output requirements"
            ]
          },
          {
            "q": "What is the relationship between output specifications and analysis usability?",
            "a": "Specifying output format ensures results are in a usable format for the user",
            "opts": [
              "Output specifications have no impact on usability",
              "Specifying output format ensures results are in a usable format for the user",
              "Output specifications reduce analysis quality",
              "Specifying format makes results less relevant"
            ]
          },
          {
            "q": "How do structured prompts compare to general prompts in data analysis?",
            "a": "Structured prompts produce more relevant and actionable insights than general prompts",
            "opts": [
              "Structured prompts produce more relevant and actionable insights than general prompts",
              "General prompts are always more effective",
              "Structured prompts reduce analysis quality",
              "There is no difference between structured and general prompts"
            ]
          }
        ],
        "summary": "In this lesson, we've explored specialized prompt engineering techniques for data analysis that address the multi-dimensional requirements of effective data analysis. By providing comprehensive context about the data, specific analytical objectives, and detailed output requirements, you can significantly improve the quality, relevance, and actionability of AI-generated data insights. Context-setting ensures the AI understands the business or research significance of the data, leading to more relevant analysis. Clear objectives focus the AI's analytical efforts on the most important aspects of the data based on your specific needs. Detailed output specifications ensure the results are presented in a format that's immediately useful for decision-making. The combination of these specialized techniques in your prompts results in AI-generated insights that are not only statistically accurate but also relevant to your specific needs and presented in a format that's actionable for your stakeholders. Mastering these specialized techniques allows you to leverage AI as a powerful tool for extracting meaningful intelligence from your data assets, transforming raw data into actionable insights that can drive business decisions and strategic planning."
      },
      {
        "id": 14,
        "module": "Troubleshooting and Best Practices",
        "title": "Common Prompt Engineering Mistakes and How to Avoid Them",
        "duration": "10-15 min",
        "intro": "In this lesson, we'll examine common mistakes in prompt engineering and learn how to avoid them, which is fundamental to becoming a proficient and effective prompt engineer. Understanding these pitfalls is crucial for developing prompts that consistently produce high-quality results with AI systems. Even experienced prompt engineers make mistakes, but recognizing and avoiding these common errors significantly improves the effectiveness of your interactions with AI systems. We'll explore the most frequent errors, their causes, their impacts, and their solutions, providing you with practical strategies to enhance your prompt engineering skills. This lesson focuses on identifying patterns of ineffective prompting and replacing them with proven techniques that lead to more reliable and effective results. By understanding these common mistakes, you'll be better equipped to create prompts that consistently produce the results you're looking for, saving time and improving the quality of your AI interactions.",
        "bigIdea": "Recognizing and systematically avoiding common prompt engineering mistakes leads to more effective, reliable, and consistent AI interactions. Understanding these common pitfalls enables you to craft prompts that consistently produce high-quality results by eliminating sources of ambiguity, confusion, and misdirection that can cause AI systems to generate irrelevant or inaccurate outputs. This awareness helps you anticipate potential issues before they occur and apply proven techniques to prevent them. The most effective prompt engineers develop a mental checklist of common mistakes and apply this knowledge proactively when crafting prompts, resulting in more predictable and useful AI responses. By internalizing these common mistakes and their solutions, you develop an intuitive sense for potential issues and can create prompts that are robust, clear, and effective across different scenarios and use cases.",
        "steps": [
          "Review your prompt systematically for ambiguous language and unclear terms",
          "Ensure sufficient context is provided for the AI to understand the task completely",
          "Check that the prompt is focused, clear, and not overly complex",
          "Test the prompt with various sample inputs to identify potential issues",
          "Refine based on results and apply lessons to future prompts"
        ],
        "example": "A common mistake would be a prompt like 'Tell me about marketing,' which is ambiguous, lacks context, and doesn't specify the output format. A much better approach would be: 'Explain the key components of a digital marketing strategy for a B2B software company targeting enterprise clients with annual revenue over $10M. Include discussion of content marketing for thought leadership, social media for engagement, and account-based marketing for high-value prospects. Address the unique challenges of selling to IT decision-makers and procurement teams. Format as a 3-point summary with brief explanations of each component, and include one specific recommendation for each component that could be implemented in the next 30 days. Use business language appropriate for a C-suite presentation.' This improved prompt addresses multiple common mistakes: it eliminates ambiguity by specifying the exact context and requirements, provides sufficient context about the company type, target audience, and challenges, and clearly defines the output format. The same principles apply to other types of prompts - always check for ambiguity, missing context, and unnecessary complexity.",
        "video": "",
        "reflection": "Consider how recognizing common mistakes changes your approach to prompt engineering. How might you change your prompt creation process to systematically check for these mistakes? Think about how you could develop a review checklist that includes checking for ambiguous language, missing context, and unnecessary complexity. Reflect on prompts you've created in the past and identify which of these common mistakes they might have contained. Consider how this awareness will influence your future prompt creation, and think about how you might apply these principles to different types of tasks and applications. Think about how you could develop a systematic approach to reviewing and improving your prompts.",
        "quiz": [
          {
            "q": "What is a common mistake in prompt engineering?",
            "a": "Using ambiguous or unclear language",
            "opts": [
              "Providing too much context",
              "Using ambiguous or unclear language",
              "Being too specific",
              "Using simple language"
            ]
          },
          {
            "q": "How does ambiguous language affect AI response quality?",
            "a": "It leads to varied interpretations and inconsistent results",
            "opts": [
              "It has no effect on responses",
              "It leads to varied interpretations and inconsistent results",
              "It makes responses more consistent",
              "It speeds up response time"
            ]
          },
          {
            "q": "Which of the following is NOT a common prompt engineering mistake?",
            "a": "Providing sufficient context",
            "opts": [
              "Using ambiguous language",
              "Missing context",
              "Providing sufficient context",
              "Overly complex prompts"
            ]
          },
          {
            "q": "What is the relationship between prompt complexity and response quality?",
            "a": "Overly complex prompts can confuse the AI and reduce response quality",
            "opts": [
              "Simple prompts always produce better results",
              "Overly complex prompts can confuse the AI and reduce response quality",
              "Complexity has no impact on quality",
              "More complex prompts always produce better results"
            ]
          },
          {
            "q": "How do best practices in prompt engineering improve results?",
            "a": "By helping avoid common pitfalls and creating more effective prompts",
            "opts": [
              "By helping avoid common pitfalls and creating more effective prompts",
              "By making prompts more complex",
              "By reducing the need for testing",
              "By making responses less accurate"
            ]
          }
        ],
        "summary": "In this lesson, we've examined common prompt engineering mistakes and how to avoid them, which is fundamental to becoming a proficient prompt engineer. By recognizing these pitfalls and applying best practices, you can create more effective prompts that consistently produce high-quality results. Understanding how to avoid ambiguous language ensures the AI interprets your instructions correctly, while providing sufficient context helps the AI generate relevant and appropriate responses. Keeping prompts clear and focused prevents confusion and ensures the AI understands your primary objectives. Testing your prompts systematically allows you to identify and fix issues before deployment. The most effective prompt engineers develop a systematic approach to reviewing their prompts for common mistakes, applying these principles proactively to create robust, effective prompts. By internalizing these common mistakes and their solutions, you'll develop an intuitive sense for potential issues and create prompts that are reliable, clear, and effective across different scenarios and use cases. Mastering the identification and avoidance of these common mistakes significantly accelerates your development as a proficient prompt engineer."
      },
      {
        "id": 15,
        "module": "Troubleshooting and Best Practices",
        "title": "Testing and Validating Prompts",
        "duration": "10-15 min",
        "intro": "In this lesson, we'll explore systematic approaches to testing and validating prompts to ensure they work reliably across different scenarios, which is a critical component of professional prompt engineering. Testing is not just a one-time activity but an ongoing process that ensures your prompts maintain consistency and reliability across various inputs, contexts, and changing requirements. Without proper testing, prompts may work well in ideal conditions but fail when presented with unexpected inputs or edge cases. Systematic testing helps identify potential failures before they occur in production use, leading to more robust and reliable prompt performance. We'll cover various testing strategies and validation techniques, including edge case testing, consistency validation, and performance evaluation, to help you create prompts that perform well across diverse situations. This lesson emphasizes the importance of developing a comprehensive testing approach that covers typical use cases, edge cases, and failure scenarios to ensure your prompts are robust and reliable for professional use.",
        "bigIdea": "Systematic testing and validation are essential practices that ensure prompts work reliably across different inputs, scenarios, and contexts. Effective prompt testing involves multiple layers: verifying functionality with typical use cases, validating robustness with edge cases, and ensuring consistency across multiple executions. This systematic approach helps identify potential failures before they occur in production, leading to more robust and reliable prompt performance. Professional prompt engineering requires a comprehensive testing methodology that includes testing for accuracy, consistency, reliability, and appropriate responses across the full range of expected inputs. By implementing systematic testing and validation processes, you can create prompts that maintain their effectiveness over time and under varying conditions, ensuring they consistently produce high-quality results in real-world applications.",
        "steps": [
          "Identify and document typical use cases that represent normal operating conditions",
          "Create comprehensive test cases for edge cases and unusual scenarios",
          "Test the prompt multiple times with identical inputs to validate consistency",
          "Evaluate the quality, accuracy, and appropriateness of all responses",
          "Document issues and refine the prompt based on comprehensive test results"
        ],
        "example": "For a customer service prompt designed to handle technical support inquiries, comprehensive testing would involve multiple dimensions. For edge case testing, you would test with extremely angry customers ('I've lost all my data and my business is ruined!'), customers with incomplete information ('My computer broke'), complex technical questions ('Our SQL database is experiencing performance issues during peak hours'), and conflicting requests ('I need to access my account but I've forgotten my password and can't access my email'). For consistency validation, you would run the same inquiry multiple times to ensure the prompt generates responses with consistent tone, quality, and accuracy. For performance testing, you would evaluate how the prompt handles various types of inquiries including standard requests, complex multi-part questions, requests in different languages or formats, and unusually long or short inquiries. Additionally, you would test the prompt's ability to handle requests with missing information, contradictory information, or requests that fall outside the scope of support. This comprehensive testing approach ensures the prompt performs reliably across all expected scenarios and maintains quality under various conditions.",
        "video": "",
        "reflection": "Consider how systematic testing changes your approach to prompt engineering. How might you integrate testing into your regular prompt development workflow? Think about how you could develop a systematic testing protocol that includes edge case testing, consistency validation, and performance evaluation. Reflect on how testing might change how you design your prompts from the beginning, and consider what types of prompts might require more extensive testing. Think about how you might document your testing results and use them to improve future prompts. Consider how you could create a testing framework that you could apply to different types of prompts and applications.",
        "quiz": [
          {
            "q": "Why is testing important in prompt engineering?",
            "a": "It ensures prompts work reliably across different inputs and scenarios",
            "opts": [
              "It makes the AI respond faster",
              "It ensures prompts work reliably across different inputs and scenarios",
              "It reduces the cost of using AI",
              "It makes the AI more creative"
            ]
          },
          {
            "q": "How does edge case testing improve prompt reliability?",
            "a": "By identifying potential failures with unusual or extreme inputs",
            "opts": [
              "By making prompts respond faster",
              "By identifying potential failures with unusual or extreme inputs",
              "By reducing the complexity of prompts",
              "By making prompts more creative"
            ]
          },
          {
            "q": "Which of the following is NOT a core component of prompt validation?",
            "a": "Avoiding edge case testing",
            "opts": [
              "Edge case testing",
              "Consistency validation",
              "Avoiding edge case testing",
              "Performance testing"
            ]
          },
          {
            "q": "What is the relationship between consistency validation and reliable prompt performance?",
            "a": "Consistency validation ensures prompts produce reproducible outputs",
            "opts": [
              "There is no relationship between them",
              "Consistency validation ensures prompts produce reproducible outputs",
              "Consistency validation reduces performance",
              "Reliable performance eliminates the need for consistency validation"
            ]
          },
          {
            "q": "How do systematic testing approaches compare to ad-hoc testing?",
            "a": "Systematic testing is more thorough and reliable than ad-hoc testing",
            "opts": [
              "Systematic testing is more thorough and reliable than ad-hoc testing",
              "Ad-hoc testing is always more effective",
              "There is no difference between the approaches",
              "Systematic testing is less effective than ad-hoc testing"
            ]
          }
        ],
        "summary": "In this lesson, we've explored systematic approaches to testing and validating prompts, which is essential for professional prompt engineering. By thoroughly testing prompts across different scenarios, inputs, and conditions, you can ensure they work reliably and consistently produce high-quality results. Edge case testing helps identify potential failures before they occur in production, consistency validation ensures prompts produce reproducible results, and performance testing validates effectiveness across all anticipated use cases. Systematic testing is not a one-time activity but an ongoing process that validates prompts continue to meet quality standards over time. This comprehensive approach to testing and validation helps create robust, reliable prompts that maintain their effectiveness across various contexts and inputs. By implementing these systematic testing approaches, you can have confidence that your prompts will perform reliably in production environments, reducing the risk of failures and ensuring consistent, high-quality results in real-world applications. Testing is a critical investment that prevents problems and ensures the long-term effectiveness of your prompt engineering efforts."
      },
      {
        "id": 16,
        "module": "Course Conclusion",
        "title": "Putting It All Together: Advanced Prompt Engineering Projects",
        "duration": "10-15 min",
        "intro": "In this final lesson, we'll synthesize all the concepts learned throughout the course by exploring advanced prompt engineering projects that represent the pinnacle of professional prompt engineering practice. You'll learn how to combine multiple techniques effectively, approach complex multi-dimensional challenges, and develop sophisticated prompts that solve real-world problems. This lesson serves as a comprehensive capstone that brings together all the skills, knowledge, and best practices you've gained throughout the course, demonstrating how to apply them in advanced applications. Advanced prompt engineering projects require a deep understanding of multiple techniques and the ability to strategically combine them to address challenges that cannot be solved with single approaches. You'll learn how to architect complex prompt systems, manage multi-step processes, and create integrated solutions that leverage the strengths of different techniques. This lesson will prepare you to tackle sophisticated challenges that require combining multiple approaches, iterative refinement, and systematic integration of different prompt engineering methodologies. By the end of this lesson, you'll understand how to approach complex challenges with confidence and create advanced prompts that deliver professional-quality results.",
        "bigIdea": "Advanced prompt engineering involves strategically combining multiple techniques to solve complex, multi-dimensional challenges and achieve sophisticated results that cannot be obtained through single approaches. The most powerful prompt engineering applications require the synthesis of various techniques, each contributing its unique strengths to address different aspects of complex challenges. This synthesis involves understanding when and how to combine techniques like few-shot learning, chain of thought reasoning, role assignment, context setting, and constraint definition to create comprehensive solutions. Advanced prompt engineering also involves understanding the interactions between different techniques and how they can complement each other to produce more effective results than any single technique alone. Professional-level prompt engineering requires the ability to architect complex prompt systems that leverage the strengths of multiple methodologies while mitigating their individual limitations. The most sophisticated applications of AI through prompt engineering involve creating integrated systems where multiple techniques work together to address complex, real-world challenges that require nuanced, multi-faceted solutions.",
        "steps": [
          "Identify the overall objective and comprehensive requirements for the advanced project",
          "Break the challenge into smaller, specialized, and manageable components",
          "Select and synthesize appropriate prompt techniques for each component",
          "Develop, test, and validate individual prompts systematically",
          "Integrate the components into a complete, cohesive solution",
          "Refine the overall approach iteratively based on comprehensive results"
        ],
        "example": "A comprehensive business strategy development project would exemplify advanced prompt engineering synthesis. For market analysis: A data analysis prompt might combine few-shot learning with examples of market analysis reports, chain of thought reasoning to guide the analytical process, and role assignment to have the AI act as a senior market analyst. For strategy generation: A creative brainstorming prompt might integrate role assignment (innovation consultant), constraint definition (budget and timeline limitations), and formatting requirements for structured outputs. For option evaluation: A detailed analysis prompt might use comparative analysis techniques, incorporate multiple perspectives through role assignment, and include specific criteria for evaluation. For presentation: A formatting prompt might combine style guidelines, audience considerations, and specific structural requirements. Each component would be designed with appropriate techniques and then integrated into a cohesive workflow. The iterative development process would involve testing each component, evaluating the integrated results, and refining the entire system based on outcomes. This approach demonstrates how advanced prompt engineering projects combine multiple techniques across different components to address complex, multi-faceted challenges that require nuanced, comprehensive solutions.",
        "video": "",
        "reflection": "Consider how you will continue developing your prompt engineering skills beyond this course. Think about how you can apply the advanced techniques you've learned to real-world challenges in your field. Reflect on how you might approach complex problems that require combining multiple techniques and how you'll use iterative development to refine your approaches. Consider what types of advanced projects you might undertake and how you'll measure success in your continued learning. Think about how you can stay current with evolving prompt engineering practices and technologies. Consider how you might create a systematic approach to continuous learning and skill development in this rapidly evolving field. Think about how you'll apply the principles of advanced prompt engineering to create sophisticated solutions to complex challenges you encounter in your work or personal projects.",
        "quiz": [
          {
            "q": "What is the main benefit of combining multiple prompt engineering techniques?",
            "a": "It allows for solving complex challenges that require multiple approaches",
            "opts": [
              "It makes the AI respond faster",
              "It allows for solving complex challenges that require multiple approaches",
              "It reduces the cost of using AI",
              "It makes the AI more creative in all cases"
            ]
          },
          {
            "q": "How does technique synthesis improve the ability to solve complex challenges?",
            "a": "By allowing different approaches to be applied to different aspects of the task",
            "opts": [
              "By making the AI respond faster",
              "By allowing different approaches to be applied to different aspects of the task",
              "By reducing the complexity of each prompt",
              "By making the AI more creative"
            ]
          },
          {
            "q": "Which of the following is NOT a core concept in advanced prompt engineering projects?",
            "a": "Avoiding iterative refinement",
            "opts": [
              "Technique synthesis",
              "Complex task decomposition",
              "Avoiding iterative refinement",
              "Iterative development"
            ]
          },
          {
            "q": "What is the relationship between iterative development and prompt improvement?",
            "a": "Iterative development leads to increasingly sophisticated and effective prompts",
            "opts": [
              "There is no relationship between them",
              "Iterative development leads to increasingly sophisticated and effective prompts",
              "Iterative development reduces prompt effectiveness",
              "Iterative development eliminates the need for testing"
            ]
          },
          {
            "q": "How does breaking down complex tasks help in prompt engineering?",
            "a": "It allows for specialized prompts to address each component effectively",
            "opts": [
              "It makes the task more complex",
              "It allows for specialized prompts to address each component effectively",
              "It reduces the effectiveness of prompts",
              "It eliminates the need for testing"
            ]
          }
        ],
        "summary": "Congratulations! You've completed the Prompt Engineering Mastery course and now have a comprehensive toolkit of techniques to create effective, sophisticated prompts for a wide variety of applications. You've learned to strategically combine multiple techniques to address complex challenges that require sophisticated approaches, decompose complex tasks into specialized, manageable components for targeted solutions, and apply iterative development to continuously refine and improve your advanced projects. Advanced prompt engineering involves systematic integration of multiple methodologies, and technique synthesis creates solutions that exceed what single approaches can achieve. You now understand how to approach complex, multi-dimensional challenges that require nuanced, multi-faceted solutions using integrated systems of different techniques. Remember that prompt engineering is a skill that improves with practice and continuous learning, so continue experimenting, refining your approaches, and applying the principles of advanced prompt engineering to create sophisticated solutions to complex challenges. The most valuable applications of prompt engineering involve complex, multi-faceted challenges that require combining several techniques, and you now have the knowledge and skills to tackle these sophisticated tasks with confidence. Your journey in prompt engineering continues as you apply these advanced concepts to real-world challenges and continue developing your expertise in this rapidly evolving field."
      }
    ]
  }
};

        let currentCourse = "vibe-coding";
        let currentLesson = 0;
        let completedLessons = {};

        (function init() {
            const s = localStorage.getItem('supabase_session');
            const u = localStorage.getItem('supabase_user');
            if (!s || !u) { window.location.replace('/signup'); return; }
            const saved = localStorage.getItem('course_progress');
            if (saved) completedLessons = JSON.parse(saved);
            const p = new URLSearchParams(window.location.search);
            if (p.get('course') && COURSES[p.get('course')]) currentCourse = p.get('course');
            document.getElementById('courseSelect').value = currentCourse;
            currentLesson = Math.max(0, Math.min((parseInt(p.get('lesson')) || 1) - 1, COURSES[currentCourse].lessons.length - 1));
            updateLogo();
            renderLessonList();
            renderLesson();
        })();

        function updateLogo() { document.getElementById('courseLogo').textContent = 'ðŸ“– ' + COURSES[currentCourse].title; }

        function switchCourse(courseId) {
            if (COURSES[courseId]) {
                currentCourse = courseId;
                currentLesson = 0;
                updateLogo();
                renderLessonList();
                renderLesson();
                history.replaceState({}, '', `?course=${courseId}&lesson=1`);
            }
        }

        function renderLessonList() {
            const lessons = COURSES[currentCourse].lessons;
            const completed = completedLessons[currentCourse] || [];
            let html = '';
            let currentModule = '';
            lessons.forEach((L, i) => {
                if (L.module !== currentModule) {
                    currentModule = L.module;
                    html += `<div class="module-group"><div class="module-title">${currentModule}</div>`;
                }
                const isActive = i === currentLesson;
                const isCompleted = completed.includes(i);
                html += `<div class="lesson-item ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}" onclick="selectLesson(${i})"><div class="lesson-num">${isCompleted ? 'âœ“' : i + 1}</div><div class="lesson-info"><div class="lesson-name">${L.title}</div><div class="lesson-duration">â±ï¸ ${L.duration}</div></div></div>`;
            });
            document.getElementById('lessonList').innerHTML = html;
            document.getElementById('progressText').textContent = `${completed.length}/${lessons.length} completed`;
        }

        function selectLesson(index) {
            currentLesson = index;
            renderLessonList();
            renderLesson();
            switchTab('board');
            history.replaceState({}, '', `?course=${currentCourse}&lesson=${index + 1}`);
        }

        function renderLesson() {
            const L = COURSES[currentCourse].lessons[currentLesson];
            const totalLessons = COURSES[currentCourse].lessons.length;
            let videoHtml = '';
            if (L.video) {
                videoHtml = `<div class="content-section"><h3 class="section-title">Watch & Learn</h3><div class="video-container"><iframe src="${L.video}" title="Lesson Video" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div>${L.videoCredit ? `<p style="color: var(--text-muted); font-size: 0.75rem; margin-top: 0.5rem; text-align: right;">Video: ${L.videoCredit}</p>` : ''}</div>`;
            }
            document.getElementById('learningBoard').innerHTML = `<div class="board-content"><div class="lesson-header"><h1>${L.title}</h1><div class="lesson-meta"><span>${L.module}</span><span>${L.duration}</span><span>Lesson ${currentLesson + 1} of ${totalLessons}</span></div></div><div class="content-section"><h3 class="section-title">Introduction</h3><p class="section-text">${L.intro}</p><div class="big-idea-box"><strong style="color: var(--primary);">The Big Idea</strong><p style="margin-top: 0.5rem;">${L.bigIdea}</p></div></div>${videoHtml}<div class="content-section"><h3 class="section-title">Key Steps</h3><ol class="steps-list">${L.steps.map((s, i) => `<li><span class="step-badge">${i + 1}</span><span>${s}</span></li>`).join('')}</ol></div><div class="content-section"><h3 class="section-title">Example</h3><p class="section-text">${L.example}</p></div><div class="content-section"><h3 class="section-title">Quick Quiz (5 Questions)</h3>${L.quiz.map((q, i) => `<div class="quiz-item" id="quiz-${i}"><p><strong>Q${i+1}:</strong> ${q.q}</p><div class="quiz-options">${q.opts.map(o => `<div class="quiz-opt" onclick="checkQuiz(${i}, '${o.replace(/'/g, "\\'")}', '${q.a.replace(/'/g, "\\'")}')">${o}</div>`).join('')}</div></div>`).join('')}</div><div class="content-section"><h3 class="section-title">Reflection</h3><p class="section-text">${L.reflection}</p></div><div class="content-section" style="background: linear-gradient(135deg, var(--bg-card), rgba(16, 185, 129, 0.1)); border-color: var(--success);"><h3 class="section-title" style="color: var(--success);">Summary</h3><p class="section-text">${L.summary}</p></div><div class="lesson-nav"><button class="nav-btn" onclick="navigate(-1)" ${currentLesson === 0 ? 'disabled' : ''}>Previous Lesson</button><button class="nav-btn primary" onclick="completeAndNext()">${currentLesson >= totalLessons - 1 ? 'Complete Course' : 'Mark Complete & Next'}</button></div></div>`;
        }

        function switchTab(tab) {
            document.querySelectorAll('.content-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
            document.querySelector(`.content-tab:nth-child(${tab === 'board' ? 1 : 2})`).classList.add('active');
            document.getElementById(`${tab}-panel`).classList.add('active');
        }

        function checkQuiz(i, selected, correct) {
            const quizDiv = document.getElementById(`quiz-${i}`);
            quizDiv.querySelectorAll('.quiz-opt').forEach(o => {
                o.onclick = null;
                if (o.textContent === correct) o.classList.add('correct');
                else if (o.textContent === selected) o.classList.add('wrong');
            });
        }

        function navigate(dir) {
            const totalLessons = COURSES[currentCourse].lessons.length;
            currentLesson = Math.max(0, Math.min(currentLesson + dir, totalLessons - 1));
            renderLessonList();
            renderLesson();
            document.getElementById('learningBoard').scrollTop = 0;
            history.replaceState({}, '', `?course=${currentCourse}&lesson=${currentLesson + 1}`);
        }

        function completeAndNext() {
            if (!completedLessons[currentCourse]) completedLessons[currentCourse] = [];
            if (!completedLessons[currentCourse].includes(currentLesson)) completedLessons[currentCourse].push(currentLesson);
            localStorage.setItem('course_progress', JSON.stringify(completedLessons));
            const totalLessons = COURSES[currentCourse].lessons.length;
            if (currentLesson < totalLessons - 1) {
                navigate(1);
            } else {
                alert('Congratulations! You have completed the ' + COURSES[currentCourse].title + ' course!');
                renderLessonList();
            }
        }
    </script>
</body>
</html>
