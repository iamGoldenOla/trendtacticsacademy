-- UPDATE LESSONS 15-26: BUILDING SOFTWARE, ADVANCED, CAREER
-- Run this in Supabase SQL Editor

-- LESSON 15: Building a SaaS with AI
UPDATE lessons SET
    content = '<h2>The Playbook: SaaS in Days, Not Months</h2><p>Building a SaaS used to take months. With Vibe Coding, the first version launches in days. Here''s the playbook.</p><h3>The Essential SaaS Stack</h3><ol><li><strong>Auth</strong>: Clerk or Supabase Auth</li><li><strong>Database</strong>: Supabase (Postgres)</li><li><strong>Payments</strong>: Stripe</li><li><strong>Email</strong>: Resend or Postmark</li><li><strong>Hosting</strong>: Vercel or Cloudflare</li><li><strong>UI</strong>: Next.js + Tailwind + Shadcn</li></ol><h3>The Vibe Coding SaaS Workflow</h3><h4>Day 1: Foundation</h4><p>Set up: Next.js project, Supabase connection, basic auth flow. Prompt: ''Create a Next.js app with Supabase auth - login, signup, password reset.''</p><h4>Day 2: Core Feature</h4><p>Build the ONE thing your SaaS does. Prompt: ''Create CRUD for [your core entity] with proper types and validation.''</p><h4>Day 3: Payments</h4><p>Stripe integration. Prompt: ''Add Stripe Checkout for two plans: Free and Pro ($10/month). Handle webhooks for subscription changes.''</p><h4>Day 4: Polish & Launch</h4><p>Dashboard, onboarding, email notifications. Ship it.</p><h3>Prompting for Integrations</h3><p>Paste the actual Stripe/Supabase docs into context. AI reads documentation and implements correctly when given the source of truth.</p><h3>Avoiding Common SaaS Mistakes</h3><ul><li>Start with billing - harder to add later</li><li>Keep feature scope minimal - one core value</li><li>Use existing UI components - don''t reinvent</li></ul>',
    summary = 'SaaS development with Vibe Coding: 4-day playbook covering auth, database, payments, and launch. Paste actual docs for accurate integrations.',
    case_studies = '[{"title": "The $2K MRR SaaS", "scenario": "A developer built a screenshot annotation tool in 5 days using the Vibe Coding SaaS playbook.", "analysis": "Following the day-by-day structure: Day 1 auth, Day 2 canvas/annotations, Day 3 Stripe, Day 4 marketing page.", "outcome": "$2K MRR within 2 months. Total development investment: 5 days and $0 (free tiers everywhere)."}]'::jsonb,
    key_takeaways = '["The 4-day SaaS playbook: Auth → Core Feature → Payments → Launch.", "Paste actual documentation into AI context for accurate integrations.", "Start with billing from day 1 - it is harder to add later."]'::jsonb,
    quizzes = '[{"question": "What should you build on Day 1 of SaaS development?", "options": ["Payments", "Foundation: auth and database setup", "Marketing site", "Advanced features"], "correctAnswer": 1, "explanation": "Auth and database setup create the foundation for everything else."}, {"question": "Why paste documentation into AI context?", "options": ["To look smart", "AI reads and implements from source of truth", "Documentation is fun", "Required by law"], "correctAnswer": 1, "explanation": "AI generates more accurate code when given official docs."}, {"question": "What is the recommended payment stack?", "options": ["PayPal only", "Stripe", "Cash only", "Bitcoin"], "correctAnswer": 1, "explanation": "Stripe has the best AI integration and documentation."}, {"question": "When should you add billing?", "options": ["Never", "From the start - Day 3", "After launch", "After 1000 users"], "correctAnswer": 1, "explanation": "Billing is harder to add later; include it early."}, {"question": "What makes a SaaS launch-ready?", "options": ["100 features", "One core value, working payments, basic auth", "Perfect code", "Desktop app"], "correctAnswer": 1, "explanation": "Minimal viable SaaS: solves one problem, accepts payment."}]'::jsonb,
    videos = '[{"title": "Building SaaS with AI in 2024", "url": "https://www.youtube.com/embed/6qg5iI_n8m0", "why_this_video": "Complete SaaS build using modern AI tools."}]'::jsonb,
    playground = '{"objective": "Build a minimal SaaS foundation in one session", "environment": "cursor", "starter_prompt": "Create a Next.js app with Supabase auth (login, signup) and a protected dashboard page", "guided_steps": ["Set up Supabase project", "Create Next.js app with AI", "Add authentication flow", "Create protected routes", "Add a simple CRUD feature", "Deploy to Vercel"], "advanced_challenge": "Add Stripe subscription with free and paid tiers", "failure_mode_experiment": "Try to add payments without proper webhook handling", "real_world_simulation": "Build the foundation for an actual SaaS idea you have"}'::jsonb,
    duration = 25
WHERE title = 'Building a SaaS with AI';

-- LESSON 16: Building an LMS (Your Case Study)
UPDATE lessons SET
    content = '<h2>Meta-Learning: How This Course Was Built</h2><p>You are using an LMS built by Vibe Coding. This lesson explains how it works—and how you could build one yourself.</p><h3>The LMS Architecture</h3><h4>Database Schema</h4><ul><li><strong>courses</strong>: id, title, description, slug</li><li><strong>modules</strong>: id, course_id, title, order</li><li><strong>lessons</strong>: id, module_id, title, content, video_url, quizzes</li><li><strong>enrollments</strong>: user_id, course_id, progress</li><li><strong>completions</strong>: user_id, lesson_id, completed_at</li></ul><h4>Content Generation System</h4><p>The ''Antigravity'' engine checks for missing content and fills it. When a lesson is incomplete, it triggers AI generation following strict specifications (this very document!).</p><h4>Resume Logic</h4><p>''Last Lesson'' ID stored in user profile. On login, redirect to last position. Progress calculation: completed_lessons / total_lessons.</p><h3>How Content Is Rendered</h3><ol><li>User navigates to course</li><li>System fetches course → modules → lessons tree</li><li>Current lesson renders: video, content, quizzes</li><li>On completion, progress updates, next lesson unlocks</li></ol><h3>Building Your Own</h3><p>The prompts that built this system:</p><ul><li>''Create a course player with video, content sections, and quiz''</li><li>''Add progress tracking that persists to Supabase''</li><li>''Generate lesson content following this specification...''</li></ul>',
    summary = 'This LMS demonstrates Vibe Coding in action: courses, modules, lessons, progress tracking, and AI-generated content following strict specifications.',
    case_studies = '[{"title": "The Self-Building Course", "scenario": "Trendtactics Academy needed 26 lessons. Rather than write each manually, the system generates compliant content.", "analysis": "A content specification defines the structure. AI generates, validates, and persists. Human reviews.", "outcome": "100+ lessons across multiple courses, maintained by a single developer with AI assistance. Scales infinitely."}]'::jsonb,
    key_takeaways = '["LMS is courses → modules → lessons with user progress tracking.", "Content generation can be systematic - define spec, generate, validate.", "This course is proof that Vibe Coding can build production systems."]'::jsonb,
    quizzes = '[{"question": "What is the LMS database hierarchy?", "options": ["Users → Lessons", "Courses → Modules → Lessons", "Files → Folders", "Random"], "correctAnswer": 1, "explanation": "Content is organized: Courses contain Modules contain Lessons."}, {"question": "How does progress tracking work?", "options": ["Manual counting", "completed_lessons / total_lessons", "Time-based", "Random"], "correctAnswer": 1, "explanation": "Progress is calculated by dividing completed by total lessons."}, {"question": "What triggers content generation?", "options": ["User request", "Missing or incomplete content detected", "Full moon", "Never"], "correctAnswer": 1, "explanation": "The system detects gaps and generates to fill them."}, {"question": "What is resume logic?", "options": ["Finding a job", "Returning user to their last lesson position", "Starting over", "Skipping content"], "correctAnswer": 1, "explanation": "Resume logic remembers where users left off."}, {"question": "Can AI build production systems?", "options": ["Never", "Yes - this course proves it", "Only toys", "Only with huge teams"], "correctAnswer": 1, "explanation": "This LMS is proof that AI-built systems can be production-quality."}]'::jsonb,
    videos = '[{"title": "Building an LMS from Scratch", "url": "https://www.youtube.com/embed/pU72h2Zbc5c", "why_this_video": "Complete walkthrough of LMS architecture and implementation."}]'::jsonb,
    playground = '{"objective": "Build a minimal course player with progress tracking", "environment": "cursor", "starter_prompt": "Create a course player that shows a list of lessons on the left, current lesson content on the right, and tracks completion", "guided_steps": ["Design the course schema in Supabase", "Create the lesson list sidebar", "Create the content display area", "Add completion tracking", "Implement progress calculation", "Add resume functionality"], "advanced_challenge": "Add AI-generated content for new lessons", "failure_mode_experiment": "Build without progress tracking and see how UX suffers", "real_world_simulation": "Design an LMS for a topic you could teach"}'::jsonb,
    duration = 20
WHERE title = 'Building an LMS (Your Case Study)';

-- LESSON 17: Debugging AI Systems
UPDATE lessons SET
    content = '<h2>When It Breaks: Debugging AI-Generated Code</h2><p>AI writes bugs. It hallucinates. It misunderstands. Debugging AI systems requires specific strategies.</p><h3>The AI Debugging Mindset</h3><ul><li><strong>Expect Errors</strong>: AI code needs validation, always</li><li><strong>Read Before Run</strong>: Skim generated code for obvious issues</li><li><strong>Error as Input</strong>: Paste errors back to AI for fixes</li><li><strong>Isolate Quickly</strong>: Find the minimal reproduction</li></ul><h3>The Error Feedback Loop</h3><ol><li>Run the code</li><li>Get error</li><li>Paste error + context back to AI</li><li>''Explain this error and fix it''</li><li>Review fix, apply if correct</li></ol><h3>Common AI Code Bugs</h3><ul><li><strong>Hallucinated APIs</strong>: Functions that don''t exist</li><li><strong>Type Mismatches</strong>: Especially in TypeScript</li><li><strong>Missing Edge Cases</strong>: Null checks, error handling</li><li><strong>Stale Dependencies</strong>: Old package versions</li><li><strong>Logic Errors</strong>: Correct syntax, wrong behavior</li></ul><h3>Debugging Tools</h3><ul><li><strong>Console.log</strong>: Still your best friend</li><li><strong>Debugger</strong>: Step through AI code like any code</li><li><strong>Type Checking</strong>: TypeScript catches many AI errors</li><li><strong>Tests</strong>: AI can write tests to validate AI code</li></ul><h3>Self-Healing Systems</h3><p>Advanced: Auto-feed errors back to AI. If error, run fix_agent(error). Loop until resolved or limit reached.</p>',
    summary = 'AI code needs debugging. Use the error feedback loop: run → error → paste to AI → fix → verify. Expect hallucinated APIs and missing edge cases.',
    case_studies = '[{"title": "The Infinite Error Loop", "scenario": "A developer kept pasting errors to AI, which kept making new errors.", "analysis": "The AI was pattern-matching fixes without understanding root cause.", "outcome": "Solution: Step back, explain the intent, let AI regenerate from scratch. Sometimes rewrite beats fix."}]'::jsonb,
    key_takeaways = '["Expect errors - AI code always needs validation.", "Error feedback loop: paste error back to AI with context.", "Sometimes regeneration beats iteration - know when to restart."]'::jsonb,
    quizzes = '[{"question": "What is the error feedback loop?", "options": ["Ignore errors", "Paste error back to AI for fixes", "Delete everything", "Blame the AI"], "correctAnswer": 1, "explanation": "Feeding errors back with context helps AI fix them."}, {"question": "What are hallucinated APIs?", "options": ["Dream features", "Functions AI invented that do not exist", "Fast APIs", "Cloud services"], "correctAnswer": 1, "explanation": "AI sometimes invents plausible-sounding but fake API methods."}, {"question": "When should you regenerate vs iterate?", "options": ["Never regenerate", "When fix loops are not converging", "Always regenerate", "Randomly"], "correctAnswer": 1, "explanation": "If fixes keep causing new errors, regeneration may be faster."}, {"question": "What tool catches many AI type errors?", "options": ["Notepad", "TypeScript strict mode", "Paint", "Excel"], "correctAnswer": 1, "explanation": "TypeScript catches type mismatches at compile time."}, {"question": "What is a self-healing system?", "options": ["Medical AI", "System that auto-fixes errors using AI", "Broken system", "Manual repair"], "correctAnswer": 1, "explanation": "Self-healing systems automatically feed errors back to AI for fixes."}]'::jsonb,
    videos = '[{"title": "Debugging AI-Generated Code", "url": "https://www.youtube.com/embed/5EFd0n_n7bU", "why_this_video": "Practical strategies for finding and fixing AI code bugs."}]'::jsonb,
    playground = '{"objective": "Practice the error feedback loop on intentionally buggy code", "environment": "cursor", "starter_prompt": "Generate a function to fetch user data that has at least 3 bugs", "guided_steps": ["Ask AI to generate code with intentional bugs", "Run and observe errors", "Practice the feedback loop technique", "Compare fix iterations vs regeneration", "Build intuition for when to restart"], "advanced_challenge": "Build an auto-debugging agent that runs code, catches errors, and fixes them", "failure_mode_experiment": "Enter an infinite fix loop and document when to break out", "real_world_simulation": "Debug a real AI-generated feature in your project"}'::jsonb,
    duration = 20
WHERE title = 'Debugging AI Systems';

-- LESSON 18: Databases Without Fear
UPDATE lessons SET
    content = '<h2>SQL is English: Database AI Mastery</h2><p>With AI, SQL becomes natural language. You don''t need to be a DBA. You need to understand data models.</p><h3>The Prompt-to-SQL Pattern</h3><p><strong>You say:</strong> ''Get all users who haven''t logged in for 30 days''</p><p><strong>AI generates:</strong> SELECT * FROM users WHERE last_login < NOW() - INTERVAL ''30 days''</p><h3>Schema Design with AI</h3><p>Describe relationships in words:</p><ul><li>''Users can have many posts''</li><li>''Posts belong to one user''</li><li>''Posts can have many tags through post_tags''</li></ul><p>AI generates proper foreign keys, indexes, and constraints.</p><h3>Migrations Made Easy</h3><p>Never write migrations manually. Prompt: ''Add a phone_number column to users table, nullable, VARCHAR(20)''</p><p>AI generates migration with proper types and defaults.</p><h3>RLS - Row Level Security</h3><p>Critical for multi-tenant apps. Prompt: ''Create RLS policy so users can only see their own data''</p><p>AI generates: auth.uid() = user_id policies.</p><h3>Query Optimization</h3><p>''This query is slow: [paste query]. Explain why and optimize it.''</p><p>AI analyzes, suggests indexes, rewrites for performance.</p><h3>The Data Model Mindset</h3><p>You need to understand: entities, relationships, cardinality, normalization concepts. The SQL syntax is AI''s job; the data architecture is yours.</p>',
    summary = 'SQL is natural language with AI. Focus on data model understanding; AI handles syntax, migrations, and optimization.',
    case_studies = '[{"title": "The Complex Query", "scenario": "A developer needed to generate monthly revenue reports with 5 table joins.", "analysis": "Natural language description: ''Get total revenue per month, broken down by product category, for customers who have made more than 3 purchases.''", "outcome": "AI generated a 30-line SQL query that would have taken an hour to write manually. Worked on first try."}]'::jsonb,
    key_takeaways = '["SQL is natural language - describe what you want, AI writes the query.", "Migrations are prompts - never write ALTER TABLE manually.", "Understand data models - AI handles syntax, you handle architecture."]'::jsonb,
    quizzes = '[{"question": "What skill is still needed with AI SQL?", "options": ["Memorizing syntax", "Understanding data models and relationships", "Fast typing", "Nothing"], "correctAnswer": 1, "explanation": "You design the data architecture; AI handles the SQL syntax."}, {"question": "How do you create migrations with AI?", "options": ["Write them manually", "Describe the change in natural language", "Import from cloud", "Migrations are obsolete"], "correctAnswer": 1, "explanation": "Prompt the migration like: ''Add X column to Y table''."}, {"question": "What is RLS?", "options": ["Random List System", "Row Level Security - users see only their data", "Read Load Speed", "Real Live System"], "correctAnswer": 1, "explanation": "RLS ensures users can only access their own rows."}, {"question": "How do you optimize slow queries?", "options": ["Buy faster computer", "Ask AI to analyze and suggest indexes", "Delete data", "Ignore performance"], "correctAnswer": 1, "explanation": "AI can analyze queries, explain bottlenecks, and suggest optimizations."}, {"question": "What should you design, not the AI?", "options": ["SQL syntax", "Data architecture and relationships", "Variable names", "Comments"], "correctAnswer": 1, "explanation": "You design entities and relationships; AI writes the implementation."}]'::jsonb,
    videos = '[{"title": "Database Design with AI", "url": "https://www.youtube.com/embed/FdbBgZp33W0", "why_this_video": "How to design and query databases using natural language AI."}]'::jsonb,
    playground = '{"objective": "Design and query a database using only natural language", "environment": "cursor", "starter_prompt": "Design a database for a blog: users can write posts, posts have tags, users can comment on posts", "guided_steps": ["Describe the data model in plain English", "Generate the schema with AI", "Create sample queries: get all posts by user, get popular tags", "Generate a migration to add a feature", "Write an RLS policy for user-owned data"], "advanced_challenge": "Design a schema for a marketplace with users, products, orders, and reviews", "failure_mode_experiment": "Generate a query with poor performance and optimize it", "real_world_simulation": "Design the database for an actual project using only AI"}'::jsonb,
    duration = 20
WHERE title = 'Databases Without Fear';

-- LESSON 19: Authentication & Roles
UPDATE lessons SET
    content = '<h2>Security by Prompt: Auth and Authorization</h2><p>Authentication (who you are) and authorization (what you can do) are critical—and often where AI-generated code has gaps.</p><h3>The Auth Stack</h3><ul><li><strong>Supabase Auth</strong>: Built-in, works with RLS</li><li><strong>Clerk</strong>: Drop-in UI, advanced features</li><li><strong>Auth0</strong>: Enterprise-grade</li><li><strong>NextAuth</strong>: Flexible, open source</li></ul><h3>RLS (Row Level Security)</h3><p>The most important security concept for Vibe Coding:</p><pre>CREATE POLICY "Users see own data"\nON todos\nFOR SELECT\nUSING (auth.uid() = user_id);</pre><p>This ensures database-level security—even if your app code has bugs.</p><h3>Common Auth Prompts</h3><ul><li>''Create login/signup flow with email verification''</li><li>''Add social login: Google and GitHub''</li><li>''Implement role-based access: admin, user, guest''</li><li>''Protect this API route for authenticated users only''</li></ul><h3>Role-Based Access Control (RBAC)</h3><p>Store roles in the user profile. Check on both client and server:</p><pre>if (user.role !== ''admin'') throw unauthorized();</pre><h3>AI Auth Pitfalls</h3><p><strong>Always prompt:</strong> ''Ensure RLS policies are enabled and correct.''</p><p>AI often forgets server-side validation. Always verify auth checks exist in API routes.</p>',
    summary = 'RLS (Row Level Security) is the key to secure Vibe Coding. Always prompt for security checks—AI often forgets server-side validation.',
    case_studies = '[{"title": "The Security Audit", "scenario": "An app launched with AI-generated code. A security audit found 5 routes missing auth checks.", "analysis": "AI generated the routes but did not add middleware. The prompts never mentioned security.", "outcome": "Added explicit security prompts: ''Protect this route - verify user is authenticated AND authorized.'' All future routes generated correctly."}]'::jsonb,
    key_takeaways = '["RLS provides database-level security that survives app bugs.", "Always prompt for security: AI does not add it by default.", "Validate auth on BOTH client and server - never trust client alone."]'::jsonb,
    quizzes = '[{"question": "What is RLS?", "options": ["A programming language", "Row Level Security - database-level access control", "A framework", "A testing tool"], "correctAnswer": 1, "explanation": "RLS ensures users can only access rows they are authorized for."}, {"question": "Why is RLS important?", "options": ["Performance", "It protects data even if app code has bugs", "Looks professional", "Required by law"], "correctAnswer": 1, "explanation": "RLS is a safety net at the database level."}, {"question": "What should you always prompt for?", "options": ["Comments", "Security and auth checks", "Prettier code", "Longer variable names"], "correctAnswer": 1, "explanation": "AI often forgets security; always explicitly request it."}, {"question": "Where should auth be validated?", "options": ["Client only", "Server only", "Both client AND server", "Neither"], "correctAnswer": 2, "explanation": "Never trust client-side auth alone; always validate on server."}, {"question": "What is RBAC?", "options": ["A database", "Role-Based Access Control", "A framework", "A testing method"], "correctAnswer": 1, "explanation": "RBAC assigns permissions based on user roles like admin, user, guest."}]'::jsonb,
    videos = '[{"title": "Supabase Auth and RLS Deep Dive", "url": "https://www.youtube.com/embed/1PHk_g8gWbU", "why_this_video": "Complete guide to authentication and row-level security."}]'::jsonb,
    playground = '{"objective": "Implement secure authentication with proper RLS", "environment": "cursor", "starter_prompt": "Create a Supabase auth flow with login, signup, and password reset, protected by RLS", "guided_steps": ["Set up Supabase auth", "Create a protected table (e.g., todos)", "Add RLS policy for user-owned data", "Test: can you see other users data? (should be no)", "Add role-based access (admin role)", "Create an admin-only route"], "advanced_challenge": "Implement multi-tenant RLS where users see only their organization data", "failure_mode_experiment": "Disable RLS and observe how easily data leaks", "real_world_simulation": "Audit your current project for missing auth checks"}'::jsonb,
    duration = 20
WHERE title = 'Authentication & Roles';

-- LESSON 20: State, Caching & Persistence
UPDATE lessons SET
    content = '<h2>The Memory of the App: State Management</h2><p>Apps need to remember. Understanding where state lives is crucial for Vibe Coding.</p><h3>The State Hierarchy</h3><ol><li><strong>Component State</strong>: React useState - dies on unmount</li><li><strong>Global State</strong>: Redux/Zustand - survives navigation, dies on refresh</li><li><strong>Local Storage</strong>: Browser storage - survives refresh, per-device</li><li><strong>Session Storage</strong>: Tab-specific, dies on close</li><li><strong>Server State</strong>: Database - permanent, cross-device</li></ol><h3>Choosing the Right State</h3><ul><li>Form inputs → Component state</li><li>User preferences → Local storage</li><li>Shopping cart → Local storage + server sync</li><li>User profile → Server state (database)</li></ul><h3>The Vibe Lesson</h3><p>AI loves useState. It will use it for EVERYTHING. Remind it:</p><p>''This needs to persist across page refresh - use localStorage''</p><p>''This needs to sync across devices - use Supabase''</p><h3>Caching Strategies</h3><ul><li><strong>React Query / SWR</strong>: Server state caching</li><li><strong>Zustand persist</strong>: Local storage for global state</li><li><strong>Service Workers</strong>: Offline-first apps</li></ul><h3>Common Mistakes</h3><ul><li>Using useState for data that should persist</li><li>Fetching on every render instead of caching</li><li>Not handling loading/error states</li></ul>',
    summary = 'State lives in different places for different durations. AI defaults to useState—always specify persistence requirements explicitly.',
    case_studies = '[{"title": "The Lost Cart", "scenario": "An e-commerce site stored cart in useState. Users lost their cart on every page refresh.", "analysis": "AI used the simplest state option. The prompt never mentioned persistence.", "outcome": "Adding ''persist cart to localStorage with Supabase sync'' to the prompt fixed it permanently."}]'::jsonb,
    key_takeaways = '["AI defaults to useState - always specify persistence needs.", "Local storage survives refresh; database survives across devices.", "Use React Query or SWR for server state caching."]'::jsonb,
    quizzes = '[{"question": "What happens to useState on page refresh?", "options": ["Persists", "Resets to initial value", "Syncs to cloud", "Nothing"], "correctAnswer": 1, "explanation": "Component state is lost on refresh unless persisted elsewhere."}, {"question": "What survives browser refresh?", "options": ["useState", "localStorage", "Component props", "Context"], "correctAnswer": 1, "explanation": "localStorage persists in the browser across sessions."}, {"question": "What syncs across devices?", "options": ["localStorage", "sessionStorage", "Database (server state)", "Cookies"], "correctAnswer": 2, "explanation": "Only server state (database) syncs across devices."}, {"question": "What does AI default to for state?", "options": ["Database", "localStorage", "useState (component state)", "Redux"], "correctAnswer": 2, "explanation": "AI typically uses the simplest option: useState."}, {"question": "What caches server state in React?", "options": ["useState", "React Query or SWR", "localStorage", "console.log"], "correctAnswer": 1, "explanation": "React Query and SWR handle server state caching intelligently."}]'::jsonb,
    videos = '[{"title": "State Management in React", "url": "https://www.youtube.com/embed/uGgCqV7G8_0", "why_this_video": "Complete overview of state management options and when to use each."}]'::jsonb,
    playground = '{"objective": "Implement proper state persistence for different scenarios", "environment": "cursor", "starter_prompt": "Create a settings page where user preferences (theme, notifications) persist across sessions", "guided_steps": ["Build a settings form with useState (it will break on refresh)", "Add localStorage persistence", "Implement sync to Supabase for cross-device", "Add loading/error states", "Test: change device, see settings persist"], "advanced_challenge": "Build an offline-first app that syncs when connection returns", "failure_mode_experiment": "Use only useState for a shopping cart and observe data loss", "real_world_simulation": "Audit your app for state that should persist but does not"}'::jsonb,
    duration = 20
WHERE title = 'State, Caching & Persistence';

-- LESSON 21: Verification Prompts
UPDATE lessons SET
    content = '<h2>Checking the AI''s Work: Verification Prompts</h2><p>After generation, run verification prompts. This forces AI from ''Creative Writer'' to ''Critical Critic'' mode.</p><h3>The Verification Pattern</h3><p>After AI generates code, immediately ask:</p><ol><li>''List 3 ways this code could fail''</li><li>''What edge cases are not handled?''</li><li>''Audit this for security vulnerabilities''</li><li>''Explain this code to a 5-year-old''</li></ol><h3>Why Verification Works</h3><p>Generation is optimistic—AI tries to complete the task. Verification is pessimistic—AI tries to break the solution. Different cognitive modes.</p><h3>Security Audit Prompts</h3><ul><li>''Check for SQL injection vulnerabilities''</li><li>''Are there any auth bypasses?''</li><li>''Review for XSS vulnerabilities''</li><li>''Check for exposed secrets or API keys''</li></ul><h3>Performance Review Prompts</h3><ul><li>''What is the time complexity of this function?''</li><li>''Will this scale to 10,000 users?''</li><li>''Are there any N+1 query problems?''</li></ul><h3>Building a Verification Habit</h3><p>Generate → Verify → Iterate. Never ship the first output. Always ask ''what could go wrong?''</p>',
    summary = 'Verification prompts switch AI from generation mode to critique mode. Always ask: What could fail? What edge cases are missing?',
    case_studies = '[{"title": "The Security Catch", "scenario": "AI generated an upload endpoint. Verification prompt caught: no file type validation, no size limit.", "analysis": "The generation was functional but insecure. Verification caught it before production.", "outcome": "Added validation, size limits, and malware scanning. Verification saved a potential breach."}]'::jsonb,
    key_takeaways = '["Verification switches AI from creative to critical mode.", "Always ask: What could fail? What is missing? What is insecure?", "Generate → Verify → Iterate - never ship first output."]'::jsonb,
    quizzes = '[{"question": "What do verification prompts do?", "options": ["Generate more code", "Switch AI to critical/audit mode", "Speed up generation", "Delete code"], "correctAnswer": 1, "explanation": "Verification switches AI from trying to complete to trying to break."}, {"question": "When should you verify?", "options": ["Never", "After every generation", "Once a year", "Only for production"], "correctAnswer": 1, "explanation": "Verification should be part of every generation cycle."}, {"question": "What is a good verification prompt?", "options": ["Make it pretty", "List ways this could fail", "Add comments", "Make it longer"], "correctAnswer": 1, "explanation": "Asking how code could fail triggers critical analysis."}, {"question": "Why does verification work?", "options": ["AI is smarter", "Different cognitive mode than generation", "Faster processing", "More memory"], "correctAnswer": 1, "explanation": "Generation is optimistic; verification is pessimistic. Different modes."}, {"question": "What should you never ship?", "options": ["Verified code", "The first unverified output", "Tested code", "Documented code"], "correctAnswer": 1, "explanation": "Always verify before shipping - first output often has issues."}]'::jsonb,
    videos = '[{"title": "AI Code Review Techniques", "url": "https://www.youtube.com/embed/sFkS-XJb6jo", "why_this_video": "How to use AI to review and verify AI-generated code."}]'::jsonb,
    playground = '{"objective": "Practice verification prompts on generated code", "environment": "cursor", "starter_prompt": "Generate an API endpoint for user registration", "guided_steps": ["Generate the registration endpoint", "Ask: List 3 ways this could fail", "Ask: What edge cases are not handled?", "Ask: Audit for security vulnerabilities", "Implement the suggested fixes", "Verify the fixed version"], "advanced_challenge": "Build an automated verification pipeline that runs these prompts automatically", "failure_mode_experiment": "Ship unverified code to staging and catalog the issues found", "real_world_simulation": "Verify AI-generated code in your actual project"}'::jsonb,
    duration = 15
WHERE title = 'Verification Prompts';

-- LESSON 22: Cost, Performance & Sanity
UPDATE lessons SET
    content = '<h2>The API Bill: Managing AI Costs and Your Sanity</h2><p>AI APIs cost money. Context is expensive. Iteration can spiral. Managing costs and mental health matters.</p><h3>The Model Hierarchy</h3><ul><li><strong>Expensive/Smart</strong>: Claude 3.5, GPT-4o - Use for complex generation</li><li><strong>Cheap/Fast</strong>: Claude Haiku, GPT-4o-mini - Use for simple tasks</li><li><strong>Free</strong>: Cursor small, local models - Use for autocomplete</li></ul><h3>Cost Optimization Strategy</h3><ol><li>Draft complex features with expensive models</li><li>Refine and iterate with cheaper models</li><li>Use autocomplete for typing assistance</li></ol><h3>Context Costs Money</h3><p>Loading 50 files into context = expensive. Be surgical about what you include.</p><h3>The Sanity Rule</h3><p>If AI struggles for 10+ minutes on the same problem:</p><ol><li>Stop</li><li>Re-prompt from scratch with different framing</li><li>Consider a manual solution</li><li>Take a break</li></ol><p>Don''t let the AI drive you into a ravine. You are still in control.</p><h3>Burnout Prevention</h3><ul><li>Set session time limits</li><li>Celebrate small wins</li><li>Remember: stuck is normal</li><li>AI amplifies, not replaces, your thinking</li></ul>',
    summary = 'Manage AI costs with model hierarchy: expensive for drafting, cheap for refining. Stop iteration loops after 10 minutes—re-prompt or manual fix.',
    case_studies = '[{"title": "The $500 Day", "scenario": "A developer left Cursor running with a huge context window overnight. $500 API bill.", "analysis": "Large context + continuous autocomplete = expensive. No safeguards in place.", "outcome": "Implemented: API spending alerts, smaller context windows, session limits. Normal costs: $20/month."}]'::jsonb,
    key_takeaways = '["Use expensive models for drafting, cheap models for refining.", "Context costs money - be surgical about what you include.", "Stop after 10 minutes of struggle - re-prompt or go manual."]'::jsonb,
    quizzes = '[{"question": "When to use expensive models?", "options": ["Always", "Complex initial generation", "Never", "Only for comments"], "correctAnswer": 1, "explanation": "Expensive models for complex drafting, cheap for refinement."}, {"question": "What costs money in AI usage?", "options": ["Thinking", "Context size and token usage", "Time", "Hard drive space"], "correctAnswer": 1, "explanation": "Tokens (context + output) are what you pay for."}, {"question": "When should you stop iterating?", "options": ["Never stop", "After 10+ minutes of struggle", "After 1 try", "When perfect"], "correctAnswer": 1, "explanation": "Endless iteration is a trap - know when to reset."}, {"question": "What is the sanity rule?", "options": ["Always use AI", "Re-prompt or go manual after extended struggle", "Never stop", "Only use free models"], "correctAnswer": 1, "explanation": "Protect your mental health - AI should help, not frustrate."}, {"question": "How do you reduce API costs?", "options": ["Use more context", "Smaller context, cheaper models for simple tasks", "Run 24/7", "More iterations"], "correctAnswer": 1, "explanation": "Be surgical with context and use appropriate model tiers."}]'::jsonb,
    videos = '[{"title": "Managing AI Development Costs", "url": "https://www.youtube.com/embed/yO7-wV7pPZQ", "why_this_video": "Practical tips for controlling AI API spending."}]'::jsonb,
    playground = '{"objective": "Practice cost-effective AI usage", "environment": "cursor", "starter_prompt": "Build a feature using model tiering: draft with Claude 3.5, refine with Haiku", "guided_steps": ["Identify a feature to build", "Generate first draft with premium model", "Switch to cheaper model for refinements", "Compare output quality vs cost", "Implement spending alerts or limits"], "advanced_challenge": "Build the same feature with only free/local models", "failure_mode_experiment": "Intentionally iterate for 30 minutes on a stuck problem", "real_world_simulation": "Track your AI costs for a week and optimize"}'::jsonb,
    duration = 15
WHERE title = 'Cost, Performance & Sanity';

-- Continue in next part...
SELECT 'Updated lessons 15-22 successfully' as status;
