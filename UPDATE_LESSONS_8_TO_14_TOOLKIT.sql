-- UPDATE LESSONS 8-14: THE VIBE CODING TOOLKIT (40+ TOOLS)
-- Run this in Supabase SQL Editor

-- LESSON 8: System Prompts vs User Prompts
UPDATE lessons SET
    content = '<h2>The God Mode</h2><p>System prompts are the constitution of your AI agent. They define the rules, personality, and constraints that apply to EVERY interaction. User prompts are specific requests within that framework.</p><h3>The Hierarchy of Prompts</h3><ul><li><strong>System Prompt</strong>: Always active, sets the foundation (You are a senior TypeScript developer...)</li><li><strong>Context</strong>: Files, documentation, examples currently loaded</li><li><strong>User Prompt</strong>: The specific task request</li></ul><h3>Crafting Powerful System Prompts</h3><p>A great system prompt includes:</p><ol><li><strong>Role Definition</strong>: Who is the AI in this context?</li><li><strong>Constraints</strong>: What should it always/never do?</li><li><strong>Output Format</strong>: How should responses be structured?</li><li><strong>Quality Standards</strong>: What level of code is acceptable?</li></ol><h3>The .cursorrules File</h3><p>In Cursor, the .cursorrules file in your project root becomes your persistent system prompt. It loads automatically, ensuring every AI interaction follows your standards.</p><h3>Example System Prompt</h3><pre>You are a senior React/TypeScript developer.\nALWAYS: Use functional components, TypeScript strict mode, Tailwind CSS.\nNEVER: Use class components, any type, inline styles.\nFORMAT: Explain changes briefly, then show code.\nSTANDARD: Production-ready, properly typed, tested.</pre><h3>Layering Prompts</h3><p>System prompts and user prompts work together. System sets the foundation; user provides the specific task. This layering is the key to consistent, high-quality output.</p>',
    summary = 'System prompts define the always-active rules and personality for AI interactions. They are the constitution that guides every user prompt.',
    case_studies = '[{"title": "The Inconsistent Codebase", "scenario": "A team of 4 used AI without system prompts. Their codebase had 3 different coding styles.", "analysis": "Each developer got different AI outputs because there was no shared foundation.", "outcome": "Adding a .cursorrules file with team coding standards unified output. Code review time dropped 60%."}]'::jsonb,
    key_takeaways = '["System prompts are the constitution - they apply to every interaction.", "Use .cursorrules for persistent project-level AI configuration.", "Layer system + user prompts for consistent, specific results."]'::jsonb,
    quizzes = '[{"question": "What is a system prompt?", "options": ["A one-time instruction", "Always-active rules for AI", "The operating system", "A debugging tool"], "correctAnswer": 1, "explanation": "System prompts define persistent rules that apply to all interactions."}, {"question": "Where does .cursorrules go?", "options": ["Home directory", "Project root", "System32", "Cloud"], "correctAnswer": 1, "explanation": "The .cursorrules file in project root auto-loads as system prompt."}, {"question": "What should a system prompt include?", "options": ["Just the task", "Role, constraints, format, standards", "Only examples", "Error messages"], "correctAnswer": 1, "explanation": "Complete system prompts define role, rules, format, and quality."}, {"question": "How do system and user prompts relate?", "options": ["They conflict", "System sets foundation, user requests specific task", "They are the same", "User overrides system"], "correctAnswer": 1, "explanation": "They layer - system provides context, user provides specifics."}, {"question": "What problem do system prompts solve?", "options": ["Speed", "Inconsistent outputs across sessions", "Cost", "File size"], "correctAnswer": 1, "explanation": "System prompts ensure consistent AI behavior."}]'::jsonb,
    videos = '[{"title": "Cursor Rules Deep Dive", "url": "https://www.youtube.com/embed/6qg5iI_n8m0", "why_this_video": "Complete guide to setting up .cursorrules for consistent AI development."}]'::jsonb,
    playground = '{"objective": "Create and test a comprehensive system prompt for your coding style", "environment": "cursor", "starter_prompt": "You are a [role]. ALWAYS: [3 things]. NEVER: [3 things]. FORMAT: [output style].", "guided_steps": ["Define your ideal coding style", "Write a system prompt with role, constraints, format", "Create .cursorrules in a project", "Test with a simple task", "Compare output with and without .cursorrules", "Iterate on the rules"], "advanced_challenge": "Create a .cursorrules that produces consistent output for a team of 4 developers", "failure_mode_experiment": "Remove .cursorrules and observe how output consistency degrades", "real_world_simulation": "Build the .cursorrules for your actual production project"}'::jsonb,
    duration = 15
WHERE title = 'System Prompts vs User Prompts';

-- LESSON 9: Modular Thinking
UPDATE lessons SET
    content = '<h2>Everything is a Lego Block</h2><p>Build modules, not monoliths. AI works best on focused, isolated pieces that snap together. Modular thinking is the key to scaling Vibe Coding to large projects.</p><h3>Why Modules Win</h3><ul><li><strong>AI Focus</strong>: Smaller context = better output</li><li><strong>Reusability</strong>: Build once, use everywhere</li><li><strong>Testability</strong>: Isolated testing is easier</li><li><strong>Parallelization</strong>: Different modules can be built simultaneously</li></ul><h3>The Module Anatomy</h3><p>Every good module has:</p><ol><li><strong>Clear Interface</strong>: What goes in, what comes out</li><li><strong>Single Responsibility</strong>: Does one thing well</li><li><strong>Minimal Dependencies</strong>: Loosely coupled</li><li><strong>Self-Contained Logic</strong>: Understandable in isolation</li></ol><h3>Prompting for Modules</h3><p>Instead of: ''Build a user management system''</p><p>Try: ''Build a createUser function that takes {name, email}, validates input, hashes password, and returns User | Error''</p><h3>The Composition Pattern</h3><p>Large features = many small modules composed together. AI builds the blocks; you design the architecture that connects them.</p><h3>Module Boundaries</h3><p>Where do you draw the line? When in doubt, if you can describe it in one sentence, it''s a module. If it takes a paragraph, break it down further.</p>',
    summary = 'Modular architecture enables better AI output by providing focused context. Build small, composable blocks rather than monolithic features.',
    case_studies = '[{"title": "The Monolith Disaster", "scenario": "A developer tried to generate an entire e-commerce checkout flow in one prompt. 2000 lines of tangled code.", "analysis": "The AI lost coherence at scale. Early patterns conflicted with later requirements.", "outcome": "Breaking into 12 modules (cart, payment, shipping, etc.) produced clean, working code in 1/3 the time."}]'::jsonb,
    key_takeaways = '["Smaller context = better AI output.", "One sentence description = one module.", "Composition > monolith - build blocks that snap together."]'::jsonb,
    quizzes = '[{"question": "Why does modular thinking help Vibe Coding?", "options": ["Looks more organized", "Smaller context produces better AI output", "Required by frameworks", "Saves storage"], "correctAnswer": 1, "explanation": "Focused context windows produce higher quality AI generation."}, {"question": "What defines a good module?", "options": ["Large size", "Clear interface and single responsibility", "Many dependencies", "Complex logic"], "correctAnswer": 1, "explanation": "Modules should be focused, with clear inputs/outputs."}, {"question": "How do you know when to split?", "options": ["When code is long", "When description takes a paragraph", "Every 100 lines", "When tests fail"], "correctAnswer": 1, "explanation": "If you cannot describe it in one sentence, split it."}, {"question": "What is the composition pattern?", "options": ["One big function", "Many modules connected together", "Class inheritance", "Copy-paste"], "correctAnswer": 1, "explanation": "Composition connects small focused modules into larger features."}, {"question": "Who designs the architecture?", "options": ["The AI", "The human", "The framework", "Random"], "correctAnswer": 1, "explanation": "You design how modules connect; AI builds the blocks."}]'::jsonb,
    videos = '[{"title": "Modular Development with AI", "url": "https://www.youtube.com/embed/pU72h2Zbc5c", "why_this_video": "Shows how to break features into AI-friendly modules."}]'::jsonb,
    playground = '{"objective": "Decompose a large feature into AI-friendly modules", "environment": "cursor", "starter_prompt": "Build a user authentication system", "guided_steps": ["Write the big request as one prompt - observe issues", "Break into modules: validateEmail, hashPassword, createUser, loginUser, generateToken", "Prompt for each module separately", "Compose modules together", "Compare quality to monolithic approach"], "advanced_challenge": "Design a 20-module architecture for an e-commerce platform", "failure_mode_experiment": "Build a 500-line feature in one prompt and document failures", "real_world_simulation": "Take a real feature request and create a module dependency diagram"}'::jsonb,
    duration = 15
WHERE title = 'Modular Thinking';

-- LESSON 10: Agentic IDEs (Command Centers) - 40+ TOOLS START HERE
UPDATE lessons SET
    content = '<h2>The New Workbench: Agentic IDEs</h2><p>Agentic IDEs are the command centers of Vibe Coding. They integrate AI directly into your development workflow, enabling multi-file editing, context awareness, and autonomous code generation.</p><h3>The Top Agentic IDEs</h3><h4>1. Cursor ($20/month)</h4><p>The current king. Features: Composer (multi-file editing), Cmd+K inline edits, @-mentions for context, .cursorrules support. Best for: Daily driving, production work.</p><h4>2. Windsurf (Free/Pro)</h4><p>Built by Codeium. Features: Cascade (autonomous agent), deep codebase understanding, proactive suggestions. Best for: Large codebase exploration.</p><h4>3. VS Code + GitHub Copilot</h4><p>The mainstream choice. Features: Copilot Chat, inline completions, workspace agents. Best for: Teams already on GitHub.</p><h4>4. Qoder</h4><p>Specializes in structured generation and code quality. Features: Type-aware generation, refactoring patterns. Best for: TypeScript-heavy projects.</p><h4>5. Antigravity</h4><p>Google''s next-gen agentic system. Features: Multi-step task execution, tool use, browser automation. Best for: Complex autonomous workflows.</p><h4>6. Aider (CLI)</h4><p>Terminal-based AI coding. Features: Git integration, works with any LLM, extremely powerful for power users. Best for: Terminal lovers, CI/CD integration.</p><h4>7. JetBrains AI Assistant</h4><p>For IntelliJ users. Features: Deep IDE integration, smart refactoring. Best for: Java/Kotlin developers.</p><h4>8. Zed + AI</h4><p>Fast, multiplayer editor with AI. Features: Real-time collaboration, low latency. Best for: Pair programming with AI.</p><h3>When to Use What</h3><ul><li><strong>Daily Development</strong>: Cursor or Windsurf</li><li><strong>Quick Edits</strong>: VS Code + Copilot</li><li><strong>Power Users</strong>: Aider via terminal</li><li><strong>Autonomous Tasks</strong>: Antigravity</li></ul>',
    summary = 'Agentic IDEs integrate AI directly into your workflow. The top choices are Cursor (best UX), Windsurf (deep codebase understanding), Aider (CLI power), and Antigravity (autonomous tasks).',
    case_studies = '[{"title": "The Multi-File Refactor", "scenario": "A developer needed to rename a component across 47 files with consistent updates.", "analysis": "Cursor Composer allowed selecting all files and describing the change in natural language. The AI understood the relationship between files.", "outcome": "What would have been 2 hours of manual work completed in 3 minutes with zero errors."}]'::jsonb,
    key_takeaways = '["Cursor is the current leader for daily Vibe Coding.", "Aider is the power user choice for terminal-based workflows.", "Antigravity excels at complex autonomous multi-step tasks."]'::jsonb,
    quizzes = '[{"question": "What makes an IDE agentic?", "options": ["Dark mode", "AI integrated into workflow with autonomy", "Cloud sync", "Fast compilation"], "correctAnswer": 1, "explanation": "Agentic IDEs have AI that can take actions, not just suggest."}, {"question": "Which IDE is best for multi-file edits?", "options": ["Notepad", "Cursor with Composer", "Basic VS Code", "Word"], "correctAnswer": 1, "explanation": "Cursor Composer enables coherent multi-file AI edits."}, {"question": "When should you use Aider?", "options": ["GUI preference", "Terminal/CLI power user workflows", "Mobile development", "Design work"], "correctAnswer": 1, "explanation": "Aider is designed for terminal-based AI coding."}, {"question": "What is Antigravity best for?", "options": ["Typing practice", "Complex autonomous multi-step tasks", "Simple edits", "Reading code"], "correctAnswer": 1, "explanation": "Antigravity excels at autonomous task execution."}, {"question": "What is .cursorrules?", "options": ["A game", "Persistent AI configuration for Cursor projects", "A theme", "A plugin"], "correctAnswer": 1, "explanation": ".cursorrules defines project-level AI behavior."}]'::jsonb,
    videos = '[{"title": "Cursor AI Complete Guide", "url": "https://www.youtube.com/embed/uGgCqV7G8_0", "why_this_video": "Comprehensive overview of the leading agentic IDE features."}]'::jsonb,
    playground = '{"objective": "Compare agentic IDE features with a consistent task", "environment": "cursor", "starter_prompt": "Refactor the User component to use React hooks instead of class state", "guided_steps": ["Install Cursor if not already", "Create a sample React class component", "Use Cursor Composer to refactor", "Try the same in VS Code Copilot", "Note the differences in approach", "Test Aider if comfortable with CLI"], "advanced_challenge": "Complete a 20-file refactor using only AI-assisted editing", "failure_mode_experiment": "Try a complex refactor without agentic features and time the difference", "real_world_simulation": "Set up your preferred agentic IDE for your main project"}'::jsonb,
    duration = 20
WHERE title = 'Agentic IDEs (Command Centers)';

-- LESSON 11: UI / Frontend AI - MORE TOOLS
UPDATE lessons SET
    content = '<h2>Pixel Perfect Instantly: Frontend AI Tools</h2><p>Frontend development is essentially solved. These tools generate production-quality UI from descriptions, screenshots, or designs.</p><h3>The Frontend AI Toolkit</h3><h4>UI GENERATION</h4><p><strong>1. v0.dev (Vercel)</strong> - Generative UI from prompts. Copy-paste React/Tailwind code. The gold standard.</p><p><strong>2. Bolt.new (StackBlitz)</strong> - Full browser-based dev environments. Generate, edit, deploy without local setup.</p><p><strong>3. Lovable (formerly GPT-Engineer)</strong> - Full app generation from descriptions. Great for MVPs.</p><p><strong>4. Create.xyz</strong> - Component-driven generation. Connect data sources easily.</p><p><strong>5. Screenshot-to-Code</strong> - Literal magic. Upload a screenshot, get code. Supports React, Vue, HTML.</p><p><strong>6. Galileo AI</strong> - AI design tool that generates Figma designs.</p><p><strong>7. Uizard</strong> - Sketch to digital design, then to code.</p><h4>DESIGN SYSTEMS</h4><p><strong>8. Shadcn/ui</strong> - Copy-paste components. AI understands these patterns well.</p><p><strong>9. Tailwind CSS</strong> - Utility-first CSS AI generates flawlessly.</p><p><strong>10. Radix UI</strong> - Accessible components for AI to build upon.</p><p><strong>11. Chakra UI</strong> - Component library with great AI compatibility.</p><h4>WORKFLOW</h4><p>Screenshot site you like → Screenshot-to-Code → Paste into v0.dev → Refine → Paste into Cursor → Polish. Production UI in minutes.</p>',
    summary = 'Frontend AI tools like v0.dev, Bolt.new, and Screenshot-to-Code have essentially solved UI generation. The workflow is: describe → generate → refine → ship.',
    case_studies = '[{"title": "The Landing Page Speed Run", "scenario": "A startup needed a landing page in 2 hours for a demo. No designer available.", "analysis": "Using v0.dev with specific prompts, they generated sections. Screenshot-to-Code replicated a competitor''s layout they admired.", "outcome": "Complete, polished landing page in 90 minutes. The investor thought they had a design team."}]'::jsonb,
    key_takeaways = '["v0.dev is the gold standard for AI-generated React/Tailwind UI.", "Screenshot-to-Code literally converts images to working code.", "Combine tools: Screenshot → v0 → Cursor for the fastest workflow."]'::jsonb,
    quizzes = '[{"question": "What is v0.dev best for?", "options": ["Backend APIs", "Generative UI from prompts", "Database design", "Testing"], "correctAnswer": 1, "explanation": "v0.dev generates React/Tailwind UI from natural language."}, {"question": "What does Screenshot-to-Code do?", "options": ["Takes screenshots", "Converts images of UI to code", "Compresses images", "Shares screens"], "correctAnswer": 1, "explanation": "It literally converts screenshots of websites into working code."}, {"question": "What is Bolt.new?", "options": ["A game", "Browser-based full dev environment", "An email tool", "A database"], "correctAnswer": 1, "explanation": "Bolt.new provides full development environments in the browser."}, {"question": "Why is Tailwind preferred by AI?", "options": ["It''s free", "Utility-first patterns are easy to generate", "It''s newer", "It''s owned by AI companies"], "correctAnswer": 1, "explanation": "Tailwind''s utility classes are predictable patterns AI generates well."}, {"question": "What is the optimal frontend AI workflow?", "options": ["Code everything manually", "Screenshot → v0 → Cursor → Polish", "Only use one tool", "Avoid AI for UI"], "correctAnswer": 1, "explanation": "Combining Screenshot-to-Code, v0.dev, and Cursor creates the fastest workflow."}]'::jsonb,
    videos = '[{"title": "v0.dev Complete Tutorial", "url": "https://www.youtube.com/embed/sFkS-XJb6jo", "why_this_video": "Learn to generate production-quality UI with v0.dev."}]'::jsonb,
    playground = '{"objective": "Generate a complete UI using the frontend AI stack", "environment": "cursor", "starter_prompt": "Create a pricing page with 3 tiers: Free, Pro ($10/mo), Enterprise (custom)", "guided_steps": ["Go to v0.dev and input the prompt", "Generate and iterate on the design", "Copy the code to Cursor", "Find a pricing page you admire online", "Use Screenshot-to-Code to replicate it", "Merge the best elements"], "advanced_challenge": "Create a complete marketing site (Home, About, Pricing, Contact) in under 2 hours", "failure_mode_experiment": "Try to describe a complex UI poorly and observe the output", "real_world_simulation": "Replicate your favorite SaaS landing page using only AI tools"}'::jsonb,
    duration = 20
WHERE title = 'UI / Frontend AI';

-- LESSON 12: Full-Stack & Auto Builders - MORE TOOLS
UPDATE lessons SET
    content = '<h2>One Prompt, One App: Full-Stack Auto Builders</h2><p>These tools build complete applications from descriptions. Backend, frontend, database, deployment—all from natural language.</p><h3>The Auto Builder Toolkit</h3><h4>FULL-STACK GENERATORS</h4><p><strong>1. Replit Agent</strong> - The pioneer. Builds valid, deployable apps in the browser. From prompt to production.</p><p><strong>2. Bolt.new</strong> - StackBlitz''s entry. Full environments, multiple frameworks.</p><p><strong>3. Lovable</strong> - End-to-end app generation with Supabase integration.</p><p><strong>4. Create.xyz</strong> - Component-first approach with data connections.</p><p><strong>5. Databutton</strong> - AI-native app builder with Python backend.</p><h4>NO-CODE + AI</h4><p><strong>6. Softr</strong> - Build apps on top of Airtable or Google Sheets.</p><p><strong>7. Glide</strong> - Mobile apps from spreadsheets.</p><p><strong>8. Bubble + AI</strong> - Visual development with AI assistance.</p><p><strong>9. Retool + AI</strong> - Internal tools with AI generation.</p><p><strong>10. Airplane</strong> - Developer-first internal tools.</p><h4>SPECIALIZED BUILDERS</h4><p><strong>11. Streamlit</strong> - Data apps in Python with AI generation.</p><p><strong>12. Gradio</strong> - ML model interfaces.</p><p><strong>13. Anvil</strong> - Full-stack Python apps.</p><h4>WHEN TO USE</h4><ul><li><strong>MVPs & Prototypes</strong>: Replit Agent, Lovable</li><li><strong>Internal Tools</strong>: Retool, Airplane</li><li><strong>Data Apps</strong>: Streamlit, Databutton</li><li><strong>Scale/Production</strong>: Graduate to Code (Cursor)</li></ul>',
    summary = 'Auto builders like Replit Agent and Lovable generate complete applications from prompts. Use them for MVPs and prototypes, then graduate to code for scale.',
    case_studies = '[{"title": "The Weekend Startup", "scenario": "A founder had an idea Friday night for a waitlist tool. No coding experience.", "analysis": "Using Replit Agent, they described the features conversationally. The AI built authentication, a waitlist form, admin dashboard, and email notifications.", "outcome": "Launched Sunday, 500 signups Monday. The real validation happened before any custom code was written."}]'::jsonb,
    key_takeaways = '["Replit Agent pioneered prompt-to-production app building.", "Use auto builders for MVPs, graduate to Cursor for scale.", "Internal tools are the hidden economy - Retool dominates."]'::jsonb,
    quizzes = '[{"question": "What does Replit Agent do?", "options": ["Edit text", "Build complete apps from prompts", "Compress files", "Test code"], "correctAnswer": 1, "explanation": "Replit Agent builds full applications from natural language descriptions."}, {"question": "When should you use auto builders?", "options": ["Production at scale", "MVPs and prototypes", "Never", "Only for games"], "correctAnswer": 1, "explanation": "Auto builders excel at rapid prototyping and validation."}, {"question": "What is Retool best for?", "options": ["Mobile games", "Internal tools and admin panels", "Social media", "Video editing"], "correctAnswer": 1, "explanation": "Retool specializes in internal business tools."}, {"question": "Why graduate from auto builders?", "options": ["They are expensive", "More control and customization needed at scale", "They break often", "No reason"], "correctAnswer": 1, "explanation": "Auto builders trade control for speed - at scale you need control."}, {"question": "What is Streamlit used for?", "options": ["Streaming video", "Python data apps and dashboards", "Music", "Gaming"], "correctAnswer": 1, "explanation": "Streamlit converts Python scripts into interactive data apps."}]'::jsonb,
    videos = '[{"title": "Replit Agent Full Demo", "url": "https://www.youtube.com/embed/yO7-wV7pPZQ", "why_this_video": "See Replit Agent build a complete app from scratch live."}]'::jsonb,
    playground = '{"objective": "Build a complete app using only auto builders", "environment": "cursor", "starter_prompt": "Create a simple feedback collection app with: form for feedback, admin view for responses, email notification on new feedback", "guided_steps": ["Open Replit Agent", "Describe the app conversationally", "Let it build the first version", "Request refinements", "Test the deployed app", "Export and examine the code"], "advanced_challenge": "Build and deploy a SaaS MVP with payments in 4 hours", "failure_mode_experiment": "Request something beyond auto builder capabilities and see how it degrades", "real_world_simulation": "Validate a real business idea with an auto-built MVP before writing custom code"}'::jsonb,
    duration = 20
WHERE title = 'Full-Stack & Auto Builders';

-- LESSON 13: Backend, Logic & Data - MORE TOOLS
UPDATE lessons SET
    content = '<h2>The Backbone: Backend AI Tools</h2><p>Data layer and business logic tools that AI understands and generates well.</p><h3>The Backend Toolkit</h3><h4>DATABASES & BaaS</h4><p><strong>1. Supabase</strong> - The Postgres standard. Auth, Realtime, Vector search, Storage. Open source Firebase alternative.</p><p><strong>2. Firebase</strong> - Google''s BaaS. Great for mobile, real-time sync.</p><p><strong>3. PlanetScale</strong> - Serverless MySQL with branching.</p><p><strong>4. Neon</strong> - Serverless Postgres with branching.</p><p><strong>5. Turso</strong> - Edge SQLite for global low-latency.</p><p><strong>6. Upstash</strong> - Serverless Redis and Kafka.</p><h4>ORMS & DATA ACCESS</h4><p><strong>7. Prisma</strong> - Type-safe ORM. AI LOVES Prisma because of its schema.</p><p><strong>8. Drizzle</strong> - Lightweight TypeScript ORM.</p><p><strong>9. Kysely</strong> - Type-safe SQL query builder.</p><h4>API BUILDERS</h4><p><strong>10. Xano</strong> - No-code API builder.</p><p><strong>11. BuildShip</strong> - Visual backend logic.</p><p><strong>12. Supabase Edge Functions</strong> - Deno at the edge.</p><p><strong>13. Vercel Functions</strong> - Serverless Node/Edge.</p><p><strong>14. Cloudflare Workers</strong> - Edge compute.</p><h4>AUTHENTICATION</h4><p><strong>15. Clerk</strong> - Drop-in auth with UI.</p><p><strong>16. Auth0</strong> - Enterprise auth.</p><p><strong>17. Supabase Auth</strong> - Built-in to Supabase.</p><p><strong>18. Lucia Auth</strong> - Flexible auth library.</p><h4>RECOMMENDATION</h4><p>Stack: <strong>Supabase + Prisma + TypeScript</strong>. Maximum type safety = best AI output.</p>',
    summary = 'Supabase + Prisma is the recommended stack for Vibe Coding. Strong types give AI maximum understanding of your data layer.',
    case_studies = '[{"title": "The Type-Safe Migration", "scenario": "A team switched from raw SQL to Prisma. Their AI code generation accuracy jumped.", "analysis": "Prisma''s schema provides explicit type information that AI uses to generate correct queries.", "outcome": "Query generation accuracy went from 70% to 95%. Debugging time dropped dramatically."}]'::jsonb,
    key_takeaways = '["Supabase + Prisma is the gold standard for Vibe Coding backends.", "Strong types = better AI output. TypeScript strict mode always.", "Edge functions (Supabase, Vercel, Cloudflare) enable global performance."]'::jsonb,
    quizzes = '[{"question": "Why is Prisma recommended for Vibe Coding?", "options": ["It is free", "Type-safe schema helps AI understand data", "It is fast", "It is new"], "correctAnswer": 1, "explanation": "Prisma''s explicit types give AI clear context for generation."}, {"question": "What is Supabase?", "options": ["A game", "Open source Firebase alternative with Postgres", "A design tool", "A compiler"], "correctAnswer": 1, "explanation": "Supabase provides Postgres, Auth, Realtime, and more as a service."}, {"question": "What are edge functions?", "options": ["Sharp corners", "Serverless compute distributed globally", "Database indexes", "CSS properties"], "correctAnswer": 1, "explanation": "Edge functions run code close to users globally."}, {"question": "Which auth solution is built into Supabase?", "options": ["Auth0", "Clerk", "Supabase Auth", "Firebase Auth"], "correctAnswer": 2, "explanation": "Supabase includes built-in authentication."}, {"question": "What is Drizzle?", "options": ["Weather", "Lightweight TypeScript ORM", "A database", "A testing tool"], "correctAnswer": 1, "explanation": "Drizzle is a lightweight alternative to Prisma."}]'::jsonb,
    videos = '[{"title": "Supabase Complete Tutorial", "url": "https://www.youtube.com/embed/1PHk_g8gWbU", "why_this_video": "Full walkthrough of Supabase for modern backend development."}]'::jsonb,
    playground = '{"objective": "Set up a type-safe backend with Supabase and Prisma", "environment": "cursor", "starter_prompt": "Create a Prisma schema for a blog with Users, Posts, and Comments", "guided_steps": ["Create a new Supabase project", "Generate a Prisma schema from existing tables", "Add a new model via Prisma", "Push changes to Supabase", "Generate AI CRUD operations using the schema", "Test type safety - try invalid queries"], "advanced_challenge": "Build a complete data layer with RLS policies using only AI", "failure_mode_experiment": "Use raw SQL without types and compare AI accuracy", "real_world_simulation": "Design and implement a database schema for an actual project"}'::jsonb,
    duration = 20
WHERE title = 'Backend, Logic & Data';

-- LESSON 14: AI Agents & Orchestration - MORE TOOLS
UPDATE lessons SET
    content = '<h2>The Autonomy Layer: AI Agent Tools</h2><p>Tools for building and orchestrating AI agents that can take actions, use tools, and complete multi-step tasks.</p><h3>The Agent Toolkit</h3><h4>AGENT PLATFORMS</h4><p><strong>1. Antigravity</strong> - Google''s agentic system. This course runs on it.</p><p><strong>2. Devin (Cognition)</strong> - The first AI software engineer. Autonomous coding agent.</p><p><strong>3. SWE-Agent</strong> - Open source AI software engineer.</p><p><strong>4. OpenDevin</strong> - Open source Devin alternative.</p><p><strong>5. AutoGPT</strong> - The original autonomous agent experiment.</p><h4>AGENT FRAMEWORKS</h4><p><strong>6. LangGraph</strong> - Stateful agent workflows. Production-ready.</p><p><strong>7. LangChain</strong> - LLM application framework.</p><p><strong>8. CrewAI</strong> - Multi-agent teams with roles.</p><p><strong>9. AutoGen (Microsoft)</strong> - Multi-agent conversations.</p><p><strong>10. Semantic Kernel</strong> - Microsoft''s AI orchestration.</p><h4>TOOL USE & RAG</h4><p><strong>11. LlamaIndex</strong> - Data framework for LLM apps.</p><p><strong>12. Chroma</strong> - Vector database for embeddings.</p><p><strong>13. Pinecone</strong> - Managed vector database.</p><p><strong>14. Weaviate</strong> - Vector search engine.</p><p><strong>15. Qdrant</strong> - Vector similarity search.</p><h4>WORKFLOW AUTOMATION</h4><p><strong>16. n8n</strong> - Open source workflow automation.</p><p><strong>17. Make (Integromat)</strong> - Visual automation.</p><p><strong>18. Zapier + AI</strong> - AI-powered workflows.</p><h4>THE FUTURE</h4><p>You will manage a ''Crew'' of agents (QA, Dev, DevOps) rather than writing code yourself. Each agent has a role.</p>',
    summary = 'AI agents are moving from experiments to production. LangGraph for workflows, CrewAI for teams, vector databases for memory.',
    case_studies = '[{"title": "The Agent QA Team", "scenario": "A startup replaced manual QA with a CrewAI crew: Planner, Tester, Reporter.", "analysis": "The agent team autonomously wrote and ran tests, reported bugs with reproduction steps.", "outcome": "QA coverage increased 10x while reducing QA headcount. Bugs caught earlier in cycle."}]'::jsonb,
    key_takeaways = '["LangGraph is production-ready for stateful agent workflows.", "CrewAI enables multi-agent teams with specialized roles.", "Vector databases (Chroma, Pinecone) give agents long-term memory."]'::jsonb,
    quizzes = '[{"question": "What is Devin?", "options": ["A database", "First AI software engineer agent", "A programming language", "A cloud provider"], "correctAnswer": 1, "explanation": "Devin by Cognition is the first AI software engineer capable of autonomous coding."}, {"question": "What does LangGraph provide?", "options": ["Graphs", "Stateful agent workflow orchestration", "Database queries", "UI components"], "correctAnswer": 1, "explanation": "LangGraph enables building complex, stateful AI agent workflows."}, {"question": "What is CrewAI for?", "options": ["Hiring", "Multi-agent teams with specialized roles", "Video calls", "Project management"], "correctAnswer": 1, "explanation": "CrewAI lets you define teams of agents with different roles and goals."}, {"question": "Why do agents need vector databases?", "options": ["For colors", "Long-term memory and retrieval", "Faster math", "Better graphics"], "correctAnswer": 1, "explanation": "Vector databases store embeddings that give agents persistent memory."}, {"question": "What is the future of software teams?", "options": ["More developers", "Managing crews of AI agents", "No technology", "Only manual work"], "correctAnswer": 1, "explanation": "The future involves orchestrating specialized AI agents rather than writing all code."}]'::jsonb,
    videos = '[{"title": "Building AI Agents with LangGraph", "url": "https://www.youtube.com/embed/Sal7cz3T40M", "why_this_video": "Production patterns for building autonomous AI agents."}]'::jsonb,
    playground = '{"objective": "Build a simple multi-step agent workflow", "environment": "cursor", "starter_prompt": "Create an agent that researches a topic, summarizes findings, and writes a report", "guided_steps": ["Define the agent roles: Researcher, Analyzer, Writer", "Set up a simple LangGraph workflow", "Connect to an LLM API", "Add tool use (web search or file read)", "Run the multi-step workflow", "Examine how agents hand off to each other"], "advanced_challenge": "Build a QA agent crew that can test your application", "failure_mode_experiment": "Create an agent without clear goals and observe infinite loops", "real_world_simulation": "Automate a real repetitive task with an agent workflow"}'::jsonb,
    duration = 20
WHERE title = 'AI Agents & Orchestration';

-- Verify updates
SELECT title, LENGTH(content) as content_length, 
       jsonb_array_length(quizzes) as quiz_count,
       CASE WHEN playground IS NOT NULL THEN 'Yes' ELSE 'No' END as has_playground
FROM lessons 
WHERE title IN (
    'System Prompts vs User Prompts',
    'Modular Thinking', 
    'Agentic IDEs (Command Centers)',
    'UI / Frontend AI',
    'Full-Stack & Auto Builders',
    'Backend, Logic & Data',
    'AI Agents & Orchestration'
);
