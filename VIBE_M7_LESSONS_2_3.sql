-- ==========================================
-- VIBE CODING MODULE 7 - LESSONS 2-3 (FINAL)
-- Cost, Performance & When NOT to Use AI
-- Compact HTML formatting
-- ==========================================

DO $$
DECLARE
    v_course_id UUID;
    v_module_id UUID;
BEGIN
    SELECT id INTO v_course_id FROM courses WHERE title ILIKE '%Vibe Coding%' LIMIT 1;
    IF v_course_id IS NULL THEN RAISE EXCEPTION 'Vibe Coding course not found'; END IF;
    
    SELECT id INTO v_module_id FROM modules WHERE course_id = v_course_id AND ordering = 7 LIMIT 1;
    IF v_module_id IS NULL THEN RAISE EXCEPTION 'Module 7 not found'; END IF;
    
    RAISE NOTICE 'ðŸ“š Expanding Vibe Coding Module 7 (Lessons 2-3 FINAL)...';
    
    -- LESSON 23: Cost, Performance & Sanity
    UPDATE lessons SET content = '<div class="lesson-content"><h2>Cost, Performance & Sanity</h2><h3>Sustainable Vibe Coding</h3><p>Vibe Coding is powerful, but it''s important to use it sustainably. This lesson covers managing AI costs, maintaining good performance, and keeping your sanity while building with AI. Learn how to be productive without burning out or breaking the bank.</p><h3>Managing AI Costs</h3><h4>Understanding Pricing Models</h4><p>AI services charge based on: Tokens (input + output). Model used (GPT-4 costs more than GPT-3.5). Features (image generation, function calling). API calls (some have per-request fees).</p><p>Example costs (approximate): ChatGPT Plus: $20/month unlimited. GPT-4 API: $0.03 per 1K input tokens, $0.06 per 1K output tokens. GPT-3.5 API: $0.001 per 1K tokens. Claude API: Similar to GPT-4. GitHub Copilot: $10/month. Cursor Pro: $20/month.</p><h4>Cost Optimization Strategies</h4><p><strong>Strategy 1: Use the Right Model</strong><br>Don''t use GPT-4 for everything. Simple tasks: Use GPT-3.5 or free tools. Complex reasoning: Use GPT-4. Code completion: Use Copilot or Cursor. Content generation: Use Claude for long-form.</p><p><strong>Strategy 2: Optimize Prompts</strong><br>Shorter prompts = lower costs. Be concise but clear. Remove unnecessary context. Use system prompts to avoid repeating instructions. Reference previous responses instead of re-explaining.</p><p><strong>Strategy 3: Cache and Reuse</strong><br>Don''t regenerate the same code repeatedly. Save good responses. Build a personal code library. Reuse patterns across projects.</p><p><strong>Strategy 4: Batch Operations</strong><br>Instead of: 10 separate prompts for 10 similar components. Do: One prompt to generate all 10 at once.</p><p><strong>Strategy 5: Use Local Models</strong><br>For sensitive or repetitive tasks: Run models locally (Ollama, LM Studio). No per-token costs. Privacy benefits. One-time setup cost.</p><h4>Tracking Your Spend</h4><p>Monitor costs: Set up billing alerts. Review usage monthly. Track costs per project. Identify expensive patterns. Adjust usage accordingly.</p><h3>Performance Considerations</h3><h4>AI Response Time</h4><p>AI isn''t instant: GPT-4: 10-30 seconds for complex prompts. GPT-3.5: 2-5 seconds. Local models: Varies by hardware.</p><p>Optimize workflow: Start AI tasks early. Work on other things while waiting. Batch requests when possible. Use faster models for iteration.</p><h4>Code Performance</h4><p>AI-generated code may not be optimized: Review for performance issues. Profile and benchmark. Optimize hot paths. Add caching where appropriate. Use verification prompts for performance.</p><p>Prompt: "Review this code for performance. Identify bottlenecks and suggest optimizations."</p><h4>Application Performance</h4><p>Don''t sacrifice app performance for development speed: Test on real devices. Monitor load times. Check bundle sizes. Optimize images and assets. Implement lazy loading.</p><h3>Maintaining Sanity</h3><h4>Avoiding AI Dependency</h4><p>Don''t become helpless without AI: Understand the code AI generates. Learn the concepts, not just the syntax. Practice problem-solving without AI sometimes. Maintain fundamental programming knowledge.</p><h4>Managing Frustration</h4><p>AI isn''t perfect and will frustrate you: Take breaks when stuck. Try different prompts or tools. Ask for help in communities. Remember: AI is a tool, not magic. Some problems need human creativity.</p><h4>Preventing Burnout</h4><p>Vibe Coding can be addictively productive: Set boundaries (work hours, project scope). Take regular breaks. Don''t try to build everything at once. Celebrate small wins. Maintain work-life balance.</p><h4>Decision Fatigue</h4><p>Too many AI suggestions can be overwhelming: Limit options (ask for 1-2 approaches, not 10). Make decisions quickly. Trust your instincts. Use frameworks for common decisions.</p><h3>Quality vs Speed Trade-offs</h3><h4>When to Go Fast</h4><p>Prototypes and MVPs. Internal tools. Learning projects. Proof of concepts. Non-critical features.</p><p>Approach: Use fastest tools (Bolt.new). Accept "good enough". Iterate quickly. Don''t over-engineer.</p><h4>When to Go Slow</h4><p>Production applications. Security-critical features. Payment processing. Data handling. Core business logic.</p><p>Approach: Use verification prompts. Write comprehensive tests. Manual code review. Security audits. Performance testing.</p><h3>Sustainable Development Practices</h3><h4>The 80/20 Rule</h4><p>AI handles 80% of routine work. You focus on the 20% that requires human judgment: Architecture decisions. Business logic. User experience. Edge cases. Optimization.</p><h4>Continuous Learning</h4><p>Don''t stop learning because AI can code: Study AI-generated code to learn patterns. Understand why solutions work. Learn new concepts and technologies. Stay current with best practices. Develop problem-solving skills.</p><h4>Building a Knowledge Base</h4><p>Create your own resources: Document patterns that work. Save effective prompts. Build component libraries. Create templates. Share learnings with others.</p><h3>Team Collaboration with AI</h3><h4>Sharing AI Resources</h4><p>Team accounts for AI tools. Shared prompt libraries. Code review guidelines for AI code. Best practices documentation. Regular knowledge sharing.</p><h4>Consistency Across Team</h4><p>Establish standards: Coding conventions. Prompt templates. Verification checklists. Review processes. Quality gates.</p><h3>Long-Term Sustainability</h3><h4>Avoiding Technical Debt</h4><p>AI can generate code fast, but: Review for maintainability. Refactor regularly. Add documentation. Write tests. Don''t accumulate "AI debt".</p><h4>Future-Proofing</h4><p>AI tools evolve rapidly: Don''t over-depend on specific tools. Learn transferable skills. Use standard technologies. Document your processes. Stay adaptable.</p><h3>Mental Models for Sustainable Vibe Coding</h3><p><strong>Model 1: AI as Pair Programmer</strong><br>You''re the senior developer, AI is the junior. You make decisions, AI implements. You review, AI adjusts.</p><p><strong>Model 2: AI as Force Multiplier</strong><br>AI doesn''t replace skills, it amplifies them. Better prompts = better results. More knowledge = better use of AI.</p><p><strong>Model 3: AI as Tool, Not Crutch</strong><br>Use AI to go faster, not to avoid learning. Understand what you''re building. Maintain agency over your code.</p><h3>Warning Signs</h3><p>Watch for these red flags: Accepting AI code without understanding it. Unable to debug without AI help. Spending more time prompting than thinking. Generating code faster than you can review it. Feeling lost when AI doesn''t work. Ignoring performance and quality for speed.</p><h3>Healthy Vibe Coding Habits</h3><p>1. Start each session with clear goals. 2. Review all AI-generated code. 3. Test thoroughly before moving on. 4. Take breaks every 90 minutes. 5. Document important decisions. 6. Refactor regularly. 7. Learn from the code AI generates. 8. Maintain a sustainable pace. 9. Celebrate progress. 10. Ask for help when stuck.</p><h3>Key Takeaways</h3><ul><li>Manage costs by <strong>using appropriate models</strong> and optimizing prompts</li><li>Monitor <strong>both AI costs and application performance</strong></li><li>Maintain <strong>sanity</strong> by setting boundaries and avoiding AI dependency</li><li>Balance <strong>speed and quality</strong> based on project needs</li><li>Practice <strong>sustainable development</strong>: learn continuously, build knowledge, avoid debt</li><li>Use AI as a <strong>tool and force multiplier</strong>, not a crutch</li><li>Watch for <strong>warning signs</strong> of unhealthy AI usage</li><li>Develop <strong>healthy habits</strong> for long-term success</li></ul><p>In the next lesson, we''ll explore when NOT to use AIâ€”understanding the limitations and alternatives.</p></div>'
    WHERE module_id = v_module_id AND ordering = 2;
    RAISE NOTICE 'âœ… Lesson 23 Complete';
    
    -- LESSON 24: When NOT to Use AI
    UPDATE lessons SET content = '<div class="lesson-content"><h2>When NOT to Use AI</h2><h3>Knowing the Limits</h3><p>AI is powerful, but it''s not the right tool for every situation. Knowing when NOT to use AI is just as important as knowing when to use it. This lesson teaches you to recognize scenarios where traditional development, human expertise, or other approaches are better choices.</p><h3>Understanding AI Limitations</h3><p>AI struggles with: Novel problems with no training data. Domain-specific expertise (legal, medical, financial). Real-time constraints. Hardware-specific optimizations. Highly regulated industries. Complex business logic unique to your domain. Ethical decision-making.</p><h3>When Human Expertise Is Essential</h3><h4>1. Architecture Decisions</h4><p>AI can suggest architectures, but humans should decide: System architecture for large applications. Technology stack selection. Scalability strategies. Security architecture. Data architecture.</p><p>Why: These decisions have long-term consequences. They require understanding business context. They involve trade-offs AI can''t fully evaluate.</p><h4>2. Business Logic</h4><p>Complex, domain-specific business rules: Tax calculations for specific jurisdictions. Insurance underwriting logic. Healthcare treatment protocols. Financial compliance rules. Legal contract terms.</p><p>Why: AI doesn''t understand your specific business context. Errors can have serious legal/financial consequences. Domain experts should validate all logic.</p><h4>3. Ethical Decisions</h4><p>Situations involving ethics or values: Content moderation policies. User privacy decisions. Algorithmic fairness. Data retention policies. Accessibility priorities.</p><p>Why: These require human judgment and values. AI can reflect biases from training data. Accountability requires human decision-making.</p><h3>When Traditional Development Is Better</h3><h4>1. Performance-Critical Code</h4><p>When every millisecond matters: High-frequency trading systems. Real-time video processing. Game engines. Embedded systems. Database query optimization.</p><p>Approach: Write and optimize by hand. Use profiling tools. Benchmark extensively. AI can assist, but expert optimization is needed.</p><h4>2. Security-Critical Systems</h4><p>When security is paramount: Cryptographic implementations. Authentication systems. Payment processing. Access control. Security auditing.</p><p>Approach: Use proven libraries. Follow security standards (OWASP). Get security audits. AI can help, but don''t rely solely on it.</p><h4>3. Highly Regulated Code</h4><p>Industries with strict compliance: Medical devices (FDA approval). Financial systems (SOX compliance). Aviation software. Nuclear systems. Government contracts.</p><p>Approach: Follow certification processes. Use approved methods. Extensive documentation. Formal verification. AI-generated code may not meet standards.</p><h3>When AI Adds More Complexity</h3><h4>1. Simple Tasks</h4><p>Sometimes writing code is faster than prompting: Simple utility functions. Basic CRUD operations. Standard configurations. Trivial bug fixes.</p><p>If it takes longer to explain than to code, just code it.</p><h4>2. Well-Understood Patterns</h4><p>When you know exactly what to do: Implementing a pattern you''ve done 100 times. Copying and adapting existing code. Following a clear tutorial. Using a familiar library.</p><p>Your expertise is faster than AI here.</p><h4>3. Debugging Specific Issues</h4><p>Sometimes traditional debugging is more effective: Stepping through code with a debugger. Examining stack traces. Checking network requests. Inspecting database queries.</p><p>Use debugging tools first, AI as backup.</p><h3>When AI Can''t Help</h3><h4>1. Understanding User Needs</h4><p>AI can''t replace user research: Conducting user interviews. Observing user behavior. Understanding pain points. Defining requirements. Prioritizing features.</p><p>Talk to users, don''t ask AI to guess.</p><h4>2. Creative Problem Solving</h4><p>Some problems need human creativity: Innovative UX solutions. Novel algorithms. Unique business models. Creative marketing. Original design.</p><p>AI can assist, but breakthrough ideas come from humans.</p><h4>3. Contextual Decision-Making</h4><p>Decisions requiring full context: Prioritizing technical debt vs features. Choosing between competing approaches. Deciding when to refactor. Balancing speed vs quality. Managing team dynamics.</p><p>You have context AI doesn''t.</p><h3>Red Flags: Don''t Use AI For</h3><p><strong>Medical Advice:</strong> AI shouldn''t diagnose or prescribe. Consult medical professionals.</p><p><strong>Legal Advice:</strong> AI can''t replace lawyers. Get proper legal counsel.</p><p><strong>Financial Advice:</strong> Investment decisions need qualified advisors.</p><p><strong>Safety-Critical Systems:</strong> Lives depend on it. Use certified processes.</p><p><strong>Replacing Human Judgment:</strong> Final decisions should be human-made.</p><h3>Hybrid Approaches: Best of Both</h3><h4>AI for Scaffolding, Human for Refinement</h4><p>AI generates initial structure. Human refines and optimizes. Human adds domain expertise. Human makes final decisions.</p><h4>AI for Research, Human for Implementation</h4><p>AI researches approaches. AI suggests options. Human evaluates and chooses. Human implements with understanding.</p><h4>AI for Routine, Human for Critical</h4><p>AI handles boilerplate. AI generates tests. Human writes critical logic. Human reviews everything.</p><h3>Knowing When to Stop Using AI</h3><p>Stop using AI when: You''ve spent more time prompting than it would take to code. AI keeps generating wrong solutions. The problem is too specific to your domain. You need deep optimization. Compliance requires human certification. You''re using AI to avoid learning. The task is simpler than explaining it.</p><h3>Alternatives to AI Coding</h3><h4>Traditional Resources</h4><p>Documentation (official docs are authoritative). Stack Overflow (community knowledge). GitHub (real code examples). Tutorials (structured learning). Books (deep understanding). Courses (comprehensive education).</p><h4>Human Resources</h4><p>Mentors (personalized guidance). Code review (expert feedback). Pair programming (collaborative learning). Communities (shared experiences). Consultants (specialized expertise).</p><h4>Tools and Frameworks</h4><p>Established libraries (battle-tested). Frameworks (best practices built-in). Code generators (specific to framework). Templates (proven patterns). Boilerplates (solid foundations).</p><h3>The Balanced Approach</h3><p>Use AI for: Boilerplate and repetitive code. Learning new concepts. Rapid prototyping. Code explanations. Generating tests. Exploring options.</p><p>Don''t use AI for: Final architecture decisions. Security-critical code (without review). Compliance-required code. Ethical decisions. Replacing domain expertise. Avoiding learning.</p><h3>Building Judgment</h3><p>Develop intuition for when to use AI: Start with AI for most tasks. Notice when it''s not helping. Learn the patterns of AI''s strengths/weaknesses. Develop rules of thumb. Trust your experience.</p><h3>Future Considerations</h3><p>As AI improves: Some limitations will disappear. New use cases will emerge. But human judgment will remain essential. Critical thinking will be more valuable. Domain expertise will matter more.</p><h3>Key Takeaways</h3><ul><li>AI has <strong>clear limitations</strong>: novel problems, domain expertise, ethical decisions</li><li><strong>Human expertise is essential</strong> for architecture, business logic, ethics</li><li><strong>Traditional development is better</strong> for performance-critical, security-critical, regulated code</li><li>Don''t use AI for <strong>simple tasks</strong> where coding is faster than prompting</li><li>Never use AI for <strong>medical, legal, or financial advice</strong></li><li>Use <strong>hybrid approaches</strong>: AI for scaffolding, humans for refinement</li><li>Develop <strong>judgment</strong> for when AI helps vs hinders</li><li><strong>Balance AI with traditional resources</strong> and human expertise</li></ul><p>You''ve completed Module 7! You now understand advanced Vibe Coding: verification, sustainability, and limitations. In Module 8, we''ll explore applications, career opportunities, and the future of software development.</p></div>'
    WHERE module_id = v_module_id AND ordering = 3;
    RAISE NOTICE 'âœ… Lesson 24 Complete';
    
    RAISE NOTICE 'ðŸŽ‰ MODULE 7 COMPLETE! All 3 lessons done!';
    
END $$;
