-- ==========================================
-- PROMPT ENGINEERING MODULE 2 - LESSONS 5-6 (FINAL - COMPLETE MODULE 2)
-- Core Techniques & Orchestration
-- ~1200 words each, compact HTML
-- ==========================================

-- LESSON 5: Context Layering (ID: ca5cd4e9-f050-4a5c-8b8e-d6e2e931d2a8)
UPDATE lessons SET content = '<div class="lesson-content"><h2>Context Layering</h2><h3>Managing Complex Information</h3><p>Context layering is a technique for organizing and presenting complex information to AI in digestible layers. Instead of dumping all information at once, you build context progressively. This lesson teaches you how to layer context effectively.</p><h3>What Is Context Layering?</h3><p>Context layering means providing information in organized layers from general to specific, from essential to optional, from simple to complex, and from stable to variable. Each layer builds on the previous one.</p><h3>Why Layer Context?</h3><p>Layering helps AI process information better, prevents information overload, maintains focus on priorities, allows for progressive refinement, makes prompts more maintainable, and enables reuse of base layers.</p><h3>The Three-Layer Model</h3><p>Layer 1 - Foundation: Permanent context that rarely changes (role, domain, core principles). Layer 2 - Situational: Context for this specific scenario (audience, goals, constraints). Layer 3 - Tactical: Immediate task details (specific requirements, current input).</p><h3>Layer 1: Foundation Layer</h3><p>The foundation layer establishes the base context. Include: Role and expertise, domain and industry, core principles and values, standard constraints, quality criteria. This layer is reusable across many prompts. Example: You are an expert technical writer for enterprise software. You write for IT professionals and decision makers. Your writing is clear, concise, and technically accurate.</p><h3>Layer 2: Situational Layer</h3><p>The situational layer adds scenario-specific context. Include: Current project or initiative, specific audience for this task, goals and objectives, relevant background, situational constraints. This layer changes per project or campaign. Example: We are launching a new security feature for our cloud platform. Target audience is CISOs and security teams at Fortune 500 companies. Goal is to communicate value and drive adoption.</p><h3>Layer 3: Tactical Layer</h3><p>The tactical layer provides immediate task details. Include: Specific task to perform, input data or content, format requirements, immediate constraints, success criteria for this output. This layer changes for each prompt. Example: Write a 300-word product brief about our new encryption feature. Focus on compliance benefits. Use bullet points for key features. Due today for review.</p><h3>Implementing Context Layers</h3><p>Method 1 - System Prompts: Use system prompts for Layer 1 (foundation). Add Layers 2 and 3 in user prompts. Works well with API usage. Method 2 - Conversation History: Establish Layer 1 at conversation start. Add Layer 2 when starting new topic. Use Layer 3 for each specific request. Method 3 - Prompt Templates: Create templates with Layer 1 built in. Customize Layer 2 for scenarios. Fill in Layer 3 for each use.</p><h3>Layer Boundaries</h3><p>Clear boundaries between layers help AI understand structure. Use explicit markers: Layer 1: Background and Role. Layer 2: Current Project Context. Layer 3: Immediate Task. Or use formatting: Foundation context in italics, situational in bold, tactical in normal text.</p><h3>Progressive Disclosure</h3><p>Reveal information as needed. Start with essential information. Add details progressively. Avoid overwhelming with everything upfront. Let AI ask for clarification if needed. Example: Start with high-level goal, then add specific requirements, then provide detailed constraints, finally share examples.</p><h3>Layer Maintenance</h3><p>Keep layers current and relevant. Update Layer 1 rarely (major changes only). Refresh Layer 2 per project or campaign. Recreate Layer 3 for each task. Remove outdated information. Version control your layer templates.</p><h3>Context Layer Patterns</h3><p>Pattern 1 - Stable Base: Layer 1 stays constant, Layers 2-3 vary. Use for: Consistent role across tasks. Pattern 2 - Project Focused: Layers 1-2 stay constant, Layer 3 varies. Use for: Multiple tasks in same project. Pattern 3 - Fully Dynamic: All layers change. Use for: Diverse, unrelated tasks.</p><h3>Layering for Long Conversations</h3><p>In long conversations, periodically summarize and refresh layers. Summarize Layer 1 every 10-15 exchanges. Refresh Layer 2 when changing topics. Reset Layer 3 for each new task. Compress old context to save space.</p><h3>Combining Layers with Other Techniques</h3><p>Layers plus few-shot: Examples in Layer 3. Layers plus chain-of-thought: Reasoning structure in Layer 2. Layers plus constraints: Rules distributed across layers. Layers plus formatting: Format specs in Layer 3.</p><h3>Common Layering Mistakes</h3><p>Mistake 1: All information in one layer. Solution: Distribute appropriately. Mistake 2: Layers too granular. Solution: Keep to 2-4 layers maximum. Mistake 3: Unclear layer boundaries. Solution: Mark layers explicitly. Mistake 4: Outdated layer information. Solution: Maintain and update regularly.</p><h3>Advanced Layering Techniques</h3><p>Conditional layers: Include Layer X only if condition Y. Nested layers: Sub-layers within main layers. Dynamic layer selection: Choose layers based on task type. Meta-layers: Instructions about how to use layers. Inherited layers: Child tasks inherit parent layers.</p><h3>Measuring Layer Effectiveness</h3><p>Test with and without layering. Compare clarity of outputs. Measure consistency across tasks. Track how often you reuse layers. Monitor context window usage. Assess maintenance effort.</p><h3>Building a Layer Library</h3><p>Create reusable Layer 1 templates for different roles. Build Layer 2 templates for common scenarios. Document effective layer combinations. Share layer patterns with team. Version control layer templates. Continuously refine based on results.</p><h3>Key Takeaways</h3><ul><li>Context layering organizes information in progressive layers</li><li>Three-layer model: foundation, situational, tactical</li><li>Layer 1 is stable and reusable, Layer 3 changes each time</li><li>Clear layer boundaries help AI understand structure</li><li>Progressive disclosure prevents information overload</li><li>Maintain and update layers regularly</li><li>Combine layering with other prompt techniques</li><li>Build reusable layer templates for efficiency</li></ul><p>In the next lesson, we will explore Constraints and Guardrails for controlling AI behavior.</p></div>'
WHERE id = 'ca5cd4e9-f050-4a5c-8b8e-d6e2e931d2a8';

-- LESSON 6: Constraints & Guardrails (ID: 6cad937f-3f2f-451e-95f7-9e0b264cfeb4)
UPDATE lessons SET content = '<div class="lesson-content"><h2>Constraints and Guardrails</h2><h3>Controlling AI Behavior</h3><p>Constraints and guardrails are rules that control what AI can and cannot do. They ensure outputs meet your requirements, avoid problems, and stay within boundaries. This lesson teaches you how to set effective constraints.</p><h3>What Are Constraints?</h3><p>Constraints are explicit rules and limitations you set for AI. They define: What to include or exclude, how to behave, what to avoid, boundaries and limits, quality standards. Constraints guide AI toward desired outcomes and away from problems.</p><h3>Types of Constraints</h3><p>Content constraints: What topics to cover or avoid. Format constraints: Structure and presentation rules. Style constraints: Tone, voice, and language rules. Length constraints: Word count, character limits. Quality constraints: Accuracy, completeness standards. Behavioral constraints: How AI should respond.</p><h3>Content Constraints</h3><p>Control what AI discusses. Must include: Required topics, mandatory information, key points to cover. Must exclude: Prohibited topics, sensitive information, inappropriate content. Example: Must mention pricing and features. Do not discuss competitors or make claims about performance without data.</p><h3>Format Constraints</h3><p>Control output structure. Specify: Document structure (sections, headings), data format (JSON, CSV, markdown), presentation style (bullets, paragraphs), organization (chronological, priority), visual elements (tables, lists). Example: Use markdown format. Include exactly 3 sections. Each section must have 2-3 bullet points. No more than 500 words total.</p><h3>Style Constraints</h3><p>Control tone and voice. Define: Formality level (casual, professional, academic), perspective (first person, third person), voice (active, passive), vocabulary (simple, technical, jargon-free), sentence structure (short, varied). Example: Use professional but friendly tone. Write in active voice. Keep sentences under 20 words. Avoid jargon and acronyms.</p><h3>Length Constraints</h3><p>Control output size. Specify: Word count (exactly, minimum, maximum), character limit, number of items (bullet points, examples), section lengths, response time. Example: Exactly 300 words. No more than 5 bullet points. Each bullet point 1-2 sentences maximum.</p><h3>Quality Constraints</h3><p>Control output quality. Define: Accuracy requirements, completeness standards, verification needs, source requirements, error tolerance. Example: All facts must be verifiable. Include sources for statistics. Admit uncertainty when appropriate. No speculation without labeling it as such.</p><h3>Behavioral Constraints</h3><p>Control how AI responds. Specify: How to handle uncertainty, how to deal with missing information, when to ask for clarification, how to handle edge cases, escalation procedures. Example: If you do not know something, say so explicitly. If information is ambiguous, ask for clarification. If task is impossible, explain why.</p><h3>Writing Effective Constraints</h3><p>Be specific and explicit. Use clear, unambiguous language. Make constraints measurable when possible. Prioritize constraints (must-have vs nice-to-have). Avoid conflicting constraints. Test constraints with examples.</p><h3>Constraint Patterns</h3><p>Positive constraints (do this): Include X, use Y format, follow Z structure. Negative constraints (do not do this): Avoid X, never use Y, do not include Z. Conditional constraints (if-then): If X then do Y, when A then avoid B. Graduated constraints (levels): Minimum acceptable, target, ideal.</p><h3>Guardrails vs Constraints</h3><p>Constraints are specific rules for the task. Guardrails are broader safety and quality boundaries. Guardrails prevent: Harmful content, biased outputs, privacy violations, legal issues, brand violations. Guardrails are typically permanent, while constraints are task-specific.</p><h3>Implementing Guardrails</h3><p>Set in system prompts or foundation layer. Make them non-negotiable. Test thoroughly for edge cases. Document clearly for team. Update based on issues encountered. Example guardrails: Never share personal information. Always respect copyright. Avoid discriminatory language. Do not make medical or legal claims. Respect brand guidelines.</p><h3>Balancing Constraints</h3><p>Too few constraints: Outputs too variable, may miss requirements, quality inconsistent, potential problems. Too many constraints: Outputs too rigid, creativity limited, may conflict, hard to satisfy all. Find the right balance through testing.</p><h3>Constraint Conflicts</h3><p>Watch for conflicting constraints. Example conflict: Be comprehensive (implies length) vs be concise (implies brevity). Resolution: Prioritize constraints, clarify which takes precedence, or find middle ground. Example: Be comprehensive in coverage but concise in expression.</p><h3>Testing Constraints</h3><p>Verify constraints work as intended. Test edge cases and boundary conditions. Try to break constraints intentionally. Check for unintended consequences. Measure compliance rate. Refine based on results.</p><h3>Constraint Hierarchies</h3><p>Organize constraints by priority. Critical (must never violate): Safety, legal, ethical. Important (should follow): Quality, brand, format. Preferred (nice to have): Style, optimization, polish. Communicate priority clearly to AI.</p><h3>Dynamic Constraints</h3><p>Some constraints change based on context. Conditional constraints: Apply only in certain situations. Adaptive constraints: Adjust based on input. Progressive constraints: Tighten or loosen over iterations. User-specific constraints: Different rules for different users.</p><h3>Common Constraint Mistakes</h3><p>Mistake 1: Vague constraints (be professional). Solution: Define specifically what professional means. Mistake 2: Unmeasurable constraints (make it good). Solution: Define concrete quality criteria. Mistake 3: Conflicting constraints. Solution: Prioritize and clarify. Mistake 4: Too many constraints. Solution: Focus on essential ones.</p><h3>Constraint Documentation</h3><p>Document your constraints for reuse. Create constraint libraries for common scenarios. Share effective constraints with team. Version control constraint sets. Update based on learnings. Build templates with built-in constraints.</p><h3>Key Takeaways</h3><ul><li>Constraints are explicit rules that control AI behavior</li><li>Types: content, format, style, length, quality, behavioral</li><li>Be specific, measurable, and unambiguous</li><li>Guardrails are broader safety boundaries</li><li>Balance constraints - too few or too many both problematic</li><li>Watch for and resolve constraint conflicts</li><li>Test constraints thoroughly including edge cases</li><li>Organize constraints by priority hierarchy</li><li>Document and reuse effective constraint patterns</li></ul><p>Congratulations! You have completed Module 2. You now understand core prompt engineering techniques. In Module 3, we will explore advanced workflows and meta-prompting.</p></div>'
WHERE id = '6cad937f-3f2f-451e-95f7-9e0b264cfeb4';

-- MODULE 2 COMPLETE! All 6 lessons expanded!
-- Progress: 11/27 lessons complete (40.7%)
-- Next: Run PROMPT_M3_COMPLETE.sql for Module 3 (6 lessons)
