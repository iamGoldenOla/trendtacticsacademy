-- ==========================================
-- VIBE CODING MODULE 3 - LESSONS 2 & 3
-- The Core Vibe Coding Workflow (Continued)
-- Compact formatting
-- ==========================================

DO $$
DECLARE
    v_course_id UUID;
    v_module_id UUID;
BEGIN
    SELECT id INTO v_course_id FROM courses WHERE title ILIKE '%Vibe Coding%' LIMIT 1;
    IF v_course_id IS NULL THEN RAISE EXCEPTION 'Vibe Coding course not found'; END IF;
    
    SELECT id INTO v_module_id FROM modules WHERE course_id = v_course_id AND ordering = 3 LIMIT 1;
    IF v_module_id IS NULL THEN RAISE EXCEPTION 'Module 3 not found'; END IF;
    
    RAISE NOTICE 'ðŸ“š Expanding Vibe Coding Module 3 (Lessons 2-3)...';
    
    -- LESSON 9: The Vibe Coding Loop
    UPDATE lessons SET content = '<div class="lesson-content"><h2>The Vibe Coding Loop</h2><h3>The Iterative Development Cycle</h3><p>Vibe Coding isn''t a linear process where you describe something once and it''s done. It''s an <strong>iterative loop</strong>â€”a cycle of describing, generating, testing, and refining that continues until you have exactly what you need.</p><p>This lesson breaks down the Vibe Coding Loop, showing you the practical workflow you''ll use every day to build features, fix bugs, and create software with AI.</p><h3>The Five Phases of the Vibe Coding Loop</h3><p>The Vibe Coding Loop consists of five distinct phases: Define Intent, Generate Solution, Evaluate Result, Refine Direction, and Iterate. Let''s explore each phase in detail.</p><h4>Phase 1: Define Intent</h4><p>Start by clearly articulating what you want to achieve. This isn''t just listing featuresâ€”it''s understanding the purpose and desired outcome.</p><p><strong>Good Intent Definition:</strong> "Users need to filter products by price range. They should see results update instantly as they adjust the range slider. The filter should work on mobile with touch-friendly controls."</p><p><strong>Weak Intent Definition:</strong> "Add a filter"</p><p>Key questions to ask yourself: What problem am I solving? Who will use this feature? What should the user experience feel like? What are the success criteria?</p><h4>Phase 2: Generate Solution</h4><p>Communicate your intent to AI and let it generate a solution. This is where AI translates your description into working code.</p><p><strong>Tips for this phase:</strong> Be specific but not overly prescriptive about implementation. Provide context about your tech stack and existing code. Include examples or references if helpful. Set clear constraints and requirements.</p><h4>Phase 3: Evaluate Result</h4><p>Test what AI generated. Does it work? Does it match your intent? This is where you act as the director, evaluating whether the implementation meets your vision.</p><p><strong>What to evaluate:</strong> Functionality: Does it work as intended? User Experience: Does it feel right? Code Quality: Is it maintainable and well-structured? Edge Cases: Does it handle unusual situations? Integration: Does it fit with existing code?</p><h4>Phase 4: Refine Direction</h4><p>Based on your evaluation, provide more specific guidance. This is where you clarify, adjust, or expand your original intent.</p><p><strong>Example refinements:</strong> "The slider works, but it''s too sensitive on mobile. Make the touch targets larger and add some damping to the movement." "Good, but add a ''Clear Filters'' button to reset everything." "The price range should persist when users navigate away and come back."</p><h4>Phase 5: Iterate</h4><p>Return to Phase 2 with your refined direction. Continue the loop until the result matches your intent.</p><p>The loop continues: Generate â†’ Evaluate â†’ Refine â†’ Generate â†’ Evaluate â†’ Refine... until you''re satisfied.</p><h3>Real-World Example: Building a Feature</h3><p>Let''s walk through the complete loop for a real feature: building a comment system.</p><p><strong>Iteration 1:</strong></p><p>Define Intent: "Add a comment system where users can post comments on articles. Show comments in chronological order with newest first."</p><p>Generate: AI creates a basic comment component with a form and list.</p><p>Evaluate: It works, but there''s no user info, no timestamps, and no way to delete comments.</p><p>Refine: "Add user avatars and names to each comment. Show how long ago the comment was posted (''2 hours ago''). Let users delete their own comments with a confirmation dialog."</p><p><strong>Iteration 2:</strong></p><p>Generate: AI updates the component with user info, timestamps, and delete functionality.</p><p>Evaluate: Much better! But the timestamps don''t update (''2 hours ago'' stays static). Also, there''s no loading state when posting a comment.</p><p>Refine: "Make the timestamps update automatically (''2 hours ago'' should change to ''3 hours ago'' after an hour). Add a loading spinner to the submit button while the comment is being posted."</p><p><strong>Iteration 3:</strong></p><p>Generate: AI adds dynamic timestamps and loading states.</p><p>Evaluate: Perfect! The feature now matches the intent. Loop complete.</p><h3>How Many Iterations Are Normal?</h3><p>The number of iterations varies based on complexity:</p><p><strong>Simple features:</strong> 1-2 iterations - Basic UI components, simple functions, straightforward logic</p><p><strong>Medium features:</strong> 3-5 iterations - Forms with validation, data fetching with error handling, interactive components</p><p><strong>Complex features:</strong> 6-10+ iterations - Multi-step workflows, complex state management, intricate user interactions</p><p>Don''t be discouraged by multiple iterationsâ€”that''s the process working as intended!</p><h3>Optimizing Your Loop Speed</h3><p>Here are strategies to make each iteration faster and more effective:</p><h4>1. Front-Load Context</h4><p>Provide comprehensive context in your first iteration to reduce back-and-forth: "I''m building a task app with Next.js and Supabase. Users are small teams. Design should be clean and minimal like Linear. Create a task card component showing title, assignee, due date, and status."</p><h4>2. Test Incrementally</h4><p>Don''t wait until everything is "done" to test. Test after each generation to catch issues early.</p><h4>3. Be Specific in Refinements</h4><p>Vague: "Make it better"<br>Specific: "The button text is hard to read. Increase font size to 16px and change color to white for better contrast."</p><h4>4. Use Visual References</h4><p>"Make the card look like Stripe''s pricing cards" is faster than describing every detail.</p><h4>5. Build on What Works</h4><p>When something is good, acknowledge it: "The layout is perfect. Keep that exactly as is. Now add a search bar at the top."</p><h3>Common Loop Patterns</h3><h4>The Expansion Loop</h4><p>Start minimal, then expand: Iteration 1: Core functionality only. Iteration 2: Add error handling. Iteration 3: Add loading states. Iteration 4: Add edge case handling. Iteration 5: Polish UX details.</p><h4>The Refinement Loop</h4><p>Start broad, then refine: Iteration 1: Get the general structure. Iteration 2: Refine the layout. Iteration 3: Adjust styling. Iteration 4: Fine-tune interactions. Iteration 5: Perfect the details.</p><h4>The Debugging Loop</h4><p>When something breaks: Iteration 1: Identify the problem. Iteration 2: Attempt a fix. Iteration 3: Test the fix. Iteration 4: Address side effects. Iteration 5: Verify everything works.</p><h3>When to Exit the Loop</h3><p>How do you know when you''re done? Use these criteria:</p><p><strong>Functionality Check:</strong> Does it do what it''s supposed to do?</p><p><strong>User Experience Check:</strong> Does it feel good to use?</p><p><strong>Edge Case Check:</strong> Does it handle unusual situations gracefully?</p><p><strong>Integration Check:</strong> Does it work well with the rest of your app?</p><p><strong>Quality Check:</strong> Is the code maintainable and understandable?</p><p>If you can answer "yes" to all five, you''re done!</p><h3>Avoiding Infinite Loops</h3><p>Sometimes you can get stuck in an endless cycle of refinements. Here''s how to avoid it:</p><p><strong>Problem 1: Moving Target</strong> - You keep changing what you want.<br>Solution: Write down your success criteria before starting. Stick to them.</p><p><strong>Problem 2: Perfectionism</strong> - You''re refining details that don''t matter.<br>Solution: Ask "Will users notice this?" If not, move on.</p><p><strong>Problem 3: AI Limitations</strong> - AI can''t do what you''re asking.<br>Solution: Simplify your request or try a different approach.</p><p><strong>Problem 4: Unclear Intent</strong> - You don''t know exactly what you want.<br>Solution: Step back. Sketch it out. Get clearer on your vision before continuing.</p><h3>The Meta-Loop: Learning and Improving</h3><p>There''s a larger loop happening as you work: with each project, you get better at defining intent, you learn what works and what doesn''t, you build a library of patterns and approaches, and you become faster at each iteration.</p><p>This meta-loop means you''ll naturally get faster and more effective over time.</p><h3>Parallel Loops: Working on Multiple Features</h3><p>You can run multiple Vibe Coding Loops simultaneously for different features. Best practices: Use separate conversations for separate features. Complete one loop before starting another (don''t interleave). Document decisions from completed loops. Reference completed features when building new ones.</p><h3>The Loop in Different Contexts</h3><p><strong>For Learning:</strong> The loop is slower but more educational. Take time to understand what AI generates and why.</p><p><strong>For Production:</strong> The loop is faster but more rigorous. Test thoroughly and consider edge cases carefully.</p><p><strong>For Prototyping:</strong> The loop is fastest. Accept "good enough" and move on quickly.</p><h3>Tools to Support Your Loop</h3><p><strong>Version Control:</strong> Commit after successful iterations so you can roll back if needed.</p><p><strong>Testing:</strong> Automated tests help you verify each iteration quickly.</p><p><strong>Documentation:</strong> Note important decisions as you iterate.</p><p><strong>Screenshots/Videos:</strong> Capture working states to compare iterations.</p><h3>Key Takeaways</h3><ul><li>The Vibe Coding Loop has <strong>five phases</strong>: Define Intent, Generate Solution, Evaluate Result, Refine Direction, Iterate</li><li>Multiple iterations are <strong>normal and expected</strong>â€”embrace the process</li><li>Front-load context and be specific in refinements to <strong>speed up iterations</strong></li><li>Know when to <strong>exit the loop</strong> using clear success criteria</li><li>Avoid infinite loops by setting clear goals and avoiding perfectionism</li><li>You''ll get <strong>faster and better</strong> with practice through the meta-loop</li></ul><p>In the next lesson, we''ll explore modular thinkingâ€”how to break down complex projects into manageable pieces that work well with the Vibe Coding Loop.</p></div>'
    WHERE module_id = v_module_id AND ordering = 2;
    RAISE NOTICE 'âœ… Lesson 9 Complete';
    
    -- LESSON 10: Modular Thinking
    UPDATE lessons SET content = '<div class="lesson-content"><h2>Modular Thinking</h2><h3>Breaking Down Complexity</h3><p>One of the most valuable skills in Vibe Coding is <strong>modular thinking</strong>â€”the ability to break down complex projects into smaller, manageable pieces that can be built, tested, and refined independently.</p><p>This lesson teaches you how to think modularly, structure your projects effectively, and use this approach to build complex software with AI more efficiently.</p><h3>What Is Modular Thinking?</h3><p>Modular thinking means viewing your project as a collection of independent, reusable pieces (modules) rather than one monolithic whole.</p><p>Think of it like building with LEGO blocks. Instead of trying to create the entire structure at once, you build individual pieces that can be combined, rearranged, and reused.</p><h4>Benefits of Modular Thinking</h4><p><strong>Easier to Build:</strong> Smaller pieces are simpler to describe and generate with AI.</p><p><strong>Easier to Test:</strong> You can verify each module works before combining them.</p><p><strong>Easier to Debug:</strong> Problems are isolated to specific modules.</p><p><strong>Easier to Modify:</strong> Change one module without affecting others.</p><p><strong>Easier to Reuse:</strong> Use the same modules in different projects.</p><h3>Identifying Modules in Your Project</h3><p>How do you break down a project into modules? Look for natural boundaries:</p><h4>1. By Functionality</h4><p>Each distinct feature or capability is a module.</p><p>Example: In a task management app: Task Creation Module, Task List Module, Task Filtering Module, User Authentication Module, Settings Module</p><h4>2. By User Interface</h4><p>Each distinct UI component is a module.</p><p>Example: Header Component, Sidebar Component, Task Card Component, Modal Component, Button Component</p><h4>3. By Data</h4><p>Each type of data or entity is a module.</p><p>Example: User Data Module, Task Data Module, Project Data Module, Comment Data Module</p><h4>4. By Layer</h4><p>Each technical layer is a module.</p><p>Example: Database Layer, API Layer, Business Logic Layer, UI Layer, Authentication Layer</p><h3>The Modular Vibe Coding Workflow</h3><p>Here''s how to apply modular thinking to your Vibe Coding process:</p><p><strong>Step 1: Identify Modules</strong> - Break your project down into distinct modules.</p><p><strong>Step 2: Prioritize Modules</strong> - Decide which modules to build first (usually core functionality).</p><p><strong>Step 3: Build One Module at a Time</strong> - Use the Vibe Coding Loop to build each module completely.</p><p><strong>Step 4: Test Each Module</strong> - Verify it works independently before moving on.</p><p><strong>Step 5: Integrate Modules</strong> - Connect modules together to form the complete system.</p><p><strong>Step 6: Test Integration</strong> - Verify modules work together correctly.</p><h3>Real-World Example: Building a Blog Platform</h3><p>Let''s break down a blog platform into modules:</p><p><strong>Core Modules:</strong> Article Display Module (show individual articles), Article List Module (show all articles), Article Editor Module (create/edit articles), User Authentication Module (login/signup), Comment System Module</p><p><strong>Supporting Modules:</strong> Navigation Component, Footer Component, Search Module, Category Filter Module, User Profile Module</p><p><strong>Data Modules:</strong> Article Data Layer, User Data Layer, Comment Data Layer</p><p><strong>Build Order:</strong> 1. Article Display Module (core functionality). 2. Article List Module (needed to navigate). 3. User Authentication (needed for editing). 4. Article Editor Module (content creation). 5. Comment System (engagement). 6. Search and Filters (enhancement)</p><h3>Designing Good Modules</h3><p>What makes a module well-designed? Follow these principles:</p><h4>1. Single Responsibility</h4><p>Each module should do one thing well.</p><p>Good: "Button Component" that handles button styling and click events.<br>Bad: "Button Component" that also manages global state and makes API calls.</p><h4>2. Clear Interface</h4><p>It should be obvious how to use the module.</p><p>Good: A function with clear parameters and return value.<br>Bad: A function that relies on global variables and side effects.</p><h4>3. Independence</h4><p>Modules should work with minimal dependencies on other modules.</p><p>Good: A date formatting utility that works standalone.<br>Bad: A date formatter that requires the entire app context to function.</p><h4>4. Reusability</h4><p>Design modules to be used in multiple places.</p><p>Good: A generic "Card" component that accepts any content.<br>Bad: A "UserCard" component with hardcoded user-specific logic.</p><h3>Communicating Modules to AI</h3><p>When building modules with AI, be explicit about boundaries:</p><p><strong>Example:</strong> "Create a standalone Button component. It should accept these props: text, onClick, variant (''primary'' or ''secondary''), disabled. It should not depend on any other components or global state. Use Tailwind CSS for styling."</p><p>This makes it clear: What the module is, What it needs (inputs), What it does (functionality), What it doesn''t do (boundaries)</p><h3>Module Patterns in Vibe Coding</h3><h4>Pattern 1: The Foundation Pattern</h4><p>Build foundational modules first, then build on top of them.</p><p>Example: 1. Create base "Card" component. 2. Create "TaskCard" using Card. 3. Create "ProjectCard" using Card. 4. Create "UserCard" using Card.</p><h4>Pattern 2: The Parallel Pattern</h4><p>Build independent modules simultaneously.</p><p>Example: Build authentication module in one conversation, build article display in another, build comment system in a third, then integrate all three.</p><h4>Pattern 3: The Vertical Slice Pattern</h4><p>Build one complete feature (all layers) before moving to the next.</p><p>Example: For "Create Task" feature: 1. UI component. 2. API endpoint. 3. Database schema. 4. Validation logic. Complete this entire vertical slice before starting "Edit Task".</p><h3>Managing Module Dependencies</h3><p>Some modules depend on others. Manage this carefully:</p><p><strong>Identify Dependencies:</strong> "TaskCard depends on Button and Card components"</p><p><strong>Build in Order:</strong> Build dependencies first: Button â†’ Card â†’ TaskCard</p><p><strong>Use Interfaces:</strong> Define how modules connect: "TaskCard expects a task object with id, title, status, and dueDate properties"</p><p><strong>Document Connections:</strong> Keep track of which modules use which: "Button is used by: TaskCard, ProjectCard, Modal, Header"</p><h3>The Module Library Concept</h3><p>As you build, you''re creating a library of reusable modules. Maintain this library:</p><p><strong>Document Each Module:</strong> What it does, how to use it, what it depends on</p><p><strong>Keep a Module Inventory:</strong> List all available modules in your project</p><p><strong>Share with AI:</strong> When starting new features, show AI your module library: "Here are our existing components: [list]. Reuse these instead of creating new ones."</p><h3>Refactoring into Modules</h3><p>Sometimes you''ll build something monolithic and need to break it apart. Here''s how:</p><p><strong>Identify Repeated Code:</strong> Look for patterns that appear multiple times.</p><p><strong>Extract to Module:</strong> "Take this repeated validation logic and create a standalone validateEmail function."</p><p><strong>Replace Duplicates:</strong> "Replace all instances of inline email validation with calls to validateEmail."</p><p><strong>Test:</strong> Verify everything still works after refactoring.</p><h3>Modular Thinking for Different Project Sizes</h3><p><strong>Small Projects (1-5 features):</strong> Simple modules: Components, utilities, data fetchers. Minimal abstraction. Focus on clarity over reusability.</p><p><strong>Medium Projects (5-20 features):</strong> Organized modules: Feature modules, shared components, utility libraries. Clear folder structure. Balance reusability and simplicity.</p><p><strong>Large Projects (20+ features):</strong> Sophisticated modules: Domain-driven modules, design systems, shared libraries. Strict interfaces and contracts. High reusability and maintainability.</p><h3>Common Modular Thinking Mistakes</h3><p><strong>Mistake 1: Over-Modularization</strong> - Breaking things down too much creates unnecessary complexity.<br>Solution: If a module is only used once and is very simple, it might not need to be separate.</p><p><strong>Mistake 2: Under-Modularization</strong> - Building everything as one big piece makes it hard to manage.<br>Solution: If a file is getting very long or doing multiple things, break it apart.</p><p><strong>Mistake 3: Tight Coupling</strong> - Modules that depend heavily on each other lose independence.<br>Solution: Design clear interfaces and minimize dependencies.</p><p><strong>Mistake 4: Premature Abstraction</strong> - Creating reusable modules before you know the patterns.<br>Solution: Wait until you''ve used something 2-3 times before abstracting it.</p><h3>Tools for Modular Development</h3><p><strong>File Organization:</strong> Use folders to group related modules: components/, utils/, hooks/, services/</p><p><strong>Naming Conventions:</strong> Clear names that indicate purpose: useAuth.js, validateEmail.js, TaskCard.jsx</p><p><strong>Documentation:</strong> README files explaining each module''s purpose and usage</p><p><strong>Storybook/Component Libraries:</strong> Tools to develop and test UI modules in isolation</p><h3>Modular Thinking Beyond Code</h3><p>Modular thinking applies to more than just code:</p><p><strong>Design Systems:</strong> Modular UI patterns and components</p><p><strong>Documentation:</strong> Modular docs for each feature</p><p><strong>Testing:</strong> Modular test suites for each module</p><p><strong>Deployment:</strong> Modular deployment of different services</p><h3>Key Takeaways</h3><ul><li>Modular thinking means breaking projects into <strong>independent, reusable pieces</strong></li><li>Identify modules by <strong>functionality, UI, data, or technical layer</strong></li><li>Build modules <strong>one at a time</strong> using the Vibe Coding Loop</li><li>Good modules have <strong>single responsibility, clear interfaces, independence, and reusability</strong></li><li>Manage <strong>dependencies carefully</strong> and build in the right order</li><li>Create a <strong>module library</strong> that grows with your project</li><li>Avoid over-modularization and premature abstraction</li></ul><p>You''ve now completed Module 3! You understand the core Vibe Coding workflow: system vs user prompts, the iterative loop, and modular thinking. In Module 4, we''ll explore the Vibe Toolkitâ€”the 45+ tools available to help you build software with AI.</p></div>'
    WHERE module_id = v_module_id AND ordering = 3;
    RAISE NOTICE 'âœ… Lesson 10 Complete';
    
    RAISE NOTICE 'ðŸŽ‰ Module 3 ALL 3 LESSONS COMPLETE!';
    
END $$;
