-- ==========================================
-- VIBE CODING MODULE 4 - LESSONS 4-5 (FINAL)
-- Agentic IDEs & AI Agents
-- Compact HTML formatting
-- ==========================================

DO $$
DECLARE
    v_course_id UUID;
    v_module_id UUID;
BEGIN
    SELECT id INTO v_course_id FROM courses WHERE title ILIKE '%Vibe Coding%' LIMIT 1;
    IF v_course_id IS NULL THEN RAISE EXCEPTION 'Vibe Coding course not found'; END IF;
    
    SELECT id INTO v_module_id FROM modules WHERE course_id = v_course_id AND ordering = 4 LIMIT 1;
    IF v_module_id IS NULL THEN RAISE EXCEPTION 'Module 4 not found'; END IF;
    
    RAISE NOTICE 'ðŸ“š Expanding Vibe Coding Module 4 (Lessons 4-5 FINAL)...';
    
    -- LESSON 14: Agentic IDEs (Command Centers)
    UPDATE lessons SET content = '<div class="lesson-content"><h2>Agentic IDEs (Command Centers)</h2><h3>Your AI-Powered Development Environment</h3><p>Agentic IDEs are the next evolution of development environmentsâ€”intelligent coding partners that understand your entire codebase, anticipate your needs, and actively help you build better software faster. This lesson explores the leading agentic IDEs and how to use them as your command center for Vibe Coding.</p><h3>What Makes an IDE "Agentic"?</h3><p>Traditional IDEs are passive tools that wait for your commands. Agentic IDEs are active partners that understand context across your entire project, suggest relevant changes proactively, execute multi-step tasks autonomously, learn from your codebase patterns, and collaborate with you conversationally.</p><p>Think of them as having an expert developer sitting next to you, understanding your project deeply and helping at every step.</p><h3>Top Agentic IDEs</h3><h4>1. Cursor</h4><p><strong>What it is:</strong> A fork of VS Code with deep AI integration, designed specifically for AI-assisted development.</p><p><strong>Best for:</strong> Professional development, complex projects, teams wanting AI assistance</p><p><strong>Key Features:</strong> Chat with your codebase (ask questions about any part of your code). Cmd+K for inline AI edits. Composer for multi-file changes. Codebase-wide context understanding. Terminal integration with AI assistance.</p><p><strong>Example use:</strong> "Refactor this component to use TypeScript and add proper error handling throughout."</p><h4>2. Windsurf</h4><p><strong>What it is:</strong> AI-first IDE focused on "flow state" coding with intelligent assistance.</p><p><strong>Best for:</strong> Developers who want minimal interruption, flow-focused coding</p><p><strong>Key Features:</strong> Flow mode (AI assists without breaking concentration). Cascade (AI handles multi-step tasks). Context-aware suggestions. Intelligent code completion.</p><p><strong>Example use:</strong> "Add authentication to this app, including signup, login, and protected routes."</p><h4>3. GitHub Copilot in VS Code</h4><p><strong>What it is:</strong> AI pair programmer integrated into VS Code.</p><p><strong>Best for:</strong> VS Code users, teams already on GitHub</p><p><strong>Key Features:</strong> Real-time code suggestions. Chat interface for questions. Slash commands for common tasks. Copilot Labs for experimental features.</p><p><strong>Example use:</strong> Start typing a function and Copilot suggests the complete implementation.</p><h4>4. Replit Ghostwriter</h4><p><strong>What it is:</strong> AI assistant built into Replit''s cloud IDE.</p><p><strong>Best for:</strong> Learning, collaborative coding, quick prototypes</p><p><strong>Key Features:</strong> Code generation and completion. Explain code functionality. Debug assistance. Generate from comments.</p><p><strong>Example use:</strong> Write a comment describing what you want, Ghostwriter generates the code.</p><h3>How to Use Agentic IDEs Effectively</h3><h4>1. Provide Project Context</h4><p>Help your IDE understand your project: Add a README with project overview. Include architecture documentation. Use clear folder structure. Write descriptive comments. Maintain consistent naming conventions.</p><h4>2. Use Chat for Understanding</h4><p>Ask questions about your codebase: "How does authentication work in this app?" "Where is the user data being validated?" "What does this function do and where is it used?" "Find all API endpoints that need rate limiting."</p><h4>3. Request Targeted Changes</h4><p>Be specific about what you want: "Add error handling to all API calls in this file." "Refactor this component to use hooks instead of class methods." "Extract this logic into a reusable utility function." "Add TypeScript types to this entire module."</p><h4>4. Leverage Multi-File Operations</h4><p>Make coordinated changes across files: "Update all components to use the new theme system." "Rename this function everywhere it''s used." "Add logging to all database operations." "Update imports after moving this file."</p><h3>Advanced Agentic IDE Features</h3><h4>Codebase-Wide Search and Understanding</h4><p>Cursor and Windsurf can search and understand your entire codebase: "Find all places where we''re making API calls without error handling." "Show me all components that use the old authentication method." "List all database queries that could benefit from indexing."</p><h4>Intelligent Refactoring</h4><p>"Refactor this monolithic component into smaller, focused components while maintaining all functionality."</p><h4>Test Generation</h4><p>"Generate unit tests for this module covering all edge cases and error conditions."</p><h4>Documentation Generation</h4><p>"Add JSDoc comments to all functions in this file explaining parameters, return values, and usage examples."</p><h4>Code Review Assistance</h4><p>"Review this pull request for potential bugs, security issues, and performance problems."</p><h3>Workflow Patterns with Agentic IDEs</h3><h4>Pattern 1: Exploration â†’ Understanding â†’ Implementation</h4><p>Step 1: "Explain how the current authentication system works."<br>Step 2: "What would need to change to add OAuth support?"<br>Step 3: "Implement Google OAuth while maintaining existing email/password auth."</p><h4>Pattern 2: Describe â†’ Generate â†’ Refine</h4><p>Step 1: "Create a user profile component with avatar, name, bio, and edit button."<br>Step 2: Review generated code.<br>Step 3: "Add loading states and error handling to the profile component."</p><h4>Pattern 3: Problem â†’ Diagnosis â†’ Solution</h4><p>Step 1: "This component is rendering too many times. Why?"<br>Step 2: AI explains the cause.<br>Step 3: "Fix the unnecessary re-renders using React.memo and useCallback."</p><h3>Keyboard Shortcuts and Commands</h3><p><strong>Cursor:</strong> Cmd/Ctrl + K: Inline edit. Cmd/Ctrl + L: Chat with codebase. Cmd/Ctrl + I: Composer mode. Cmd/Ctrl + Shift + P: Command palette.</p><p><strong>GitHub Copilot:</strong> Tab: Accept suggestion. Alt + ]: Next suggestion. Alt + [: Previous suggestion. Ctrl + Enter: Open Copilot.</p><h3>Best Practices for Agentic IDEs</h3><h4>1. Start Conversations with Context</h4><p>Instead of: "Add validation"<br>Better: "In the UserForm component, add validation for email (valid format), password (min 8 chars, 1 number), and username (3-20 chars, alphanumeric)."</p><h4>2. Review AI-Generated Code</h4><p>Always review and test AI suggestions. AI is a tool, not a replacement for your judgment.</p><h4>3. Iterate Incrementally</h4><p>Make changes in small steps rather than asking for massive rewrites all at once.</p><h4>4. Use AI for Tedious Tasks</h4><p>Let AI handle: Boilerplate code. Repetitive patterns. Type definitions. Test scaffolding. Documentation.</p><h4>5. Keep AI in the Loop</h4><p>When you make manual changes, explain them in comments so AI understands your decisions.</p><h3>Combining Agentic IDEs with Other Tools</h3><p>Agentic IDEs work great with: Version control (Git integration for commits and PRs). Linters and formatters (Prettier, ESLint). Testing frameworks (Jest, Vitest). Debuggers (built-in debugging with AI assistance). Deployment tools (Vercel, Netlify).</p><h3>Common Challenges and Solutions</h3><p><strong>Challenge:</strong> AI suggests code that doesn''t fit project patterns.<br><strong>Solution:</strong> Add style guides and patterns to your project docs. Reference existing code as examples.</p><p><strong>Challenge:</strong> AI makes changes that break other parts of the app.<br><strong>Solution:</strong> Use version control. Test thoroughly. Make smaller, focused changes.</p><p><strong>Challenge:</strong> AI doesn''t understand complex business logic.<br><strong>Solution:</strong> Document business rules clearly. Explain the "why" behind complex code.</p><p><strong>Challenge:</strong> Too many AI suggestions are distracting.<br><strong>Solution:</strong> Adjust settings to reduce suggestion frequency. Use AI intentionally via chat rather than relying on autocomplete.</p><h3>Security and Privacy Considerations</h3><p>When using agentic IDEs: Understand what code is sent to AI services. Use local models for sensitive projects. Review terms of service for data usage. Don''t commit API keys or secrets. Use environment variables for sensitive data.</p><h3>Measuring Productivity Gains</h3><p>Track your improvements: Time to implement features. Code quality metrics. Bug reduction. Test coverage. Developer satisfaction.</p><p>Most developers report 30-50% productivity increases with agentic IDEs.</p><h3>The Future of Agentic IDEs</h3><p>Emerging capabilities: Autonomous bug fixing. Proactive code optimization. Intelligent code migration. Cross-project learning. Team collaboration features.</p><h3>Key Takeaways</h3><ul><li>Agentic IDEs are <strong>active coding partners</strong>, not passive tools</li><li>Top choices: <strong>Cursor for professionals, Windsurf for flow, Copilot for VS Code users</strong></li><li>Use chat to <strong>understand your codebase</strong> and ask questions</li><li>Request <strong>targeted, incremental changes</strong> rather than massive rewrites</li><li>Always <strong>review and test</strong> AI-generated code</li><li>Leverage AI for <strong>tedious tasks</strong> while focusing on creative problem-solving</li><li>Combine with other tools for a <strong>complete development workflow</strong></li></ul><p>In the next lesson, we''ll explore AI Agents & Orchestration - systems that coordinate multiple AI tools to build complex applications.</p></div>'
    WHERE module_id = v_module_id AND ordering = 4;
    RAISE NOTICE 'âœ… Lesson 14 Complete';
    
    -- LESSON 15: AI Agents & Orchestration
    UPDATE lessons SET content = '<div class="lesson-content"><h2>AI Agents & Orchestration</h2><h3>Coordinating Multiple AI Systems</h3><p>AI agents are autonomous systems that can plan, execute, and adapt to complete complex tasks. Orchestration is the art of coordinating multiple AI agents and tools to work together seamlessly. This lesson explores how to use AI agents and orchestration to build sophisticated applications beyond what single tools can achieve.</p><h3>What Are AI Agents?</h3><p>An AI agent is a system that can perceive its environment (understand the current state), reason about goals (plan how to achieve objectives), take actions (execute steps autonomously), and learn from results (adapt based on outcomes).</p><p>Unlike simple AI tools that respond to single prompts, agents can handle multi-step workflows, make decisions, and course-correct when needed.</p><h3>Types of AI Agents</h3><h4>1. Task-Specific Agents</h4><p>Designed for particular jobs: Code generation agents. Testing agents. Documentation agents. Deployment agents. Monitoring agents.</p><h4>2. General-Purpose Agents</h4><p>Can handle various tasks: AutoGPT. BabyAGI. AgentGPT. These agents can break down complex goals into subtasks and execute them.</p><h4>3. Specialized Development Agents</h4><p>Built for software development: Devin (autonomous software engineer). Sweep (GitHub issue resolver). Codium (test generation and review).</p><h3>How AI Agents Work</h3><p>A typical agent workflow: Receive goal or task. Break down into subtasks. Execute each subtask. Verify results. Adjust plan if needed. Repeat until goal achieved.</p><p><strong>Example:</strong> Goal: "Build a contact form with email sending"</p><p>Agent breaks this down: Create HTML form structure. Add form validation. Set up backend endpoint. Integrate email service. Add error handling. Test the complete flow. Deploy.</p><h3>AI Orchestration Platforms</h3><h4>1. LangChain</h4><p><strong>What it does:</strong> Framework for building applications with language models and agents.</p><p><strong>Best for:</strong> Custom agent workflows, complex chains of AI operations</p><p><strong>Example use:</strong> "Create an agent that reads documentation, answers questions, and generates code examples based on the docs."</p><h4>2. AutoGPT</h4><p><strong>What it does:</strong> Autonomous agent that breaks down goals and executes them independently.</p><p><strong>Best for:</strong> Research tasks, content generation, automated workflows</p><p><strong>Example use:</strong> "Research the top 10 project management tools, compare features, and create a summary report."</p><h4>3. n8n</h4><p><strong>What it does:</strong> Workflow automation platform with AI integration.</p><p><strong>Best for:</strong> Business process automation, connecting multiple services</p><p><strong>Example use:</strong> "When a new user signs up, create account, send welcome email, add to CRM, and notify team in Slack."</p><h4>4. Zapier AI</h4><p><strong>What it does:</strong> No-code automation with AI-powered workflows.</p><p><strong>Best for:</strong> Simple automations, connecting apps without code</p><p><strong>Example use:</strong> "When I receive an email with an attachment, save it to Google Drive and summarize the email content."</p><h3>Building Multi-Agent Systems</h3><p>Coordinate multiple specialized agents:</p><h4>Example: Automated Code Review System</h4><p>Agent 1 (Code Analyzer): Reviews code for bugs and issues.<br>Agent 2 (Security Scanner): Checks for security vulnerabilities.<br>Agent 3 (Performance Analyzer): Identifies performance bottlenecks.<br>Agent 4 (Documentation Generator): Creates/updates documentation.<br>Orchestrator: Coordinates all agents and compiles final report.</p><h4>Example: Content Creation Pipeline</h4><p>Agent 1 (Researcher): Gathers information on topic.<br>Agent 2 (Writer): Creates draft content.<br>Agent 3 (Editor): Refines and improves writing.<br>Agent 4 (SEO Optimizer): Optimizes for search engines.<br>Agent 5 (Publisher): Formats and publishes content.<br>Orchestrator: Manages the pipeline from research to publication.</p><h3>Practical Agent Workflows</h3><h4>Workflow 1: Automated Testing</h4><p>"Create an agent that: Analyzes new code changes. Generates appropriate unit tests. Runs tests and reports results. Suggests fixes for failing tests. Updates tests when code changes."</p><h4>Workflow 2: Documentation Maintenance</h4><p>"Build an agent system that: Monitors code changes. Identifies outdated documentation. Generates updated docs. Creates pull requests with changes. Notifies team for review."</p><h4>Workflow 3: Bug Triage and Resolution</h4><p>"Set up agents to: Monitor error logs and user reports. Categorize and prioritize bugs. Attempt automated fixes for simple issues. Create detailed bug reports for complex issues. Assign to appropriate team members."</p><h3>Agent Communication Patterns</h3><h4>Sequential Processing</h4><p>Agents work one after another: Agent A completes â†’ passes results to Agent B â†’ Agent B completes â†’ passes to Agent C.</p><h4>Parallel Processing</h4><p>Multiple agents work simultaneously: Agents A, B, and C all work on different aspects â†’ Results combined by orchestrator.</p><h4>Hierarchical Processing</h4><p>Manager agent coordinates worker agents: Manager breaks down task â†’ Assigns subtasks to workers â†’ Workers report back â†’ Manager synthesizes results.</p><h3>Tools for Agent Orchestration</h3><p><strong>LangChain:</strong> Python/JavaScript framework for agent chains</p><p><strong>CrewAI:</strong> Framework for role-playing AI agents</p><p><strong>AutoGen:</strong> Microsoft''s multi-agent conversation framework</p><p><strong>Semantic Kernel:</strong> Microsoft''s SDK for AI orchestration</p><h3>Best Practices for AI Agents</h3><h4>1. Define Clear Goals</h4><p>Agents need specific, measurable objectives: Vague: "Improve the codebase". Clear: "Reduce code duplication by extracting common functions into utilities."</p><h4>2. Set Boundaries</h4><p>Limit what agents can do: Define allowed actions. Set resource limits (time, API calls). Require human approval for critical changes. Implement safety checks.</p><h4>3. Monitor Agent Behavior</h4><p>Track what agents are doing: Log all actions. Review decisions. Measure success rates. Identify failure patterns.</p><h4>4. Implement Feedback Loops</h4><p>Help agents improve: Provide feedback on results. Adjust parameters based on performance. Update instructions when patterns emerge.</p><h3>Common Agent Patterns</h3><p><strong>The Researcher:</strong> Gathers information from multiple sources and synthesizes findings.</p><p><strong>The Validator:</strong> Checks work for correctness, completeness, and quality.</p><p><strong>The Optimizer:</strong> Improves existing solutions for performance, readability, or efficiency.</p><p><strong>The Monitor:</strong> Watches for issues and alerts when intervention needed.</p><p><strong>The Executor:</strong> Carries out predefined tasks reliably and consistently.</p><h3>Challenges and Limitations</h3><p><strong>Challenge 1: Unpredictable Behavior</strong><br>Agents may take unexpected approaches.<br>Solution: Set clear constraints and review agent plans before execution.</p><p><strong>Challenge 2: Error Propagation</strong><br>Mistakes early in the chain affect everything downstream.<br>Solution: Add validation checkpoints between agent steps.</p><p><strong>Challenge 3: Cost Management</strong><br>Multiple agents making API calls can get expensive.<br>Solution: Set budgets, cache results, use local models where possible.</p><p><strong>Challenge 4: Debugging Complexity</strong><br>Multi-agent systems are hard to debug.<br>Solution: Comprehensive logging, step-by-step execution mode, visualization tools.</p><h3>Security Considerations</h3><p>When using AI agents: Never give agents unrestricted access to systems. Require approval for destructive actions. Sanitize all agent inputs and outputs. Monitor for unusual behavior. Keep sensitive data separate from agent access.</p><h3>The Future of AI Agents</h3><p>Emerging trends: Agents that learn from experience. Multi-agent collaboration without explicit orchestration. Agents that can use any software tool. Specialized domain agents (legal, medical, financial). Personal AI assistants that know your preferences.</p><h3>Getting Started with Agents</h3><p>Start simple: Begin with single-purpose agents. Add orchestration gradually. Test extensively before automation. Monitor closely initially. Scale as you gain confidence.</p><h3>Key Takeaways</h3><ul><li>AI agents are <strong>autonomous systems</strong> that plan and execute complex tasks</li><li>Orchestration <strong>coordinates multiple agents</strong> to work together</li><li>Use <strong>specialized agents</strong> for different aspects of development</li><li>Define <strong>clear goals and boundaries</strong> for agent behavior</li><li>Implement <strong>monitoring and feedback loops</strong> to improve performance</li><li>Start simple and <strong>scale gradually</strong> as you learn</li><li>Consider <strong>security and cost</strong> implications of autonomous systems</li></ul><p>You''ve completed Module 4! You now understand the full Vibe Toolkit from frontend tools to AI agents. In Module 5, we''ll apply these tools to build real software, starting with debugging AI systems.</p></div>'
    WHERE module_id = v_module_id AND ordering = 5;
    RAISE NOTICE 'âœ… Lesson 15 Complete';
    
    RAISE NOTICE 'ðŸŽ‰ MODULE 4 COMPLETE! All 5 lessons done!';
    
END $$;
