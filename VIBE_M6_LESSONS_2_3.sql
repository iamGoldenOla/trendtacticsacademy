-- ==========================================
-- VIBE CODING MODULE 6 - LESSONS 2-3 (FINAL)
-- Authentication & State Management
-- Compact HTML formatting
-- ==========================================

DO $$
DECLARE
    v_course_id UUID;
    v_module_id UUID;
BEGIN
    SELECT id INTO v_course_id FROM courses WHERE title ILIKE '%Vibe Coding%' LIMIT 1;
    IF v_course_id IS NULL THEN RAISE EXCEPTION 'Vibe Coding course not found'; END IF;
    
    SELECT id INTO v_module_id FROM modules WHERE course_id = v_course_id AND ordering = 6 LIMIT 1;
    IF v_module_id IS NULL THEN RAISE EXCEPTION 'Module 6 not found'; END IF;
    
    RAISE NOTICE 'ðŸ“š Expanding Vibe Coding Module 6 (Lessons 2-3 FINAL)...';
    
    -- LESSON 20: Authentication & Roles
    UPDATE lessons SET content = '<div class="lesson-content"><h2>Authentication & Roles</h2><h3>Securing Your Application</h3><p>Authentication (who you are) and authorization (what you can do) are critical for any application. With AI assistance, you can implement secure auth systems without becoming a security expert. This lesson shows you how to build robust authentication with proper role-based access control.</p><h3>Understanding Auth Concepts</h3><p><strong>Authentication:</strong> Verifying user identity (login). <strong>Authorization:</strong> Determining what authenticated users can do (permissions). <strong>Session Management:</strong> Keeping users logged in securely. <strong>Role-Based Access Control (RBAC):</strong> Different permissions for different user types.</p><h3>Auth Strategies</h3><h4>1. Email/Password</h4><p>Traditional authentication. Prompt: "Implement email/password authentication with: Signup with email verification. Login with remember me option. Password reset via email. Password strength requirements. Account lockout after failed attempts. Secure password hashing (bcrypt or Argon2)."</p><h4>2. OAuth (Social Login)</h4><p>Login with Google, GitHub, etc. Prompt: "Add OAuth authentication: Google login. GitHub login. Automatic account creation on first login. Link OAuth accounts to existing users. Handle OAuth errors gracefully."</p><h4>3. Magic Links</h4><p>Passwordless login via email. Prompt: "Implement magic link authentication: User enters email. Send unique login link. Link expires after 15 minutes. One-time use only. Redirect to app after verification."</p><h4>4. Multi-Factor Authentication (MFA)</h4><p>Extra security layer. Prompt: "Add MFA support: SMS verification codes. Authenticator app (TOTP). Backup codes for account recovery. Optional for users, required for admins."</p><h3>Implementing Auth with Supabase</h3><h4>Basic Setup</h4><p>Prompt: "Set up Supabase authentication: Enable email/password auth. Configure email templates (welcome, password reset). Set up OAuth providers (Google, GitHub). Configure redirect URLs. Set session duration. Enable email confirmation."</p><h4>Signup Flow</h4><p>Prompt: "Create signup functionality: Form with email, password, name. Client-side validation. Call Supabase signup API. Send verification email. Show success message. Redirect to email verification page."</p><h4>Login Flow</h4><p>Prompt: "Create login functionality: Form with email and password. Remember me checkbox. Call Supabase login API. Handle errors (wrong password, unverified email). Redirect to dashboard on success. Store session securely."</p><h4>Password Reset</h4><p>Prompt: "Implement password reset: ''Forgot Password'' link on login page. User enters email. Send reset link via email. Reset link opens form for new password. Update password in Supabase. Auto-login after reset."</p><h3>Protected Routes</h3><h4>Frontend Protection</h4><p>Prompt: "Protect routes in Next.js: Check if user is authenticated. Redirect to login if not. Allow access if authenticated. Show loading state while checking. Handle session expiration."</p><h4>Backend Protection</h4><p>Prompt: "Protect API endpoints: Verify JWT token on each request. Extract user ID from token. Return 401 if not authenticated. Return 403 if not authorized. Rate limit authentication attempts."</p><h3>Role-Based Access Control</h3><h4>Defining Roles</h4><p>Prompt: "Set up user roles: Admin (full access to everything). Editor (can create/edit content). Viewer (read-only access). Guest (limited public access). Store role in users table."</p><h4>Checking Permissions</h4><p>Prompt: "Implement permission checks: Function to check if user has role. Function to check specific permissions. Middleware for route protection. UI elements hidden based on permissions. API endpoints protected by role."</p><h4>Example Permission System</h4><p>Prompt: "Create permissions for a blog: Admins can: manage users, publish/unpublish any post, delete any content. Editors can: create/edit their own posts, submit for review. Viewers can: read published posts, comment. Guests can: read published posts only."</p><h3>Session Management</h3><h4>Storing Sessions</h4><p>Prompt: "Implement secure session storage: Use HTTP-only cookies for tokens. Set appropriate expiration. Implement refresh tokens. Clear session on logout. Handle concurrent sessions."</p><h4>Session Persistence</h4><p>Prompt: "Keep users logged in: Store refresh token securely. Auto-refresh access token before expiry. Restore session on page reload. Handle token refresh failures. Logout if refresh fails."</p><h3>Advanced Auth Patterns</h3><h4>Impersonation (Admin Feature)</h4><p>Prompt: "Allow admins to impersonate users: Admin can view app as any user. Maintain audit log of impersonations. Easy switch back to admin account. Clear visual indicator when impersonating. Restrict sensitive actions while impersonating."</p><h4>Team/Organization Support</h4><p>Prompt: "Add multi-tenancy: Users can belong to multiple teams. Each team has own data isolation. Team roles (owner, admin, member). Invite users to teams. Switch between teams easily."</p><h4>API Keys for Programmatic Access</h4><p>Prompt: "Implement API key authentication: Users can generate API keys. Keys have specific permissions. Keys can be revoked. Rate limiting per key. Usage tracking and analytics."</p><h3>Security Best Practices</h3><h4>Password Security</h4><p>Prompt: "Implement password best practices: Minimum 8 characters. Require mix of letters, numbers, symbols. Check against common password lists. Hash with bcrypt (cost factor 12+). Never store plain text passwords. Never log passwords."</p><h4>Preventing Common Attacks</h4><p>Prompt: "Protect against: SQL injection (use parameterized queries). XSS (sanitize all inputs). CSRF (use tokens). Brute force (rate limiting, account lockout). Session hijacking (secure cookies, HTTPS only)."</p><h4>Secure Token Handling</h4><p>Prompt: "Handle tokens securely: Use short-lived access tokens (15 min). Use long-lived refresh tokens (7 days). Store tokens in HTTP-only cookies. Never expose tokens in URLs. Rotate refresh tokens on use."</p><h3>User Profile Management</h3><h4>Profile Updates</h4><p>Prompt: "Allow users to update profile: Change name, avatar, bio. Update email (requires verification). Change password (requires current password). Delete account (with confirmation). Download personal data (GDPR compliance)."</p><h4>Email Verification</h4><p>Prompt: "Implement email verification: Send verification email on signup. User clicks link to verify. Mark email as verified in database. Require verification for sensitive actions. Resend verification email option."</p><h3>Audit Logging</h3><p>Prompt: "Implement audit logs for security: Log all login attempts (success/failure). Log password changes. Log role changes. Log sensitive actions. Store IP address and user agent. Retention policy (90 days)."</p><h3>Testing Auth Systems</h3><p>Prompt: "Create tests for authentication: Test successful signup/login. Test invalid credentials. Test password reset flow. Test session expiration. Test role-based access. Test OAuth flows."</p><h3>Common Auth Challenges</h3><p><strong>Challenge:</strong> Users forget passwords frequently.<br><strong>Solution:</strong> Easy password reset, magic links, social login options.</p><p><strong>Challenge:</strong> Session management across devices.<br><strong>Solution:</strong> Refresh tokens, device management page, logout all devices option.</p><p><strong>Challenge:</strong> Balancing security and UX.<br><strong>Solution:</strong> Optional MFA, remember device, biometric auth on mobile.</p><h3>Key Takeaways</h3><ul><li>Authentication verifies <strong>who you are</strong>, authorization determines <strong>what you can do</strong></li><li>Use proven solutions like <strong>Supabase Auth</strong> rather than building from scratch</li><li>Implement <strong>multiple auth methods</strong>: email/password, OAuth, magic links</li><li>Use <strong>role-based access control</strong> for different permission levels</li><li>Follow <strong>security best practices</strong>: secure tokens, rate limiting, audit logs</li><li>Test <strong>thoroughly</strong>: successful flows, error cases, edge cases</li><li>Balance <strong>security and user experience</strong></li></ul><p>In the next lesson, we''ll explore state management, caching, and data persistence.</p></div>'
    WHERE module_id = v_module_id AND ordering = 2;
    RAISE NOTICE 'âœ… Lesson 20 Complete';
    
    -- LESSON 21: State, Caching & Persistence
    UPDATE lessons SET content = '<div class="lesson-content"><h2>State, Caching & Persistence</h2><h3>Managing Data in Your Application</h3><p>State management, caching, and persistence are about keeping your app fast, responsive, and reliable. With AI assistance, you can implement sophisticated data management without getting lost in complexity. This lesson teaches you how to handle state effectively in modern applications.</p><h3>Understanding State</h3><p><strong>Local State:</strong> Data specific to one component (form inputs, toggles). <strong>Global State:</strong> Data shared across components (user info, theme). <strong>Server State:</strong> Data from APIs (posts, user profiles). <strong>URL State:</strong> Data in the URL (current page, filters). <strong>Persistent State:</strong> Data that survives page reloads (preferences, cart).</p><h3>Local State with React</h3><h4>useState for Simple State</h4><p>Prompt: "Create a component with local state for: Form inputs (name, email). Toggle visibility (show/hide password). Counter (increment/decrement). Loading states."</p><h4>useReducer for Complex State</h4><p>Prompt: "Use useReducer for complex state management: Shopping cart (add, remove, update quantity). Multi-step form (next, previous, update field). Game state (move, undo, reset)."</p><h3>Global State Management</h3><h4>Context API</h4><p>Prompt: "Set up Context for global state: User authentication state. Theme (light/dark mode). Language preferences. Notification system. Provide context at app root. Consume in any component."</p><h4>Zustand (Recommended)</h4><p>Prompt: "Implement Zustand for state management: Create store for user data. Create store for app settings. Actions to update state. Persist state to localStorage. TypeScript types for safety."</p><h4>Redux (For Complex Apps)</h4><p>Prompt: "Set up Redux Toolkit: Configure store. Create slices for different features. Async actions with createAsyncThunk. Connect to React components. DevTools integration."</p><h3>Server State Management</h3><h4>React Query / TanStack Query</h4><p>Prompt: "Implement React Query for server state: Fetch data with useQuery. Mutations with useMutation. Automatic caching. Background refetching. Optimistic updates. Error handling. Loading states."</p><h4>SWR (Alternative)</h4><p>Prompt: "Use SWR for data fetching: Fetch with automatic revalidation. Cache management. Real-time updates. Pagination support. Optimistic UI. Error retry logic."</p><h3>Caching Strategies</h3><h4>Client-Side Caching</h4><p>Prompt: "Implement caching strategy: Cache API responses for 5 minutes. Invalidate cache on mutations. Cache user preferences indefinitely. Clear cache on logout. Show stale data while revalidating."</p><h4>Browser Storage</h4><p><strong>localStorage:</strong> Persistent, 5-10MB limit, synchronous. Prompt: "Store user preferences in localStorage: Theme, language, sidebar state. Sync across tabs. Handle storage events."</p><p><strong>sessionStorage:</strong> Clears on tab close. Prompt: "Use sessionStorage for: Form drafts, temporary filters, wizard progress."</p><p><strong>IndexedDB:</strong> Large data, async. Prompt: "Use IndexedDB for: Offline data storage, Large datasets, Complex queries."</p><h4>Service Workers & Offline Support</h4><p>Prompt: "Implement offline support: Cache static assets. Cache API responses. Serve cached data when offline. Sync data when back online. Show offline indicator."</p><h3>State Persistence Patterns</h3><h4>Persist Redux/Zustand State</h4><p>Prompt: "Persist Zustand state to localStorage: Save state on every change. Restore state on app load. Whitelist specific keys to persist. Handle migration for schema changes."</p><h4>Form State Persistence</h4><p>Prompt: "Auto-save form progress: Save to localStorage every 2 seconds. Restore on page reload. Clear on successful submit. Warn user about unsaved changes. Handle multiple forms."</p><h4>Shopping Cart Persistence</h4><p>Prompt: "Persist shopping cart: Save cart to localStorage. Sync with server for logged-in users. Merge local and server cart on login. Expire old cart items (30 days). Handle out-of-stock items."</p><h3>Optimistic Updates</h3><p>Prompt: "Implement optimistic UI updates: Update UI immediately on user action. Send request to server in background. Revert if server request fails. Show success/error feedback. Handle concurrent updates."</p><p>Example: "When user likes a post, increment count immediately, send API request, revert if request fails."</p><h3>Real-Time State Synchronization</h3><h4>WebSockets</h4><p>Prompt: "Implement WebSocket for real-time updates: Connect to WebSocket server. Listen for events (new message, user online). Update state on events. Reconnect on disconnect. Handle connection errors."</p><h4>Supabase Real-Time</h4><p>Prompt: "Use Supabase real-time subscriptions: Subscribe to table changes. Update UI when data changes. Handle inserts, updates, deletes. Unsubscribe on component unmount. Filter subscriptions by user."</p><h3>State Management Patterns</h3><h4>Pattern 1: Lifting State Up</h4><p>When multiple components need the same state, lift it to their common parent.</p><h4>Pattern 2: Compound Components</h4><p>Prompt: "Create compound components sharing state: Tabs component with Tab children. Accordion with Panel children. Shared state without prop drilling."</p><h4>Pattern 3: State Machines</h4><p>Prompt: "Implement state machine for: Multi-step form (idle â†’ filling â†’ validating â†’ submitting â†’ success/error). API request (idle â†’ loading â†’ success/error). Modal (closed â†’ opening â†’ open â†’ closing â†’ closed)."</p><h3>Performance Optimization</h3><h4>Memoization</h4><p>Prompt: "Optimize with memoization: useMemo for expensive calculations. useCallback for function references. React.memo for component re-renders. Memoize selectors in Redux/Zustand."</p><h4>Code Splitting</h4><p>Prompt: "Implement code splitting: Lazy load routes. Lazy load heavy components. Dynamic imports for features. Show loading fallback. Preload on hover."</p><h4>Virtualization</h4><p>Prompt: "Virtualize long lists: Use react-window or react-virtual. Render only visible items. Handle dynamic item heights. Maintain scroll position. Support infinite scroll."</p><h3>Debugging State Issues</h3><h4>Redux DevTools</h4><p>Prompt: "Set up Redux DevTools: Time-travel debugging. Inspect state changes. Replay actions. Export/import state. Monitor performance."</p><h4>React DevTools</h4><p>Prompt: "Use React DevTools to: Inspect component state. Track prop changes. Identify unnecessary re-renders. Profile performance. Debug hooks."</p><h3>Common State Management Mistakes</h3><p><strong>Mistake 1: Over-using Global State</strong><br>Not everything needs to be global. Keep state as local as possible.</p><p><strong>Mistake 2: Mutating State Directly</strong><br>Always create new objects/arrays when updating state.</p><p><strong>Mistake 3: Not Cleaning Up</strong><br>Unsubscribe from events, clear timers, cancel requests on unmount.</p><p><strong>Mistake 4: Prop Drilling</strong><br>Use Context or state management library instead of passing props through many levels.</p><h3>Testing State Management</h3><p>Prompt: "Create tests for state: Test state updates correctly. Test async state changes. Test error states. Test state persistence. Test state synchronization."</p><h3>Choosing the Right Solution</h3><p><strong>Small Apps:</strong> useState + Context<br><strong>Medium Apps:</strong> Zustand + React Query<br><strong>Large Apps:</strong> Redux Toolkit + React Query<br><strong>Real-Time Apps:</strong> Zustand + Supabase Real-Time</p><h3>Key Takeaways</h3><ul><li>Different types of state: <strong>local, global, server, URL, persistent</strong></li><li>Use <strong>appropriate tools</strong>: useState for local, Zustand for global, React Query for server</li><li>Implement <strong>caching</strong> to improve performance and UX</li><li><strong>Persist important state</strong> to localStorage or server</li><li>Use <strong>optimistic updates</strong> for responsive UX</li><li>Implement <strong>real-time sync</strong> for collaborative features</li><li>Optimize with <strong>memoization, code splitting, virtualization</strong></li><li>Keep state <strong>as local as possible</strong>, lift only when necessary</li></ul><p>You''ve completed Module 6! You now understand databases, authentication, and state management. In Module 7, we''ll explore advanced Vibe Coding topics including when NOT to use AI.</p></div>'
    WHERE module_id = v_module_id AND ordering = 3;
    RAISE NOTICE 'âœ… Lesson 21 Complete';
    
    RAISE NOTICE 'ðŸŽ‰ MODULE 6 COMPLETE! All 3 lessons done!';
    
END $$;
