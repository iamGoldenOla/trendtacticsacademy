-- ==========================================
-- VIBE CODING MODULE 4 - LESSONS 2-5
-- The Vibe Toolkit (Continued)
-- Compact HTML formatting
-- ==========================================

DO $$
DECLARE
    v_course_id UUID;
    v_module_id UUID;
BEGIN
    SELECT id INTO v_course_id FROM courses WHERE title ILIKE '%Vibe Coding%' LIMIT 1;
    IF v_course_id IS NULL THEN RAISE EXCEPTION 'Vibe Coding course not found'; END IF;
    
    SELECT id INTO v_module_id FROM modules WHERE course_id = v_course_id AND ordering = 4 LIMIT 1;
    IF v_module_id IS NULL THEN RAISE EXCEPTION 'Module 4 not found'; END IF;
    
    RAISE NOTICE 'ðŸ“š Expanding Vibe Coding Module 4 (Lessons 2-5)...';
    
    -- LESSON 12: Full-Stack & Auto Builders
    UPDATE lessons SET content = '<div class="lesson-content"><h2>Full-Stack & Auto Builders</h2><h3>Complete Applications from Descriptions</h3><p>Full-stack AI builders are revolutionary tools that generate entire working applicationsâ€”frontend, backend, database, and allâ€”from natural language descriptions. This lesson explores the best full-stack builders, how to use them effectively, and when they''re the right choice for your project.</p><h3>What Are Full-Stack Builders?</h3><p>Full-stack builders are AI tools that create complete, deployable applications including user interface, server logic, database schema, authentication, API endpoints, and deployment configuration. They handle the entire stack so you can focus on describing what you want to build.</p><h3>Top Full-Stack Builders</h3><h4>1. Replit</h4><p><strong>What it does:</strong> Cloud-based IDE with AI that builds full applications with backend logic and databases.</p><p><strong>Best for:</strong> Learning, prototypes with backend needs, collaborative coding</p><p><strong>Strengths:</strong> Integrated development environment. Built-in database (Replit DB). Instant deployment. Ghostwriter AI for code generation. Multiplayer coding support.</p><p><strong>Example use:</strong> "Build a URL shortener with user accounts. Users can create short links, view analytics, and manage their links."</p><h4>2. Bolt.new</h4><p><strong>What it does:</strong> Generates full web applications instantly with frontend and basic backend.</p><p><strong>Best for:</strong> Rapid prototyping, MVPs, simple full-stack apps</p><p><strong>Strengths:</strong> Extremely fast generation. No setup required. Instant preview. Great for beginners. Supports modern frameworks.</p><p><strong>Example use:</strong> "Create a recipe sharing app where users can post recipes, search by ingredients, and save favorites."</p><h4>3. Lovable (GPT Engineer)</h4><p><strong>What it does:</strong> Builds production-quality full-stack applications with beautiful UIs.</p><p><strong>Best for:</strong> SaaS products, customer-facing applications, design-focused projects</p><p><strong>Strengths:</strong> Exceptional design quality. Handles complex features. Iterative development built-in. Production-ready code.</p><p><strong>Example use:</strong> "Build a project management tool with kanban boards, team collaboration, and time tracking."</p><h4>4. v0 + Vercel</h4><p><strong>What it does:</strong> Generates React/Next.js applications with full-stack capabilities.</p><p><strong>Best for:</strong> Modern web apps, Next.js projects, scalable applications</p><p><strong>Strengths:</strong> Clean, maintainable code. Integrates with Vercel deployment. Server components support. API routes included.</p><p><strong>Example use:</strong> "Create a blog platform with markdown support, comments, and RSS feed."</p><h4>5. Cursor + Supabase</h4><p><strong>What it does:</strong> IDE with AI assistance paired with backend-as-a-service.</p><p><strong>Best for:</strong> Professional development, complex applications, team projects</p><p><strong>Strengths:</strong> Full control over code. Professional development environment. Powerful backend services. Scalable infrastructure.</p><p><strong>Example use:</strong> "Build a customer support ticketing system with real-time updates and file attachments."</p><h3>Choosing the Right Builder</h3><p><strong>For Learning:</strong> Use Replit - great educational environment with AI assistance.</p><p><strong>For Speed:</strong> Use Bolt.new - fastest from idea to working prototype.</p><p><strong>For Quality:</strong> Use Lovable - best design and user experience.</p><p><strong>For Scale:</strong> Use Cursor + Supabase - production-ready, scalable architecture.</p><p><strong>For Modern Stack:</strong> Use v0 + Vercel - cutting-edge Next.js applications.</p><h3>How to Describe Full-Stack Applications</h3><p>When prompting full-stack builders, provide comprehensive context:</p><h4>1. Define the Core Purpose</h4><p>"Build a habit tracking app where users can create daily habits, mark them complete, and see their streaks."</p><h4>2. Specify User Roles</h4><p>"There are two user types: regular users who track habits, and premium users who get analytics and custom themes."</p><h4>3. List Key Features</h4><p>"Features needed: User authentication, Habit creation and editing, Daily check-ins, Streak tracking, Progress charts, Reminder notifications."</p><h4>4. Describe Data Structure</h4><p>"Each habit has: name, description, frequency (daily/weekly), category, start date. Each check-in records: habit ID, date, completion status, optional note."</p><h4>5. Set Technical Preferences</h4><p>"Use Next.js for frontend, Supabase for backend and auth, Tailwind CSS for styling. Deploy to Vercel."</p><h3>Common Full-Stack Patterns</h3><h4>CRUD Applications</h4><p>"Build a contact management system. Users can create, read, update, and delete contacts. Each contact has name, email, phone, company, and notes."</p><h4>Social Features</h4><p>"Add user profiles, follow/unfollow functionality, activity feeds, and notifications."</p><h4>Real-Time Updates</h4><p>"Implement real-time chat using WebSockets. Messages should appear instantly for all users in a conversation."</p><h4>File Uploads</h4><p>"Allow users to upload profile pictures and documents. Store files securely and generate thumbnails for images."</p><h4>Search and Filtering</h4><p>"Add full-text search across all content. Include filters for date range, category, and status."</p><h3>Backend Considerations</h3><p>When building full-stack apps, specify backend requirements:</p><h4>Database</h4><p>"Use PostgreSQL for the database. Create tables for users, posts, comments, and likes with proper relationships."</p><h4>Authentication</h4><p>"Implement email/password authentication with password reset. Support OAuth with Google and GitHub."</p><h4>API Design</h4><p>"Create RESTful API endpoints: GET /api/posts, POST /api/posts, PUT /api/posts/:id, DELETE /api/posts/:id. Include pagination and sorting."</p><h4>Authorization</h4><p>"Users can only edit/delete their own posts. Admins can moderate all content. Implement role-based access control."</p><h4>Data Validation</h4><p>"Validate all inputs: email format, password strength (min 8 chars, 1 number), required fields. Return clear error messages."</p><h3>Deployment and Hosting</h3><p>Most full-stack builders handle deployment:</p><p><strong>Replit:</strong> Automatic deployment with custom domains available</p><p><strong>Bolt.new:</strong> Can export code for deployment elsewhere</p><p><strong>Lovable:</strong> Includes deployment as part of the platform</p><p><strong>Vercel:</strong> One-click deployment for Next.js apps</p><p><strong>Supabase:</strong> Handles backend hosting automatically</p><h3>Iterating on Full-Stack Apps</h3><p>Start with core functionality, then expand:</p><p><strong>Iteration 1:</strong> "Build basic user authentication and a simple dashboard."</p><p><strong>Iteration 2:</strong> "Add the main feature - task creation and listing."</p><p><strong>Iteration 3:</strong> "Implement task editing, deletion, and status updates."</p><p><strong>Iteration 4:</strong> "Add filtering, sorting, and search capabilities."</p><p><strong>Iteration 5:</strong> "Polish the UI and add loading states and error handling."</p><h3>Common Challenges and Solutions</h3><p><strong>Challenge:</strong> Database schema doesn''t match needs.<br><strong>Solution:</strong> Describe data relationships explicitly: "Users have many posts. Posts have many comments. Comments belong to users."</p><p><strong>Challenge:</strong> Authentication isn''t working correctly.<br><strong>Solution:</strong> Specify auth flow: "After signup, send verification email. After login, redirect to dashboard. Store session in HTTP-only cookies."</p><p><strong>Challenge:</strong> API endpoints are missing or incorrect.<br><strong>Solution:</strong> List all needed endpoints with methods and parameters explicitly.</p><p><strong>Challenge:</strong> Performance issues with large datasets.<br><strong>Solution:</strong> "Implement pagination (20 items per page), lazy loading for images, and database indexing on frequently queried fields."</p><h3>Testing Full-Stack Applications</h3><p>Test systematically: Frontend functionality (UI interactions work correctly), Backend logic (API endpoints return correct data), Database operations (data persists and retrieves correctly), Authentication (login, logout, protected routes work), Error handling (graceful failures with user-friendly messages), Edge cases (empty states, maximum limits, invalid inputs).</p><h3>Scaling Considerations</h3><p>As your app grows, consider: Database optimization (indexes, query optimization), Caching (Redis for frequently accessed data), CDN (for static assets and images), Load balancing (for high traffic), Background jobs (for time-consuming tasks), Monitoring (error tracking and performance metrics).</p><h3>Key Takeaways</h3><ul><li>Full-stack builders create <strong>complete applications</strong> from descriptions</li><li>Choose tools based on needs: <strong>Replit for learning, Bolt.new for speed, Lovable for quality</strong></li><li>Provide comprehensive context: <strong>purpose, features, data structure, tech preferences</strong></li><li>Start with <strong>core functionality</strong> and iterate to add features</li><li>Specify <strong>backend requirements</strong> explicitly (database, auth, APIs)</li><li>Test <strong>systematically</strong> across all layers of the stack</li><li>Consider <strong>scaling</strong> from the beginning for production apps</li></ul><p>In the next lesson, we''ll explore Backend, Logic & Data tools that give you more control over server-side functionality.</p></div>'
    WHERE module_id = v_module_id AND ordering = 2;
    RAISE NOTICE 'âœ… Lesson 12 Complete';
    
    -- LESSON 13: Backend, Logic & Data
    UPDATE lessons SET content = '<div class="lesson-content"><h2>Backend, Logic & Data</h2><h3>Powering Your Applications</h3><p>While frontend tools create what users see, backend tools handle what makes your application actually work: data storage, business logic, authentication, APIs, and server-side processing. This lesson explores AI-powered backend tools and how to use them effectively.</p><h3>Understanding the Backend Layer</h3><p>The backend consists of several components: Database (stores and retrieves data), API (exposes functionality to the frontend), Authentication (manages user identity and access), Business Logic (processes data and enforces rules), Background Jobs (handles time-consuming tasks), File Storage (manages uploads and media).</p><h3>Top Backend AI Tools</h3><h4>1. Supabase</h4><p><strong>What it does:</strong> Open-source Firebase alternative with PostgreSQL database, authentication, storage, and real-time subscriptions.</p><p><strong>Best for:</strong> Modern web apps, real-time features, PostgreSQL projects</p><p><strong>AI Features:</strong> SQL query generation from natural language. Schema design assistance. Automatic API generation. Security policy suggestions.</p><p><strong>Example use:</strong> "Create a database schema for a blog with users, posts, comments, and tags. Set up row-level security so users can only edit their own posts."</p><h4>2. Firebase</h4><p><strong>What it does:</strong> Google''s backend-as-a-service with NoSQL database, authentication, hosting, and cloud functions.</p><p><strong>Best for:</strong> Real-time apps, mobile backends, rapid prototyping</p><p><strong>AI Features:</strong> Firestore query assistance. Security rules generation. Cloud function templates.</p><p><strong>Example use:</strong> "Set up Firebase authentication with email/password and Google OAuth. Create Firestore collections for users and their data."</p><h4>3. Xano</h4><p><strong>What it does:</strong> No-code backend builder with visual database designer and API creator.</p><p><strong>Best for:</strong> No-code projects, complex business logic, rapid API development</p><p><strong>AI Features:</strong> Natural language to API endpoint. Database relationship suggestions. Query optimization.</p><p><strong>Example use:</strong> "Create an API endpoint that returns all active users with their post count, sorted by join date."</p><h4>4. Railway</h4><p><strong>What it does:</strong> Platform for deploying backends, databases, and services with AI assistance.</p><p><strong>Best for:</strong> Custom backends, microservices, database hosting</p><p><strong>AI Features:</strong> Deployment configuration assistance. Database setup guidance. Service orchestration.</p><p><strong>Example use:</strong> "Deploy a Node.js API with PostgreSQL database. Set up automatic backups and staging environment."</p><h3>Database Design with AI</h3><p>AI can help design your database schema:</p><h4>Describing Your Data Model</h4><p>"I need a database for an e-commerce store. Entities: Users (email, name, address), Products (name, description, price, inventory), Orders (user, products, total, status), Reviews (user, product, rating, comment). Users can have many orders. Orders can have many products. Products can have many reviews."</p><h4>AI Generates Schema</h4><p>AI creates tables with proper data types, relationships (foreign keys), indexes for performance, and constraints for data integrity.</p><h4>Refining the Schema</h4><p>"Add a categories table. Products belong to categories. Add created_at and updated_at timestamps to all tables. Add a soft delete flag to products."</p><h3>API Development with AI</h3><p>Create APIs by describing endpoints:</p><h4>RESTful APIs</h4><p>"Create REST API for blog posts: GET /api/posts - list all posts with pagination. GET /api/posts/:id - get single post with comments. POST /api/posts - create new post (auth required). PUT /api/posts/:id - update post (owner only). DELETE /api/posts/:id - delete post (owner only)."</p><h4>GraphQL APIs</h4><p>"Create a GraphQL API with queries for users, posts, and comments. Include mutations for creating and updating posts. Add subscriptions for real-time comment updates."</p><h4>Webhooks</h4><p>"Set up a webhook endpoint that receives Stripe payment events. On successful payment, create an order record and send confirmation email."</p><h3>Authentication and Authorization</h3><p>AI can implement auth systems:</p><h4>Authentication Setup</h4><p>"Implement authentication with: Email/password signup and login. Email verification required. Password reset via email. OAuth with Google and GitHub. JWT tokens for session management. Refresh token rotation."</p><h4>Authorization Rules</h4><p>"Authorization rules: Public users can read posts. Authenticated users can create posts and comments. Users can edit/delete only their own content. Admins can moderate all content. Premium users get additional features."</p><h4>Row-Level Security</h4><p>"In Supabase, set up RLS policies: Users can read all public posts. Users can insert posts with their own user_id. Users can update/delete only their own posts. Admins bypass all restrictions."</p><h3>Business Logic Implementation</h3><p>Describe complex logic in plain language:</p><h4>Example: Order Processing</h4><p>"When an order is placed: Validate all items are in stock. Calculate total with tax and shipping. Create order record with ''pending'' status. Reduce inventory for each item. Send confirmation email to user. If payment succeeds, update status to ''confirmed''. If payment fails, restore inventory and update status to ''failed''."</p><h4>Example: Recommendation System</h4><p>"Recommend products to users based on: Their purchase history. Items frequently bought together. Products in categories they''ve browsed. Trending items in their region. Limit to 10 recommendations, prioritize by relevance score."</p><h3>Data Validation and Sanitization</h3><p>Ensure data integrity:</p><p>"Validate all inputs: Email must be valid format. Password minimum 8 characters, must include number and special character. Username 3-20 characters, alphanumeric only. Age must be 18+. Phone number must match format (XXX) XXX-XXXX. Sanitize all text inputs to prevent XSS attacks."</p><h3>Background Jobs and Queues</h3><p>Handle async tasks:</p><p>"Set up background jobs for: Sending bulk emails (process in batches of 100). Generating PDF reports (queue and notify when ready). Processing uploaded images (resize, optimize, create thumbnails). Cleaning up old data (run daily at 2 AM). Syncing with external APIs (retry on failure with exponential backoff)."</p><h3>File Storage and Management</h3><p>Handle file uploads:</p><p>"Implement file upload system: Accept images (JPG, PNG, WebP) up to 5MB. Store in cloud storage (S3 or Supabase Storage). Generate thumbnails (200x200, 400x400). Create unique filenames to prevent collisions. Scan for malware before accepting. Return public URL for access."</p><h3>Real-Time Features</h3><p>Add live updates:</p><p>"Implement real-time chat: Messages appear instantly for all participants. Show typing indicators. Display online/offline status. Persist messages in database. Support message editing and deletion. Notify users of new messages when offline."</p><h3>Caching Strategies</h3><p>Improve performance:</p><p>"Implement caching: Cache frequently accessed data (user profiles, popular posts) for 5 minutes. Use Redis for session storage. Cache API responses with appropriate TTL. Invalidate cache when data changes. Implement cache warming for critical data."</p><h3>Error Handling and Logging</h3><p>Build robust systems:</p><p>"Error handling strategy: Catch all errors and log details (timestamp, user, action, error message). Return user-friendly error messages (never expose internal details). For critical errors, send alerts to admin. Log all API requests with response times. Track failed login attempts for security."</p><h3>Database Optimization</h3><p>Keep your database fast:</p><p>"Optimize database: Add indexes on frequently queried fields (user_id, created_at, status). Use database views for complex queries. Implement pagination (never load all records). Archive old data to separate tables. Monitor slow queries and optimize. Use connection pooling for efficiency."</p><h3>Testing Backend Logic</h3><p>Ensure reliability: Unit tests for business logic functions. Integration tests for API endpoints. Database transaction tests. Authentication flow tests. Error handling tests. Load testing for performance.</p><h3>Common Backend Patterns</h3><p><strong>CRUD Operations:</strong> "Create standard CRUD endpoints for [entity] with validation, auth, and error handling."</p><p><strong>Pagination:</strong> "Implement cursor-based pagination returning 20 items per page with next/previous cursors."</p><p><strong>Search:</strong> "Add full-text search across [fields] with fuzzy matching and relevance scoring."</p><p><strong>Batch Operations:</strong> "Allow bulk updates/deletes with transaction support - all succeed or all fail."</p><h3>Security Best Practices</h3><p>Protect your backend: Use parameterized queries (prevent SQL injection). Validate and sanitize all inputs. Implement rate limiting (prevent abuse). Use HTTPS only (encrypt data in transit). Store passwords hashed (bcrypt, Argon2). Implement CORS properly. Keep dependencies updated. Use environment variables for secrets.</p><h3>Key Takeaways</h3><ul><li>Backend tools handle <strong>data, logic, auth, and APIs</strong></li><li>Top choices: <strong>Supabase for PostgreSQL, Firebase for real-time, Xano for no-code</strong></li><li>Describe <strong>data models, APIs, and business logic</strong> in plain language</li><li>Implement <strong>proper validation, error handling, and security</strong></li><li>Use <strong>caching and optimization</strong> for performance</li><li>Test <strong>thoroughly</strong> at all levels</li><li>Follow <strong>security best practices</strong> to protect user data</li></ul><p>In the next lesson, we''ll explore Agentic IDEs - powerful development environments that act as your coding partner.</p></div>'
    WHERE module_id = v_module_id AND ordering = 3;
    RAISE NOTICE 'âœ… Lesson 13 Complete';
    
    RAISE NOTICE 'ðŸŽ‰ Module 4 Lessons 2-3 Complete! (2 more to go)';
    
END $$;
